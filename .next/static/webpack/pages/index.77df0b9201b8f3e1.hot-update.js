"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./services/admin.ts":
/*!***************************!*\
  !*** ./services/admin.ts ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addAdmin: function() { return /* binding */ addAdmin; },\n/* harmony export */   checkIsAdmin: function() { return /* binding */ checkIsAdmin; },\n/* harmony export */   checkIsInstitution: function() { return /* binding */ checkIsInstitution; },\n/* harmony export */   getAdminStats: function() { return /* binding */ getAdminStats; },\n/* harmony export */   getAllUsersByRole: function() { return /* binding */ getAllUsersByRole; },\n/* harmony export */   getDetailedUserData: function() { return /* binding */ getDetailedUserData; },\n/* harmony export */   getIdentityContract: function() { return /* binding */ getIdentityContract; },\n/* harmony export */   pauseContract: function() { return /* binding */ pauseContract; },\n/* harmony export */   removeAdmin: function() { return /* binding */ removeAdmin; },\n/* harmony export */   unpauseContract: function() { return /* binding */ unpauseContract; },\n/* harmony export */   updateUserRole: function() { return /* binding */ updateUserRole; },\n/* harmony export */   verifyAllPendingInstitutions: function() { return /* binding */ verifyAllPendingInstitutions; },\n/* harmony export */   verifyUser: function() { return /* binding */ verifyUser; }\n/* harmony export */ });\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ethers */ \"./node_modules/ethers/lib.esm/index.js\");\n/* harmony import */ var _constants_abis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/abis */ \"./constants/abis.ts\");\n/* harmony import */ var utils_ethersConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! utils/ethersConfig */ \"./utils/ethersConfig.ts\");\n/* harmony import */ var _utils_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/config */ \"./utils/config.ts\");\n/* harmony import */ var _examManagement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./examManagement */ \"./services/examManagement.ts\");\n\n\n\n\n\n/**\r\n * Get the Identity contract instance\r\n * @param runner - Optional signer or provider\r\n * @returns The Identity contract instance\r\n */ const getIdentityContract = async (runner)=>{\n    var _process_env_NEXT_PUBLIC_IDENTITY_CONTRACT_ADDRESS;\n    const contractAddress = ((_process_env_NEXT_PUBLIC_IDENTITY_CONTRACT_ADDRESS = \"0x911E250f1398F007704D0F6A527a6a71560a3B93\") === null || _process_env_NEXT_PUBLIC_IDENTITY_CONTRACT_ADDRESS === void 0 ? void 0 : _process_env_NEXT_PUBLIC_IDENTITY_CONTRACT_ADDRESS.toString()) || (0,_utils_config__WEBPACK_IMPORTED_MODULE_2__.getConfig)(\"IDENTITY_CONTRACT_ADDRESS\");\n    const runnerInstance = runner || await (0,utils_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getProvider)();\n    return new ethers__WEBPACK_IMPORTED_MODULE_4__.ethers.Contract(contractAddress, _constants_abis__WEBPACK_IMPORTED_MODULE_0__.IdentityABI, runnerInstance);\n};\n/**\r\n * Get all users by role\r\n * @param role - User role (1: Student, 2: Institution, 3: Employer, 4: Admin)\r\n * @returns Array of addresses with the specified role\r\n */ const getAllUsersByRole = async (role)=>{\n    try {\n        const provider = await (0,utils_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getProvider)();\n        const contract = await getIdentityContract(provider);\n        const addresses = await contract.getUsersByRole(role);\n        return addresses;\n    } catch (error) {\n        console.error(\"Error getting users by role:\", error);\n        return [];\n    }\n};\n/**\r\n * Get detailed user data\r\n * @param address - User address\r\n * @returns User data object or null if error occurs\r\n */ const getDetailedUserData = async (address)=>{\n    try {\n        const provider = await (0,utils_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getProvider)();\n        const contract = await getIdentityContract(provider);\n        const data = await contract.getUserData(address);\n        return {\n            userAddress: data[0],\n            ipfsHash: data[1],\n            role: data[2],\n            isVerified: data[3],\n            createdAt: new Date(Number(data[4]) * 1000)\n        };\n    } catch (error) {\n        console.error(\"Error getting user data:\", error);\n        return null;\n    }\n};\n/**\r\n * Verify a user (admin only)\r\n * @param userAddress - Address of the user to verify\r\n * @returns Result object with success status and transaction details\r\n */ const verifyUser = async (userAddress)=>{\n    try {\n        const signer = await (0,utils_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getSigner)();\n        const identityContract = await getIdentityContract(signer);\n        const examManagementContract = await (0,_examManagement__WEBPACK_IMPORTED_MODULE_3__.getExamManagementContract)(signer);\n        // Ensure caller is admin\n        const signerAddress = await signer.getAddress();\n        const isAdmin = await identityContract.isAdmin(signerAddress);\n        if (!isAdmin) {\n            return {\n                success: false,\n                message: \"Only admins can verify users\"\n            };\n        }\n        const examManagementTx = await examManagementContract.verifyInstitution(userAddress);\n        await examManagementTx.wait();\n        const identityTx = await identityContract.verifyUser(userAddress);\n        await identityTx.wait();\n        return {\n            success: true,\n            message: \"User verified successfully\",\n            examManagementHash: examManagementTx.hash,\n            identityHash: identityTx.hash\n        };\n    } catch (error) {\n        console.error(\"Error verifying user:\", error);\n        return {\n            success: false,\n            message: error.message || \"Failed to verify user\"\n        };\n    }\n};\n/**\r\n * Add a new admin (owner only)\r\n * @param adminAddress - Address to add as admin\r\n * @returns Result object with success status and transaction details\r\n */ const addAdmin = async (adminAddress)=>{\n    try {\n        const signer = await (0,utils_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getSigner)();\n        const contract = await getIdentityContract(signer);\n        const tx = await contract.addAdmin(adminAddress);\n        await tx.wait();\n        return {\n            success: true,\n            message: \"Admin added successfully\",\n            hash: tx.hash\n        };\n    } catch (error) {\n        console.error(\"Error adding admin:\", error);\n        return {\n            success: false,\n            message: error.message || \"Failed to add admin\"\n        };\n    }\n};\n/**\r\n * Remove an admin (owner only)\r\n * @param adminAddress - Address to remove from admin role\r\n * @returns Result object with success status and transaction details\r\n */ const removeAdmin = async (adminAddress)=>{\n    try {\n        const signer = await (0,utils_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getSigner)();\n        const contract = await getIdentityContract(signer);\n        const tx = await contract.removeAdmin(adminAddress);\n        await tx.wait();\n        return {\n            success: true,\n            message: \"Admin removed successfully\",\n            hash: tx.hash\n        };\n    } catch (error) {\n        console.error(\"Error removing admin:\", error);\n        return {\n            success: false,\n            message: error.message || \"Failed to remove admin\"\n        };\n    }\n};\n/**\r\n * Check if an address is an admin\r\n * @param address - Address to check\r\n * @returns Boolean indicating if the address is an admin\r\n */ const checkIsAdmin = async (address)=>{\n    try {\n        const provider = await (0,utils_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getProvider)();\n        const contract = await getIdentityContract(provider);\n        return await contract.isAdmin(address);\n    } catch (error) {\n        console.error(\"Error checking admin status:\", error);\n        return false;\n    }\n};\n/**\r\n * Check if an address is an institution\r\n * @param address - Address to check\r\n * @returns Boolean indicating if the address is an institution\r\n */ const checkIsInstitution = async (address)=>{\n    try {\n        const provider = await (0,utils_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getProvider)();\n        const contract = await getIdentityContract(provider);\n        return await contract.isInstitution(address);\n    } catch (error) {\n        console.error(\"Error checking institution status:\", error);\n        return false;\n    }\n};\n/**\r\n * Update a user's role (admin only)\r\n * @param userAddress - Address of the user\r\n * @param newRole - New role to assign (1: Student, 2: Institution, 3: Employer)\r\n * @returns Result object with success status and transaction details\r\n */ const updateUserRole = async (userAddress, newRole)=>{\n    try {\n        const signer = await (0,utils_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getSigner)();\n        const contract = await getIdentityContract(signer);\n        // Ensure caller is admin\n        const signerAddress = await signer.getAddress();\n        const isAdmin = await contract.isAdmin(signerAddress);\n        if (!isAdmin) {\n            return {\n                success: false,\n                message: \"Only admins can update user roles\"\n            };\n        }\n        const tx = await contract.updateUserRole(userAddress, newRole);\n        await tx.wait();\n        return {\n            success: true,\n            message: \"User role updated successfully\",\n            hash: tx.hash\n        };\n    } catch (error) {\n        console.error(\"Error updating user role:\", error);\n        return {\n            success: false,\n            message: error.message || \"Failed to update user role\"\n        };\n    }\n};\n/**\r\n * Pause the Identity contract (admin only)\r\n * @returns Result object with success status and transaction details\r\n */ const pauseContract = async ()=>{\n    try {\n        const signer = await (0,utils_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getSigner)();\n        const contract = await getIdentityContract(signer);\n        // Ensure caller is admin\n        const signerAddress = await signer.getAddress();\n        const isAdmin = await contract.isAdmin(signerAddress);\n        if (!isAdmin) {\n            return {\n                success: false,\n                message: \"Only admins can pause the contract\"\n            };\n        }\n        const tx = await contract.pause();\n        await tx.wait();\n        return {\n            success: true,\n            message: \"Contract paused successfully\",\n            hash: tx.hash\n        };\n    } catch (error) {\n        console.error(\"Error pausing contract:\", error);\n        return {\n            success: false,\n            message: error.message || \"Failed to pause contract\"\n        };\n    }\n};\n/**\r\n * Unpause the Identity contract (admin only)\r\n * @returns Result object with success status and transaction details\r\n */ const unpauseContract = async ()=>{\n    try {\n        const signer = await (0,utils_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getSigner)();\n        const contract = await getIdentityContract(signer);\n        // Ensure caller is admin\n        const signerAddress = await signer.getAddress();\n        const isAdmin = await contract.isAdmin(signerAddress);\n        if (!isAdmin) {\n            return {\n                success: false,\n                message: \"Only admins can unpause the contract\"\n            };\n        }\n        const tx = await contract.unpause();\n        await tx.wait();\n        return {\n            success: true,\n            message: \"Contract unpaused successfully\",\n            hash: tx.hash\n        };\n    } catch (error) {\n        console.error(\"Error unpausing contract:\", error);\n        return {\n            success: false,\n            message: error.message || \"Failed to unpause contract\"\n        };\n    }\n};\n/**\r\n * Verify all institutions that aren't verified yet\r\n * @returns Result object with success status and counts\r\n */ const verifyAllPendingInstitutions = async ()=>{\n    try {\n        const institutionAddresses = await getAllUsersByRole(2); // Role 2 is Institution\n        const signer = await (0,utils_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getSigner)();\n        const contract = await getIdentityContract(signer);\n        // Ensure caller is admin\n        const signerAddress = await signer.getAddress();\n        const isAdmin = await contract.isAdmin(signerAddress);\n        if (!isAdmin) {\n            return {\n                success: false,\n                message: \"Only admins can perform batch verification\"\n            };\n        }\n        let verifiedCount = 0;\n        let failedCount = 0;\n        for (const address of institutionAddresses){\n            try {\n                const userData = await getDetailedUserData(address);\n                if (userData && !userData.isVerified) {\n                    const tx = await contract.verifyUser(address);\n                    await tx.wait();\n                    verifiedCount++;\n                }\n            } catch (error) {\n                console.error(\"Failed to verify institution \".concat(address, \":\"), error);\n                failedCount++;\n            }\n        }\n        return {\n            success: true,\n            message: \"Verified \".concat(verifiedCount, \" institutions. Failed: \").concat(failedCount),\n            verifiedCount,\n            failedCount\n        };\n    } catch (error) {\n        console.error(\"Error in batch verification:\", error);\n        return {\n            success: false,\n            message: error.message || \"Failed to perform batch verification\"\n        };\n    }\n};\n/**\r\n * Get admin dashboard statistics\r\n * @returns Statistics for the admin dashboard\r\n */ const getAdminStats = async ()=>{\n    try {\n        const students = await getAllUsersByRole(1); // Role 1 is Student\n        const institutions = await getAllUsersByRole(2); // Role 2 is Institution\n        const employers = await getAllUsersByRole(3); // Role 3 is Employer\n        const admins = await getAllUsersByRole(4); // Role 4 is Admin\n        return {\n            studentCount: students.length,\n            institutionCount: institutions.length,\n            employerCount: employers.length,\n            adminCount: admins.length,\n            totalUserCount: students.length + institutions.length + employers.length + admins.length\n        };\n    } catch (error) {\n        console.error(\"Error getting admin stats:\", error);\n        return {\n            studentCount: 0,\n            institutionCount: 0,\n            employerCount: 0,\n            adminCount: 0,\n            totalUserCount: 0\n        };\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QXFCO1FBQ25FLE1BQU13RCxTQUFTLE1BQU14RCxrQkFBa0IsSUFBSSxrQkFBa0I7UUFFN0QsT0FBTztZQUNMeUQsY0FBY0osU0FBU0ssTUFBTTtZQUM3QkMsa0JBQWtCTCxhQUFhSSxNQUFNO1lBQ3JDRSxlQUFlTCxVQUFVRyxNQUFNO1lBQy9CRyxZQUFZTCxPQUFPRSxNQUFNO1lBQ3pCSSxnQkFBZ0JULFNBQVNLLE1BQU0sR0FBR0osYUFBYUksTUFBTSxHQUFHSCxVQUFVRyxNQUFNLEdBQUdGLE9BQU9FLE1BQU07UUFDMUY7SUFDRixFQUFFLE9BQU9wRCxPQUFZO1FBQ25CQyxRQUFRRCxLQUFLLENBQUMsOEJBQThCQTtRQUM1QyxPQUFPO1lBQ0xtRCxjQUFjO1lBQ2RFLGtCQUFrQjtZQUNsQkMsZUFBZTtZQUNmQyxZQUFZO1lBQ1pDLGdCQUFnQjtRQUNsQjtJQUNGO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zZXJ2aWNlcy9hZG1pbi50cz81NjQwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGV0aGVycyB9IGZyb20gJ2V0aGVycyc7XHJcbmltcG9ydCB7IElkZW50aXR5QUJJIH0gZnJvbSAnLi4vY29uc3RhbnRzL2FiaXMnO1xyXG5pbXBvcnQgeyBnZXRQcm92aWRlciwgZ2V0U2lnbmVyIH0gZnJvbSAndXRpbHMvZXRoZXJzQ29uZmlnJztcclxuaW1wb3J0IHsgZ2V0Q29uZmlnIH0gZnJvbSAnLi4vdXRpbHMvY29uZmlnJztcclxuaW1wb3J0IHsgZ2V0RXhhbU1hbmFnZW1lbnRDb250cmFjdCB9IGZyb20gJy4vZXhhbU1hbmFnZW1lbnQnO1xyXG50eXBlIElkZW50aXR5Q29udHJhY3RUeXBlID0gZXRoZXJzLkNvbnRyYWN0ICYge1xyXG4gIGdldFVzZXJzQnlSb2xlKHJvbGU6IG51bWJlcik6IFByb21pc2U8c3RyaW5nW10+O1xyXG4gIGdldFVzZXJEYXRhKGFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8W3N0cmluZywgc3RyaW5nLCBudW1iZXIsIGJvb2xlYW4sIG51bWJlcl0+O1xyXG4gIHZlcmlmeVVzZXIoYWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTxhbnk+O1xyXG4gIGFkZEFkbWluKGFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8YW55PjtcclxuICByZW1vdmVBZG1pbihhZGRyZXNzOiBzdHJpbmcpOiBQcm9taXNlPGFueT47XHJcbiAgaXNBZG1pbihhZGRyZXNzOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+O1xyXG4gIGlzSW5zdGl0dXRpb24oYWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPjtcclxuICB1cGRhdGVVc2VyUm9sZShhZGRyZXNzOiBzdHJpbmcsIHJvbGU6IG51bWJlcik6IFByb21pc2U8YW55PjtcclxuICBwYXVzZSgpOiBQcm9taXNlPGFueT47XHJcbiAgdW5wYXVzZSgpOiBQcm9taXNlPGFueT47XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBJZGVudGl0eSBjb250cmFjdCBpbnN0YW5jZVxyXG4gKiBAcGFyYW0gcnVubmVyIC0gT3B0aW9uYWwgc2lnbmVyIG9yIHByb3ZpZGVyXHJcbiAqIEByZXR1cm5zIFRoZSBJZGVudGl0eSBjb250cmFjdCBpbnN0YW5jZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGdldElkZW50aXR5Q29udHJhY3QgPSBhc3luYyAocnVubmVyPzogZXRoZXJzLlNpZ25lciB8IGV0aGVycy5Qcm92aWRlcikgPT4ge1xyXG4gIGNvbnN0IGNvbnRyYWN0QWRkcmVzcyA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0lERU5USVRZX0NPTlRSQUNUX0FERFJFU1M/LnRvU3RyaW5nKCkgfHwgZ2V0Q29uZmlnKCdJREVOVElUWV9DT05UUkFDVF9BRERSRVNTJyk7XHJcbiAgY29uc3QgcnVubmVySW5zdGFuY2UgPSBydW5uZXIgfHwgYXdhaXQgZ2V0UHJvdmlkZXIoKTtcclxuICByZXR1cm4gbmV3IGV0aGVycy5Db250cmFjdChjb250cmFjdEFkZHJlc3MsIElkZW50aXR5QUJJLCBydW5uZXJJbnN0YW5jZSkgYXMgdW5rbm93biBhcyBJZGVudGl0eUNvbnRyYWN0VHlwZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgYWxsIHVzZXJzIGJ5IHJvbGVcclxuICogQHBhcmFtIHJvbGUgLSBVc2VyIHJvbGUgKDE6IFN0dWRlbnQsIDI6IEluc3RpdHV0aW9uLCAzOiBFbXBsb3llciwgNDogQWRtaW4pXHJcbiAqIEByZXR1cm5zIEFycmF5IG9mIGFkZHJlc3NlcyB3aXRoIHRoZSBzcGVjaWZpZWQgcm9sZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGdldEFsbFVzZXJzQnlSb2xlID0gYXN5bmMgKHJvbGU6IG51bWJlcikgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IGdldFByb3ZpZGVyKCk7XHJcbiAgICBjb25zdCBjb250cmFjdCA9IGF3YWl0IGdldElkZW50aXR5Q29udHJhY3QocHJvdmlkZXIpO1xyXG4gICAgY29uc3QgYWRkcmVzc2VzID0gYXdhaXQgY29udHJhY3QuZ2V0VXNlcnNCeVJvbGUocm9sZSk7XHJcbiAgICByZXR1cm4gYWRkcmVzc2VzO1xyXG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgdXNlcnMgYnkgcm9sZTonLCBlcnJvcik7XHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldCBkZXRhaWxlZCB1c2VyIGRhdGFcclxuICogQHBhcmFtIGFkZHJlc3MgLSBVc2VyIGFkZHJlc3NcclxuICogQHJldHVybnMgVXNlciBkYXRhIG9iamVjdCBvciBudWxsIGlmIGVycm9yIG9jY3Vyc1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGdldERldGFpbGVkVXNlckRhdGEgPSBhc3luYyAoYWRkcmVzczogc3RyaW5nKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgZ2V0UHJvdmlkZXIoKTtcclxuICAgIGNvbnN0IGNvbnRyYWN0ID0gYXdhaXQgZ2V0SWRlbnRpdHlDb250cmFjdChwcm92aWRlcik7XHJcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgY29udHJhY3QuZ2V0VXNlckRhdGEoYWRkcmVzcyk7XHJcbiAgICBcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHVzZXJBZGRyZXNzOiBkYXRhWzBdLFxyXG4gICAgICBpcGZzSGFzaDogZGF0YVsxXSxcclxuICAgICAgcm9sZTogZGF0YVsyXSxcclxuICAgICAgaXNWZXJpZmllZDogZGF0YVszXSxcclxuICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZShOdW1iZXIoZGF0YVs0XSkgKiAxMDAwKVxyXG4gICAgfTtcclxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHVzZXIgZGF0YTonLCBlcnJvcik7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogVmVyaWZ5IGEgdXNlciAoYWRtaW4gb25seSlcclxuICogQHBhcmFtIHVzZXJBZGRyZXNzIC0gQWRkcmVzcyBvZiB0aGUgdXNlciB0byB2ZXJpZnlcclxuICogQHJldHVybnMgUmVzdWx0IG9iamVjdCB3aXRoIHN1Y2Nlc3Mgc3RhdHVzIGFuZCB0cmFuc2FjdGlvbiBkZXRhaWxzXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgdmVyaWZ5VXNlciA9IGFzeW5jICh1c2VyQWRkcmVzczogc3RyaW5nKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IGdldFNpZ25lcigpO1xyXG4gICAgY29uc3QgaWRlbnRpdHlDb250cmFjdCA9IGF3YWl0IGdldElkZW50aXR5Q29udHJhY3Qoc2lnbmVyKTtcclxuICAgIGNvbnN0IGV4YW1NYW5hZ2VtZW50Q29udHJhY3QgPSBhd2FpdCBnZXRFeGFtTWFuYWdlbWVudENvbnRyYWN0KHNpZ25lcik7XHJcbiAgICBcclxuICAgIC8vIEVuc3VyZSBjYWxsZXIgaXMgYWRtaW5cclxuICAgIGNvbnN0IHNpZ25lckFkZHJlc3MgPSBhd2FpdCBzaWduZXIuZ2V0QWRkcmVzcygpO1xyXG4gICAgY29uc3QgaXNBZG1pbiA9IGF3YWl0IGlkZW50aXR5Q29udHJhY3QuaXNBZG1pbihzaWduZXJBZGRyZXNzKTtcclxuICAgIFxyXG4gICAgaWYgKCFpc0FkbWluKSB7XHJcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBtZXNzYWdlOiAnT25seSBhZG1pbnMgY2FuIHZlcmlmeSB1c2VycycgfTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBleGFtTWFuYWdlbWVudFR4ID0gYXdhaXQgZXhhbU1hbmFnZW1lbnRDb250cmFjdC52ZXJpZnlJbnN0aXR1dGlvbih1c2VyQWRkcmVzcyk7XHJcbiAgICBhd2FpdCBleGFtTWFuYWdlbWVudFR4LndhaXQoKTtcclxuICAgIFxyXG4gICAgY29uc3QgaWRlbnRpdHlUeCA9IGF3YWl0IGlkZW50aXR5Q29udHJhY3QudmVyaWZ5VXNlcih1c2VyQWRkcmVzcyk7XHJcbiAgICBhd2FpdCBpZGVudGl0eVR4LndhaXQoKTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc3VjY2VzczogdHJ1ZSxcclxuICAgICAgbWVzc2FnZTogJ1VzZXIgdmVyaWZpZWQgc3VjY2Vzc2Z1bGx5JyxcclxuICAgICAgZXhhbU1hbmFnZW1lbnRIYXNoOiBleGFtTWFuYWdlbWVudFR4Lmhhc2gsXHJcbiAgICAgIGlkZW50aXR5SGFzaDogaWRlbnRpdHlUeC5oYXNoXHJcbiAgICB9O1xyXG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHZlcmlmeWluZyB1c2VyOicsIGVycm9yKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gdmVyaWZ5IHVzZXInXHJcbiAgICB9O1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGQgYSBuZXcgYWRtaW4gKG93bmVyIG9ubHkpXHJcbiAqIEBwYXJhbSBhZG1pbkFkZHJlc3MgLSBBZGRyZXNzIHRvIGFkZCBhcyBhZG1pblxyXG4gKiBAcmV0dXJucyBSZXN1bHQgb2JqZWN0IHdpdGggc3VjY2VzcyBzdGF0dXMgYW5kIHRyYW5zYWN0aW9uIGRldGFpbHNcclxuICovXHJcbmV4cG9ydCBjb25zdCBhZGRBZG1pbiA9IGFzeW5jIChhZG1pbkFkZHJlc3M6IHN0cmluZykgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBzaWduZXIgPSBhd2FpdCBnZXRTaWduZXIoKTtcclxuICAgIGNvbnN0IGNvbnRyYWN0ID0gYXdhaXQgZ2V0SWRlbnRpdHlDb250cmFjdChzaWduZXIpO1xyXG4gICAgXHJcbiAgICBjb25zdCB0eCA9IGF3YWl0IGNvbnRyYWN0LmFkZEFkbWluKGFkbWluQWRkcmVzcyk7XHJcbiAgICBhd2FpdCB0eC53YWl0KCk7XHJcbiAgICBcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXHJcbiAgICAgIG1lc3NhZ2U6ICdBZG1pbiBhZGRlZCBzdWNjZXNzZnVsbHknLFxyXG4gICAgICBoYXNoOiB0eC5oYXNoXHJcbiAgICB9O1xyXG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFkZGluZyBhZG1pbjonLCBlcnJvcik7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSB8fCAnRmFpbGVkIHRvIGFkZCBhZG1pbidcclxuICAgIH07XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSBhbiBhZG1pbiAob3duZXIgb25seSlcclxuICogQHBhcmFtIGFkbWluQWRkcmVzcyAtIEFkZHJlc3MgdG8gcmVtb3ZlIGZyb20gYWRtaW4gcm9sZVxyXG4gKiBAcmV0dXJucyBSZXN1bHQgb2JqZWN0IHdpdGggc3VjY2VzcyBzdGF0dXMgYW5kIHRyYW5zYWN0aW9uIGRldGFpbHNcclxuICovXHJcbmV4cG9ydCBjb25zdCByZW1vdmVBZG1pbiA9IGFzeW5jIChhZG1pbkFkZHJlc3M6IHN0cmluZykgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBzaWduZXIgPSBhd2FpdCBnZXRTaWduZXIoKTtcclxuICAgIGNvbnN0IGNvbnRyYWN0ID0gYXdhaXQgZ2V0SWRlbnRpdHlDb250cmFjdChzaWduZXIpO1xyXG4gICAgXHJcbiAgICBjb25zdCB0eCA9IGF3YWl0IGNvbnRyYWN0LnJlbW92ZUFkbWluKGFkbWluQWRkcmVzcyk7XHJcbiAgICBhd2FpdCB0eC53YWl0KCk7XHJcbiAgICBcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXHJcbiAgICAgIG1lc3NhZ2U6ICdBZG1pbiByZW1vdmVkIHN1Y2Nlc3NmdWxseScsXHJcbiAgICAgIGhhc2g6IHR4Lmhhc2hcclxuICAgIH07XHJcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVtb3ZpbmcgYWRtaW46JywgZXJyb3IpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byByZW1vdmUgYWRtaW4nXHJcbiAgICB9O1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBhbiBhZGRyZXNzIGlzIGFuIGFkbWluXHJcbiAqIEBwYXJhbSBhZGRyZXNzIC0gQWRkcmVzcyB0byBjaGVja1xyXG4gKiBAcmV0dXJucyBCb29sZWFuIGluZGljYXRpbmcgaWYgdGhlIGFkZHJlc3MgaXMgYW4gYWRtaW5cclxuICovXHJcbmV4cG9ydCBjb25zdCBjaGVja0lzQWRtaW4gPSBhc3luYyAoYWRkcmVzczogc3RyaW5nKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgZ2V0UHJvdmlkZXIoKTtcclxuICAgIGNvbnN0IGNvbnRyYWN0ID0gYXdhaXQgZ2V0SWRlbnRpdHlDb250cmFjdChwcm92aWRlcik7XHJcbiAgICByZXR1cm4gYXdhaXQgY29udHJhY3QuaXNBZG1pbihhZGRyZXNzKTtcclxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyBhZG1pbiBzdGF0dXM6JywgZXJyb3IpO1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBhbiBhZGRyZXNzIGlzIGFuIGluc3RpdHV0aW9uXHJcbiAqIEBwYXJhbSBhZGRyZXNzIC0gQWRkcmVzcyB0byBjaGVja1xyXG4gKiBAcmV0dXJucyBCb29sZWFuIGluZGljYXRpbmcgaWYgdGhlIGFkZHJlc3MgaXMgYW4gaW5zdGl0dXRpb25cclxuICovXHJcbmV4cG9ydCBjb25zdCBjaGVja0lzSW5zdGl0dXRpb24gPSBhc3luYyAoYWRkcmVzczogc3RyaW5nKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgZ2V0UHJvdmlkZXIoKTtcclxuICAgIGNvbnN0IGNvbnRyYWN0ID0gYXdhaXQgZ2V0SWRlbnRpdHlDb250cmFjdChwcm92aWRlcik7XHJcbiAgICByZXR1cm4gYXdhaXQgY29udHJhY3QuaXNJbnN0aXR1dGlvbihhZGRyZXNzKTtcclxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyBpbnN0aXR1dGlvbiBzdGF0dXM6JywgZXJyb3IpO1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBVcGRhdGUgYSB1c2VyJ3Mgcm9sZSAoYWRtaW4gb25seSlcclxuICogQHBhcmFtIHVzZXJBZGRyZXNzIC0gQWRkcmVzcyBvZiB0aGUgdXNlclxyXG4gKiBAcGFyYW0gbmV3Um9sZSAtIE5ldyByb2xlIHRvIGFzc2lnbiAoMTogU3R1ZGVudCwgMjogSW5zdGl0dXRpb24sIDM6IEVtcGxveWVyKVxyXG4gKiBAcmV0dXJucyBSZXN1bHQgb2JqZWN0IHdpdGggc3VjY2VzcyBzdGF0dXMgYW5kIHRyYW5zYWN0aW9uIGRldGFpbHNcclxuICovXHJcbmV4cG9ydCBjb25zdCB1cGRhdGVVc2VyUm9sZSA9IGFzeW5jICh1c2VyQWRkcmVzczogc3RyaW5nLCBuZXdSb2xlOiBudW1iZXIpID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgZ2V0U2lnbmVyKCk7XHJcbiAgICBjb25zdCBjb250cmFjdCA9IGF3YWl0IGdldElkZW50aXR5Q29udHJhY3Qoc2lnbmVyKTtcclxuICAgIFxyXG4gICAgLy8gRW5zdXJlIGNhbGxlciBpcyBhZG1pblxyXG4gICAgY29uc3Qgc2lnbmVyQWRkcmVzcyA9IGF3YWl0IHNpZ25lci5nZXRBZGRyZXNzKCk7XHJcbiAgICBjb25zdCBpc0FkbWluID0gYXdhaXQgY29udHJhY3QuaXNBZG1pbihzaWduZXJBZGRyZXNzKTtcclxuICAgIFxyXG4gICAgaWYgKCFpc0FkbWluKSB7XHJcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBtZXNzYWdlOiAnT25seSBhZG1pbnMgY2FuIHVwZGF0ZSB1c2VyIHJvbGVzJyB9O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zdCB0eCA9IGF3YWl0IGNvbnRyYWN0LnVwZGF0ZVVzZXJSb2xlKHVzZXJBZGRyZXNzLCBuZXdSb2xlKTtcclxuICAgIGF3YWl0IHR4LndhaXQoKTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc3VjY2VzczogdHJ1ZSxcclxuICAgICAgbWVzc2FnZTogJ1VzZXIgcm9sZSB1cGRhdGVkIHN1Y2Nlc3NmdWxseScsXHJcbiAgICAgIGhhc2g6IHR4Lmhhc2hcclxuICAgIH07XHJcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgdXNlciByb2xlOicsIGVycm9yKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gdXBkYXRlIHVzZXIgcm9sZSdcclxuICAgIH07XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFBhdXNlIHRoZSBJZGVudGl0eSBjb250cmFjdCAoYWRtaW4gb25seSlcclxuICogQHJldHVybnMgUmVzdWx0IG9iamVjdCB3aXRoIHN1Y2Nlc3Mgc3RhdHVzIGFuZCB0cmFuc2FjdGlvbiBkZXRhaWxzXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgcGF1c2VDb250cmFjdCA9IGFzeW5jICgpID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgZ2V0U2lnbmVyKCk7XHJcbiAgICBjb25zdCBjb250cmFjdCA9IGF3YWl0IGdldElkZW50aXR5Q29udHJhY3Qoc2lnbmVyKTtcclxuICAgIFxyXG4gICAgLy8gRW5zdXJlIGNhbGxlciBpcyBhZG1pblxyXG4gICAgY29uc3Qgc2lnbmVyQWRkcmVzcyA9IGF3YWl0IHNpZ25lci5nZXRBZGRyZXNzKCk7XHJcbiAgICBjb25zdCBpc0FkbWluID0gYXdhaXQgY29udHJhY3QuaXNBZG1pbihzaWduZXJBZGRyZXNzKTtcclxuICAgIFxyXG4gICAgaWYgKCFpc0FkbWluKSB7XHJcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBtZXNzYWdlOiAnT25seSBhZG1pbnMgY2FuIHBhdXNlIHRoZSBjb250cmFjdCcgfTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc3QgdHggPSBhd2FpdCBjb250cmFjdC5wYXVzZSgpO1xyXG4gICAgYXdhaXQgdHgud2FpdCgpO1xyXG4gICAgXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzdWNjZXNzOiB0cnVlLFxyXG4gICAgICBtZXNzYWdlOiAnQ29udHJhY3QgcGF1c2VkIHN1Y2Nlc3NmdWxseScsXHJcbiAgICAgIGhhc2g6IHR4Lmhhc2hcclxuICAgIH07XHJcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgcGF1c2luZyBjb250cmFjdDonLCBlcnJvcik7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSB8fCAnRmFpbGVkIHRvIHBhdXNlIGNvbnRyYWN0J1xyXG4gICAgfTtcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogVW5wYXVzZSB0aGUgSWRlbnRpdHkgY29udHJhY3QgKGFkbWluIG9ubHkpXHJcbiAqIEByZXR1cm5zIFJlc3VsdCBvYmplY3Qgd2l0aCBzdWNjZXNzIHN0YXR1cyBhbmQgdHJhbnNhY3Rpb24gZGV0YWlsc1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHVucGF1c2VDb250cmFjdCA9IGFzeW5jICgpID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgZ2V0U2lnbmVyKCk7XHJcbiAgICBjb25zdCBjb250cmFjdCA9IGF3YWl0IGdldElkZW50aXR5Q29udHJhY3Qoc2lnbmVyKTtcclxuICAgIFxyXG4gICAgLy8gRW5zdXJlIGNhbGxlciBpcyBhZG1pblxyXG4gICAgY29uc3Qgc2lnbmVyQWRkcmVzcyA9IGF3YWl0IHNpZ25lci5nZXRBZGRyZXNzKCk7XHJcbiAgICBjb25zdCBpc0FkbWluID0gYXdhaXQgY29udHJhY3QuaXNBZG1pbihzaWduZXJBZGRyZXNzKTtcclxuICAgIFxyXG4gICAgaWYgKCFpc0FkbWluKSB7XHJcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBtZXNzYWdlOiAnT25seSBhZG1pbnMgY2FuIHVucGF1c2UgdGhlIGNvbnRyYWN0JyB9O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zdCB0eCA9IGF3YWl0IGNvbnRyYWN0LnVucGF1c2UoKTtcclxuICAgIGF3YWl0IHR4LndhaXQoKTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc3VjY2VzczogdHJ1ZSxcclxuICAgICAgbWVzc2FnZTogJ0NvbnRyYWN0IHVucGF1c2VkIHN1Y2Nlc3NmdWxseScsXHJcbiAgICAgIGhhc2g6IHR4Lmhhc2hcclxuICAgIH07XHJcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgdW5wYXVzaW5nIGNvbnRyYWN0OicsIGVycm9yKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gdW5wYXVzZSBjb250cmFjdCdcclxuICAgIH07XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFZlcmlmeSBhbGwgaW5zdGl0dXRpb25zIHRoYXQgYXJlbid0IHZlcmlmaWVkIHlldFxyXG4gKiBAcmV0dXJucyBSZXN1bHQgb2JqZWN0IHdpdGggc3VjY2VzcyBzdGF0dXMgYW5kIGNvdW50c1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHZlcmlmeUFsbFBlbmRpbmdJbnN0aXR1dGlvbnMgPSBhc3luYyAoKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGluc3RpdHV0aW9uQWRkcmVzc2VzID0gYXdhaXQgZ2V0QWxsVXNlcnNCeVJvbGUoMik7IC8vIFJvbGUgMiBpcyBJbnN0aXR1dGlvblxyXG4gICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgZ2V0U2lnbmVyKCk7XHJcbiAgICBjb25zdCBjb250cmFjdCA9IGF3YWl0IGdldElkZW50aXR5Q29udHJhY3Qoc2lnbmVyKTtcclxuICAgIFxyXG4gICAgLy8gRW5zdXJlIGNhbGxlciBpcyBhZG1pblxyXG4gICAgY29uc3Qgc2lnbmVyQWRkcmVzcyA9IGF3YWl0IHNpZ25lci5nZXRBZGRyZXNzKCk7XHJcbiAgICBjb25zdCBpc0FkbWluID0gYXdhaXQgY29udHJhY3QuaXNBZG1pbihzaWduZXJBZGRyZXNzKTtcclxuICAgIFxyXG4gICAgaWYgKCFpc0FkbWluKSB7XHJcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBtZXNzYWdlOiAnT25seSBhZG1pbnMgY2FuIHBlcmZvcm0gYmF0Y2ggdmVyaWZpY2F0aW9uJyB9O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBsZXQgdmVyaWZpZWRDb3VudCA9IDA7XHJcbiAgICBsZXQgZmFpbGVkQ291bnQgPSAwO1xyXG4gICAgXHJcbiAgICBmb3IgKGNvbnN0IGFkZHJlc3Mgb2YgaW5zdGl0dXRpb25BZGRyZXNzZXMpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCB1c2VyRGF0YSA9IGF3YWl0IGdldERldGFpbGVkVXNlckRhdGEoYWRkcmVzcyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHVzZXJEYXRhICYmICF1c2VyRGF0YS5pc1ZlcmlmaWVkKSB7XHJcbiAgICAgICAgICBjb25zdCB0eCA9IGF3YWl0IGNvbnRyYWN0LnZlcmlmeVVzZXIoYWRkcmVzcyk7XHJcbiAgICAgICAgICBhd2FpdCB0eC53YWl0KCk7XHJcbiAgICAgICAgICB2ZXJpZmllZENvdW50Kys7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byB2ZXJpZnkgaW5zdGl0dXRpb24gJHthZGRyZXNzfTpgLCBlcnJvcik7XHJcbiAgICAgICAgZmFpbGVkQ291bnQrKztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzdWNjZXNzOiB0cnVlLFxyXG4gICAgICBtZXNzYWdlOiBgVmVyaWZpZWQgJHt2ZXJpZmllZENvdW50fSBpbnN0aXR1dGlvbnMuIEZhaWxlZDogJHtmYWlsZWRDb3VudH1gLFxyXG4gICAgICB2ZXJpZmllZENvdW50LFxyXG4gICAgICBmYWlsZWRDb3VudFxyXG4gICAgfTtcclxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBiYXRjaCB2ZXJpZmljYXRpb246JywgZXJyb3IpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byBwZXJmb3JtIGJhdGNoIHZlcmlmaWNhdGlvbidcclxuICAgIH07XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldCBhZG1pbiBkYXNoYm9hcmQgc3RhdGlzdGljc1xyXG4gKiBAcmV0dXJucyBTdGF0aXN0aWNzIGZvciB0aGUgYWRtaW4gZGFzaGJvYXJkXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZ2V0QWRtaW5TdGF0cyA9IGFzeW5jICgpID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3Qgc3R1ZGVudHMgPSBhd2FpdCBnZXRBbGxVc2Vyc0J5Um9sZSgxKTsgLy8gUm9sZSAxIGlzIFN0dWRlbnRcclxuICAgIGNvbnN0IGluc3RpdHV0aW9ucyA9IGF3YWl0IGdldEFsbFVzZXJzQnlSb2xlKDIpOyAvLyBSb2xlIDIgaXMgSW5zdGl0dXRpb25cclxuICAgIGNvbnN0IGVtcGxveWVycyA9IGF3YWl0IGdldEFsbFVzZXJzQnlSb2xlKDMpOyAvLyBSb2xlIDMgaXMgRW1wbG95ZXJcclxuICAgIGNvbnN0IGFkbWlucyA9IGF3YWl0IGdldEFsbFVzZXJzQnlSb2xlKDQpOyAvLyBSb2xlIDQgaXMgQWRtaW5cclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc3R1ZGVudENvdW50OiBzdHVkZW50cy5sZW5ndGgsXHJcbiAgICAgIGluc3RpdHV0aW9uQ291bnQ6IGluc3RpdHV0aW9ucy5sZW5ndGgsXHJcbiAgICAgIGVtcGxveWVyQ291bnQ6IGVtcGxveWVycy5sZW5ndGgsXHJcbiAgICAgIGFkbWluQ291bnQ6IGFkbWlucy5sZW5ndGgsXHJcbiAgICAgIHRvdGFsVXNlckNvdW50OiBzdHVkZW50cy5sZW5ndGggKyBpbnN0aXR1dGlvbnMubGVuZ3RoICsgZW1wbG95ZXJzLmxlbmd0aCArIGFkbWlucy5sZW5ndGhcclxuICAgIH07XHJcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBhZG1pbiBzdGF0czonLCBlcnJvcik7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzdHVkZW50Q291bnQ6IDAsXHJcbiAgICAgIGluc3RpdHV0aW9uQ291bnQ6IDAsXHJcbiAgICAgIGVtcGxveWVyQ291bnQ6IDAsXHJcbiAgICAgIGFkbWluQ291bnQ6IDAsXHJcbiAgICAgIHRvdGFsVXNlckNvdW50OiAwXHJcbiAgICB9O1xyXG4gIH1cclxufTsiXSwibmFtZXMiOlsiZXRoZXJzIiwiSWRlbnRpdHlBQkkiLCJnZXRQcm92aWRlciIsImdldFNpZ25lciIsImdldENvbmZpZyIsImdldEV4YW1NYW5hZ2VtZW50Q29udHJhY3QiLCJnZXRJZGVudGl0eUNvbnRyYWN0IiwicnVubmVyIiwicHJvY2VzcyIsImNvbnRyYWN0QWRkcmVzcyIsImVudiIsIk5FWFRfUFVCTElDX0lERU5USVRZX0NPTlRSQUNUX0FERFJFU1MiLCJ0b1N0cmluZyIsInJ1bm5lckluc3RhbmNlIiwiQ29udHJhY3QiLCJnZXRBbGxVc2Vyc0J5Um9sZSIsInJvbGUiLCJwcm92aWRlciIsImNvbnRyYWN0IiwiYWRkcmVzc2VzIiwiZ2V0VXNlcnNCeVJvbGUiLCJlcnJvciIsImNvbnNvbGUiLCJnZXREZXRhaWxlZFVzZXJEYXRhIiwiYWRkcmVzcyIsImRhdGEiLCJnZXRVc2VyRGF0YSIsInVzZXJBZGRyZXNzIiwiaXBmc0hhc2giLCJpc1ZlcmlmaWVkIiwiY3JlYXRlZEF0IiwiRGF0ZSIsIk51bWJlciIsInZlcmlmeVVzZXIiLCJzaWduZXIiLCJpZGVudGl0eUNvbnRyYWN0IiwiZXhhbU1hbmFnZW1lbnRDb250cmFjdCIsInNpZ25lckFkZHJlc3MiLCJnZXRBZGRyZXNzIiwiaXNBZG1pbiIsInN1Y2Nlc3MiLCJtZXNzYWdlIiwiZXhhbU1hbmFnZW1lbnRUeCIsInZlcmlmeUluc3RpdHV0aW9uIiwid2FpdCIsImlkZW50aXR5VHgiLCJleGFtTWFuYWdlbWVudEhhc2giLCJoYXNoIiwiaWRlbnRpdHlIYXNoIiwiYWRkQWRtaW4iLCJhZG1pbkFkZHJlc3MiLCJ0eCIsInJlbW92ZUFkbWluIiwiY2hlY2tJc0FkbWluIiwiY2hlY2tJc0luc3RpdHV0aW9uIiwiaXNJbnN0aXR1dGlvbiIsInVwZGF0ZVVzZXJSb2xlIiwibmV3Um9sZSIsInBhdXNlQ29udHJhY3QiLCJwYXVzZSIsInVucGF1c2VDb250cmFjdCIsInVucGF1c2UiLCJ2ZXJpZnlBbGxQZW5kaW5nSW5zdGl0dXRpb25zIiwiaW5zdGl0dXRpb25BZGRyZXNzZXMiLCJ2ZXJpZmllZENvdW50IiwiZmFpbGVkQ291bnQiLCJ1c2VyRGF0YSIsImdldEFkbWluU3RhdHMiLCJzdHVkZW50cyIsImluc3RpdHV0aW9ucyIsImVtcGxveWVycyIsImFkbWlucyIsInN0dWRlbnRDb3VudCIsImxlbmd0aCIsImluc3RpdHV0aW9uQ291bnQiLCJlbXBsb3llckNvdW50IiwiYWRtaW5Db3VudCIsInRvdGFsVXNlckNvdW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./services/admin.ts\n"));

/***/ }),

/***/ "./utils/contracts.ts":
/*!****************************!*\
  !*** ./utils/contracts.ts ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createExam: function() { return /* binding */ createExam; },\n/* harmony export */   enrollStudent: function() { return /* binding */ enrollStudent; },\n/* harmony export */   getCertificates: function() { return /* binding */ getCertificates; },\n/* harmony export */   getContracts: function() { return /* binding */ getContracts; },\n/* harmony export */   getExam: function() { return /* binding */ getExam; },\n/* harmony export */   getExamResult: function() { return /* binding */ getExamResult; },\n/* harmony export */   getInstitutionExams: function() { return /* binding */ getInstitutionExams; },\n/* harmony export */   getOwnerAddress: function() { return /* binding */ getOwnerAddress; },\n/* harmony export */   getStudentExams: function() { return /* binding */ getStudentExams; },\n/* harmony export */   getUserRole: function() { return /* binding */ getUserRole; },\n/* harmony export */   isOwner: function() { return /* binding */ isOwner; },\n/* harmony export */   isVerifiedUser: function() { return /* binding */ isVerifiedUser; },\n/* harmony export */   issueCertificate: function() { return /* binding */ issueCertificate; },\n/* harmony export */   registerUser: function() { return /* binding */ registerUser; },\n/* harmony export */   submitExamResult: function() { return /* binding */ submitExamResult; },\n/* harmony export */   updateExamStatus: function() { return /* binding */ updateExamStatus; },\n/* harmony export */   verifyCertificate: function() { return /* binding */ verifyCertificate; },\n/* harmony export */   verifyInstitution: function() { return /* binding */ verifyInstitution; },\n/* harmony export */   verifyUser: function() { return /* binding */ verifyUser; }\n/* harmony export */ });\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ethers */ \"./node_modules/ethers/lib.esm/index.js\");\n/* harmony import */ var _constants_abis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/abis */ \"./constants/abis.ts\");\n/* harmony import */ var _ethersConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ethersConfig */ \"./utils/ethersConfig.ts\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./config */ \"./utils/config.ts\");\n/* harmony import */ var services_admin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! services/admin */ \"./services/admin.ts\");\n/* harmony import */ var services_examManagement__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! services/examManagement */ \"./services/examManagement.ts\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/process/browser.js\");\n\n\n\n\n\n\n// Contract addresses from .env\nconst IDENTITY_CONTRACT_ADDRESS = \"0x911E250f1398F007704D0F6A527a6a71560a3B93\";\nconst CERTIFICATES_CONTRACT_ADDRESS = \"0xB5Afb0f327F7776Bff1fb9FB257eed8dC2336161\";\nconst EXAM_MANAGEMENT_CONTRACT_ADDRESS = \"0x37458DD5C9E778CF2e149E44f806D8C914bF1CE2\";\n// Role mapping with proper types\nconst USER_ROLES = {\n    NONE: 0,\n    STUDENT: 1,\n    INSTITUTION: 2,\n    EMPLOYER: 3\n};\nconst roleMap = {\n    [USER_ROLES.NONE]: \"none\",\n    [USER_ROLES.STUDENT]: \"student\",\n    [USER_ROLES.INSTITUTION]: \"institution\",\n    [USER_ROLES.EMPLOYER]: \"employer\"\n};\n// Validate environment variables\nif (!IDENTITY_CONTRACT_ADDRESS) {\n    console.error(\"NEXT_PUBLIC_IDENTITY_CONTRACT_ADDRESS is not set in .env\");\n}\nif (!CERTIFICATES_CONTRACT_ADDRESS) {\n    console.error(\"NEXT_PUBLIC_CERTIFICATES_CONTRACT_ADDRESS is not set in .env\");\n}\nconst getContracts = async ()=>{\n    try {\n        const provider = await (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getProvider)();\n        const signer = await (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getSigner)();\n        const identityContract = new ethers__WEBPACK_IMPORTED_MODULE_5__.ethers.Contract(IDENTITY_CONTRACT_ADDRESS, _constants_abis__WEBPACK_IMPORTED_MODULE_0__.IdentityABI, signer);\n        const certificatesContract = new ethers__WEBPACK_IMPORTED_MODULE_5__.ethers.Contract(CERTIFICATES_CONTRACT_ADDRESS, _constants_abis__WEBPACK_IMPORTED_MODULE_0__.CertificatesABI, signer);\n        const examManagementContract = new ethers__WEBPACK_IMPORTED_MODULE_5__.ethers.Contract(EXAM_MANAGEMENT_CONTRACT_ADDRESS, _constants_abis__WEBPACK_IMPORTED_MODULE_0__.ExamManagementABI, signer);\n        return {\n            identityContract,\n            certificatesContract,\n            examManagementContract,\n            provider,\n            signer\n        };\n    } catch (error) {\n        console.error(\"Error initializing contracts:\", error);\n        throw new Error(\"Failed to initialize contracts: \".concat(error.message));\n    }\n};\nconst registerUser = async (role)=>{\n    if (!role) {\n        throw new Error(\"Role is required\");\n    }\n    try {\n        // Error.1 missing revert data  \n        // const provider = await getProvider();\n        // solve error.1\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_5__.ethers.BrowserProvider(window.ethereum);\n        const signer = await provider.getSigner();\n        const identityAddress = (0,_config__WEBPACK_IMPORTED_MODULE_2__.getConfig)(\"IDENTITY_CONTRACT_ADDRESS\");\n        if (!identityAddress) {\n            throw new Error(\"Contract address is not configured\");\n        }\n        const identityContract = new ethers__WEBPACK_IMPORTED_MODULE_5__.ethers.Contract(identityAddress, _constants_abis__WEBPACK_IMPORTED_MODULE_0__.IdentityABI, signer);\n        // Convert role string to enum value\n        const roleMap = {\n            \"student\": 1,\n            \"institution\": 2,\n            \"employer\": 3\n        };\n        const roleValue = roleMap[role.toLowerCase()];\n        if (roleValue === undefined) {\n            throw new Error(\"Invalid role: \".concat(role, \". Must be one of: student, institution, employer\"));\n        }\n        const tx = await identityContract.registerUser(roleValue, \"\" /*, overrides*/ );\n        await tx.wait();\n        return {\n            status: \"success\"\n        };\n    } catch (error) {\n        console.error(\"Registration error:\", error);\n        throw error;\n    }\n};\nconst verifyUser = async (address)=>{\n    if (!address || !(0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getAddress)(address)) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        const { identityContract } = await getContracts();\n        return await identityContract.verifyUser(address);\n    } catch (error) {\n        console.error(\"Error verifying user:\", error);\n        throw new Error(error.message || \"Failed to verify user\");\n    }\n};\nconst getUserRole = async (address)=>{\n    if (!address || !(0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getAddress)(address)) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        const { identityContract } = await getContracts();\n        const roleValue = await identityContract.getUserRole(address);\n        return roleMap[roleValue] || \"none\";\n    } catch (error) {\n        console.error(\"Error getting user role:\", error);\n        return \"none\";\n    }\n};\nconst issueCertificate = async (studentAddress, ipfsHash)=>{\n    if (!studentAddress || !ipfsHash) {\n        throw new Error(\"Student address and IPFS hash are required\");\n    }\n    try {\n        const { certificatesContract } = await getContracts();\n        const tx = await certificatesContract.issueCertificate(studentAddress, ipfsHash);\n        await tx.wait();\n        return tx;\n    } catch (error) {\n        console.error(\"Error issuing certificate:\", error);\n        throw error;\n    }\n};\nconst verifyCertificate = async (certificateId)=>{\n    if (!certificateId) {\n        throw new Error(\"Certificate ID is required\");\n    }\n    try {\n        const { certificatesContract } = await getContracts();\n        const isValid = await certificatesContract.verifyCertificate(certificateId);\n        return isValid;\n    } catch (error) {\n        console.error(\"Error verifying certificate:\", error);\n        throw error;\n    }\n};\nconst getCertificates = async (address)=>{\n    if (!address || !(0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getAddress)(address)) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        console.log(\"Getting certificates for address:\", address);\n        const { certificatesContract } = await getContracts();\n        // Get certificate IDs first\n        console.log(\"Getting certificate IDs...\");\n        const certificateIds = await certificatesContract.getStudentCertificates(address);\n        console.log(\"Certificate IDs:\", certificateIds);\n        if (!certificateIds || certificateIds.length === 0) {\n            console.log(\"No certificates found\");\n            return [];\n        }\n        // Get details for each certificate\n        console.log(\"Getting certificate details...\");\n        const certificates = await Promise.all(certificateIds.map(async (id)=>{\n            const cert = await certificatesContract.verifyCertificate(id);\n            return {\n                id,\n                ipfsHash: cert.ipfsHash,\n                issuer: cert.institution,\n                timestamp: cert.issuedAt.toString(),\n                isValid: cert.isValid\n            };\n        }));\n        console.log(\"Certificate details:\", certificates);\n        return certificates;\n    } catch (error) {\n        console.error(\"Error in getCertificates:\", error);\n        if (error.reason) {\n            throw new Error(\"Contract error: \".concat(error.reason));\n        }\n        throw error;\n    }\n};\nconst isVerifiedUser = async (address)=>{\n    if (!address || !(0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getAddress)(address)) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        const { identityContract } = await getContracts();\n        return await identityContract.isVerifiedUser(address);\n    } catch (error) {\n        console.error(\"Error checking verification status:\", error);\n        throw error;\n    }\n};\n// Admin functions\nconst isOwner = async (address)=>{\n    if (!address || !(0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getAddress)(address)) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        const { identityContract } = await getContracts();\n        const owner = await identityContract.owner();\n        // Add additional checks\n        if (!owner) {\n            console.warn(\"Owner address is null or undefined\");\n            return false;\n        }\n        return owner.toLowerCase() === address.toLowerCase();\n    } catch (error) {\n        console.error(\"Error checking owner status:\", error);\n        throw error;\n    }\n};\nconst verifyInstitution = async (institutionAddress)=>{\n    if (!institutionAddress || !(0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getAddress)(institutionAddress)) {\n        throw new Error(\"Invalid institution address\");\n    }\n    try {\n        const identityContract = await (0,services_admin__WEBPACK_IMPORTED_MODULE_3__.getIdentityContract)();\n        const examManagementContract = await (0,services_examManagement__WEBPACK_IMPORTED_MODULE_4__.getExamManagementContract)();\n        // const identityTx = await identityContract.verifyUser(institutionAddress);\n        // await identityTx.wait();\n        const examManagementTx = await examManagementContract.verifyInstitution(institutionAddress);\n        await examManagementTx.wait();\n        return {\n            // identityHash: identityTx.hash,\n            examManagementHash: examManagementTx.hash\n        };\n    } catch (error) {\n        console.error(\"Error verifying institution:\", error);\n        throw error;\n    }\n};\nconst getOwnerAddress = async ()=>{\n    try {\n        const { identityContract } = await getContracts();\n        const owner = await identityContract.owner();\n        return owner;\n    } catch (error) {\n        console.error(\"Error getting owner address:\", error);\n        throw error;\n    }\n};\n// Add exam management contract address and ABI\nconst EXAM_MANAGEMENT_ADDRESS = process.env.NEXT_PUBLIC_EXAM_MANAGEMENT_ADDRESS || \"\";\nconst EXAM_MANAGEMENT_ABI = _constants_abis__WEBPACK_IMPORTED_MODULE_0__.ExamManagementABI;\n// Add exam management functions\nconst createExam = async (id, title, description, date, duration, ipfsHash)=>{\n    try {\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_5__.ethers.JsonRpcProvider(_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl);\n        const signer = await provider.getSigner();\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_5__.ethers.Contract(EXAM_MANAGEMENT_ADDRESS, EXAM_MANAGEMENT_ABI, signer);\n        const tx = await contract.createExam(id, title, description, date, duration, ipfsHash);\n        await tx.wait();\n        return true;\n    } catch (error) {\n        console.error(\"Error creating exam:\", error);\n        throw error;\n    }\n};\nconst submitExamResult = async (examId, student, score, grade, ipfsHash)=>{\n    try {\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_5__.ethers.JsonRpcProvider(_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl);\n        const signer = await provider.getSigner();\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_5__.ethers.Contract(EXAM_MANAGEMENT_ADDRESS, EXAM_MANAGEMENT_ABI, signer);\n        const tx = await contract.submitExamResult(examId, student, score, grade, ipfsHash);\n        await tx.wait();\n        return true;\n    } catch (error) {\n        console.error(\"Error submitting exam result:\", error);\n        throw error;\n    }\n};\nconst updateExamStatus = async (examId, status)=>{\n    try {\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_5__.ethers.JsonRpcProvider(_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl);\n        const signer = await provider.getSigner();\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_5__.ethers.Contract(EXAM_MANAGEMENT_ADDRESS, EXAM_MANAGEMENT_ABI, signer);\n        const tx = await contract.updateExamStatus(examId, status);\n        await tx.wait();\n        return true;\n    } catch (error) {\n        console.error(\"Error updating exam status:\", error);\n        throw error;\n    }\n};\nconst getExam = async (examId)=>{\n    try {\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_5__.ethers.JsonRpcProvider(_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl);\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_5__.ethers.Contract(EXAM_MANAGEMENT_ADDRESS, EXAM_MANAGEMENT_ABI, provider);\n        const exam = await contract.getExam(examId);\n        return exam;\n    } catch (error) {\n        console.error(\"Error getting exam:\", error);\n        throw error;\n    }\n};\nconst getExamResult = async (examId, student)=>{\n    try {\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_5__.ethers.JsonRpcProvider(_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl);\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_5__.ethers.Contract(EXAM_MANAGEMENT_ADDRESS, EXAM_MANAGEMENT_ABI, provider);\n        const result = await contract.getExamResult(examId, student);\n        return result;\n    } catch (error) {\n        console.error(\"Error getting exam result:\", error);\n        throw error;\n    }\n};\nconst getInstitutionExams = async (institution)=>{\n    try {\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_5__.ethers.JsonRpcProvider(_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl);\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_5__.ethers.Contract(EXAM_MANAGEMENT_ADDRESS, EXAM_MANAGEMENT_ABI, provider);\n        const exams = await contract.getInstitutionExams(institution);\n        return exams;\n    } catch (error) {\n        console.error(\"Error getting institution exams:\", error);\n        throw error;\n    }\n};\nconst getStudentExams = async (student)=>{\n    try {\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_5__.ethers.JsonRpcProvider(_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl);\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_5__.ethers.Contract(EXAM_MANAGEMENT_ADDRESS, EXAM_MANAGEMENT_ABI, provider);\n        const exams = await contract.getStudentExams(student);\n        return exams;\n    } catch (error) {\n        console.error(\"Error getting student exams:\", error);\n        throw error;\n    }\n};\nconst enrollStudent = async (examId, studentAddress)=>{\n    try {\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_5__.ethers.JsonRpcProvider(_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl);\n        const signer = await provider.getSigner();\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_5__.ethers.Contract(EXAM_MANAGEMENT_ADDRESS, EXAM_MANAGEMENT_ABI, signer);\n        const tx = await contract.enrollStudent(examId, studentAddress);\n        await tx.wait();\n        return true;\n    } catch (error) {\n        console.error(\"Error enrolling student:\", error);\n        throw error;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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T1M7SUFDVCxFQUFFLE9BQU9oRixPQUFPO1FBQ2RELFFBQVFDLEtBQUssQ0FBQyxnQ0FBZ0NBO1FBQzlDLE1BQU1BO0lBQ1I7QUFDRixFQUFFO0FBRUssTUFBTWtGLGdCQUFnQixPQUFPWixRQUFnQjVDO0lBQ2xELElBQUk7UUFDRixJQUFJLENBQUNkLE9BQU9DLFFBQVEsRUFBRTtZQUNwQixNQUFNLElBQUlMLE1BQU07UUFDbEI7UUFDQSxNQUFNTixXQUFXLElBQUk1QiwwQ0FBTUEsQ0FBQzRGLGVBQWUsQ0FBQ3RGLDJEQUFnQkEsQ0FBQ3VGLE1BQU07UUFDbkUsTUFBTWhFLFNBQVMsTUFBTUQsU0FBU3ZCLFNBQVM7UUFDdkMsTUFBTXlGLFdBQVcsSUFBSTlGLDBDQUFNQSxDQUFDK0IsUUFBUSxDQUFDcUQseUJBQXlCRSxxQkFBcUJ6RDtRQUVuRixNQUFNZ0IsS0FBSyxNQUFNaUQsU0FBU2MsYUFBYSxDQUFDWixRQUFRNUM7UUFDaEQsTUFBTVAsR0FBR0MsSUFBSTtRQUNiLE9BQU87SUFDVCxFQUFFLE9BQU9wQixPQUFPO1FBQ2RELFFBQVFDLEtBQUssQ0FBQyw0QkFBNEJBO1FBQzFDLE1BQU1BO0lBQ1I7QUFDRixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3V0aWxzL2NvbnRyYWN0cy50cz85ODU2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGV0aGVycyB9IGZyb20gJ2V0aGVycyc7XHJcbmltcG9ydCB7IEV4YW1NYW5hZ2VtZW50QUJJLCBJZGVudGl0eUFCSSwgQ2VydGlmaWNhdGVzQUJJIH0gZnJvbSAnLi4vY29uc3RhbnRzL2FiaXMnO1xyXG5pbXBvcnQge1xyXG4gIGdldFByb3ZpZGVyLFxyXG4gIGdldFNpZ25lcixcclxuICBFWFBFQ1RFRF9ORVRXT1JLLFxyXG4gIHZhbGlkYXRlTmV0d29yayxcclxuICBmb3JtYXRFdGhlcixcclxuICBoYW5kbGVDb250cmFjdEVycm9yLFxyXG4gIGdldEFkZHJlc3MsXHJcbiAgdHlwZSBFdGhlcmV1bVByb3ZpZGVyXHJcbn0gZnJvbSAnLi9ldGhlcnNDb25maWcnO1xyXG5pbXBvcnQgeyBnZXRDb25maWcgfSBmcm9tICcuL2NvbmZpZyc7XHJcbmltcG9ydCB7IGdldElkZW50aXR5Q29udHJhY3QgfSBmcm9tICdzZXJ2aWNlcy9hZG1pbic7XHJcbmltcG9ydCB7IGdldEV4YW1NYW5hZ2VtZW50Q29udHJhY3QgfSBmcm9tICdzZXJ2aWNlcy9leGFtTWFuYWdlbWVudCc7XHJcblxyXG4vLyBDb250cmFjdCBhZGRyZXNzZXMgZnJvbSAuZW52XHJcbmNvbnN0IElERU5USVRZX0NPTlRSQUNUX0FERFJFU1MgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19JREVOVElUWV9DT05UUkFDVF9BRERSRVNTO1xyXG5jb25zdCBDRVJUSUZJQ0FURVNfQ09OVFJBQ1RfQUREUkVTUyA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0NFUlRJRklDQVRFU19DT05UUkFDVF9BRERSRVNTO1xyXG5jb25zdCBFWEFNX01BTkFHRU1FTlRfQ09OVFJBQ1RfQUREUkVTUyA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0VYQU1fTUFOQUdFTUVOVF9DT05UUkFDVF9BRERSRVNTO1xyXG5cclxuLy8gUm9sZSBtYXBwaW5nIHdpdGggcHJvcGVyIHR5cGVzXHJcbmNvbnN0IFVTRVJfUk9MRVMgPSB7XHJcbiAgTk9ORTogMCxcclxuICBTVFVERU5UOiAxLFxyXG4gIElOU1RJVFVUSU9OOiAyLFxyXG4gIEVNUExPWUVSOiAzXHJcbn0gYXMgY29uc3Q7XHJcblxyXG50eXBlIFJvbGVWYWx1ZSA9IHR5cGVvZiBVU0VSX1JPTEVTW2tleW9mIHR5cGVvZiBVU0VSX1JPTEVTXTtcclxudHlwZSBSb2xlU3RyaW5nID0gJ25vbmUnIHwgJ3N0dWRlbnQnIHwgJ2luc3RpdHV0aW9uJyB8ICdlbXBsb3llcic7XHJcblxyXG5jb25zdCByb2xlTWFwOiBSZWNvcmQ8Um9sZVZhbHVlLCBSb2xlU3RyaW5nPiA9IHtcclxuICBbVVNFUl9ST0xFUy5OT05FXTogJ25vbmUnLFxyXG4gIFtVU0VSX1JPTEVTLlNUVURFTlRdOiAnc3R1ZGVudCcsXHJcbiAgW1VTRVJfUk9MRVMuSU5TVElUVVRJT05dOiAnaW5zdGl0dXRpb24nLFxyXG4gIFtVU0VSX1JPTEVTLkVNUExPWUVSXTogJ2VtcGxveWVyJ1xyXG59O1xyXG5cclxuLy8gVmFsaWRhdGUgZW52aXJvbm1lbnQgdmFyaWFibGVzXHJcbmlmICghSURFTlRJVFlfQ09OVFJBQ1RfQUREUkVTUykge1xyXG4gIGNvbnNvbGUuZXJyb3IoJ05FWFRfUFVCTElDX0lERU5USVRZX0NPTlRSQUNUX0FERFJFU1MgaXMgbm90IHNldCBpbiAuZW52Jyk7XHJcbn1cclxuaWYgKCFDRVJUSUZJQ0FURVNfQ09OVFJBQ1RfQUREUkVTUykge1xyXG4gIGNvbnNvbGUuZXJyb3IoJ05FWFRfUFVCTElDX0NFUlRJRklDQVRFU19DT05UUkFDVF9BRERSRVNTIGlzIG5vdCBzZXQgaW4gLmVudicpO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0Q29udHJhY3RzID0gYXN5bmMgKCkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IGdldFByb3ZpZGVyKCk7XHJcbiAgICBjb25zdCBzaWduZXIgPSBhd2FpdCBnZXRTaWduZXIoKTtcclxuXHJcbiAgICBjb25zdCBpZGVudGl0eUNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChcclxuICAgICAgSURFTlRJVFlfQ09OVFJBQ1RfQUREUkVTUyEsXHJcbiAgICAgIElkZW50aXR5QUJJLFxyXG4gICAgICBzaWduZXJcclxuICAgICk7XHJcblxyXG4gICAgY29uc3QgY2VydGlmaWNhdGVzQ29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KFxyXG4gICAgICBDRVJUSUZJQ0FURVNfQ09OVFJBQ1RfQUREUkVTUyEsXHJcbiAgICAgIENlcnRpZmljYXRlc0FCSSxcclxuICAgICAgc2lnbmVyXHJcbiAgICApO1xyXG5cclxuICAgIGNvbnN0IGV4YW1NYW5hZ2VtZW50Q29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KFxyXG4gICAgICBFWEFNX01BTkFHRU1FTlRfQ09OVFJBQ1RfQUREUkVTUyEsXHJcbiAgICAgIEV4YW1NYW5hZ2VtZW50QUJJLFxyXG4gICAgICBzaWduZXJcclxuICAgICk7XHJcblxyXG4gICAgcmV0dXJuIHsgaWRlbnRpdHlDb250cmFjdCwgY2VydGlmaWNhdGVzQ29udHJhY3QsIGV4YW1NYW5hZ2VtZW50Q29udHJhY3QsIHByb3ZpZGVyLCBzaWduZXIgfTtcclxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbml0aWFsaXppbmcgY29udHJhY3RzOicsIGVycm9yKTtcclxuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGluaXRpYWxpemUgY29udHJhY3RzOiAke2Vycm9yLm1lc3NhZ2V9YCk7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHJlZ2lzdGVyVXNlciA9IGFzeW5jIChyb2xlOiBzdHJpbmcpID0+IHtcclxuICBpZiAoIXJvbGUpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignUm9sZSBpcyByZXF1aXJlZCcpO1xyXG4gIH1cclxuXHJcbiAgdHJ5IHtcclxuICAgIC8vIEVycm9yLjEgbWlzc2luZyByZXZlcnQgZGF0YSAgXHJcbiAgICAvLyBjb25zdCBwcm92aWRlciA9IGF3YWl0IGdldFByb3ZpZGVyKCk7XHJcblxyXG4gICAgLy8gc29sdmUgZXJyb3IuMVxyXG4gICAgaWYgKCF3aW5kb3cuZXRoZXJldW0pIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBldGhlcmV1bSBwcm92aWRlciBmb3VuZCcpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgZXRoZXJzLkJyb3dzZXJQcm92aWRlcih3aW5kb3cuZXRoZXJldW0pO1xyXG5cclxuICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IHByb3ZpZGVyLmdldFNpZ25lcigpO1xyXG4gICAgY29uc3QgaWRlbnRpdHlBZGRyZXNzID0gZ2V0Q29uZmlnKCdJREVOVElUWV9DT05UUkFDVF9BRERSRVNTJyk7XHJcblxyXG4gICAgaWYgKCFpZGVudGl0eUFkZHJlc3MpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb250cmFjdCBhZGRyZXNzIGlzIG5vdCBjb25maWd1cmVkJyk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgaWRlbnRpdHlDb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoaWRlbnRpdHlBZGRyZXNzLCBJZGVudGl0eUFCSSwgc2lnbmVyKTtcclxuXHJcbiAgICAvLyBDb252ZXJ0IHJvbGUgc3RyaW5nIHRvIGVudW0gdmFsdWVcclxuICAgIGNvbnN0IHJvbGVNYXA6IHsgW2tleTogc3RyaW5nXTogbnVtYmVyIH0gPSB7XHJcbiAgICAgICdzdHVkZW50JzogMSxcclxuICAgICAgJ2luc3RpdHV0aW9uJzogMixcclxuICAgICAgJ2VtcGxveWVyJzogM1xyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCByb2xlVmFsdWUgPSByb2xlTWFwW3JvbGUudG9Mb3dlckNhc2UoKV07XHJcbiAgICBpZiAocm9sZVZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHJvbGU6ICR7cm9sZX0uIE11c3QgYmUgb25lIG9mOiBzdHVkZW50LCBpbnN0aXR1dGlvbiwgZW1wbG95ZXJgKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB0eCA9IGF3YWl0IGlkZW50aXR5Q29udHJhY3QucmVnaXN0ZXJVc2VyKHJvbGVWYWx1ZSwgXCJcIi8qLCBvdmVycmlkZXMqLyk7XHJcbiAgICBhd2FpdCB0eC53YWl0KCk7XHJcblxyXG4gICAgcmV0dXJuIHsgc3RhdHVzOiAnc3VjY2VzcycgfTtcclxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdSZWdpc3RyYXRpb24gZXJyb3I6JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHZlcmlmeVVzZXIgPSBhc3luYyAoYWRkcmVzczogc3RyaW5nKSA9PiB7XHJcbiAgaWYgKCFhZGRyZXNzIHx8ICFnZXRBZGRyZXNzKGFkZHJlc3MpKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYWRkcmVzcycpO1xyXG4gIH1cclxuXHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHsgaWRlbnRpdHlDb250cmFjdCB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XHJcbiAgICByZXR1cm4gYXdhaXQgaWRlbnRpdHlDb250cmFjdC52ZXJpZnlVc2VyKGFkZHJlc3MpO1xyXG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHZlcmlmeWluZyB1c2VyOicsIGVycm9yKTtcclxuICAgIHRocm93IG5ldyBFcnJvcihlcnJvci5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gdmVyaWZ5IHVzZXInKTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0VXNlclJvbGUgPSBhc3luYyAoYWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTxSb2xlU3RyaW5nPiA9PiB7XHJcbiAgaWYgKCFhZGRyZXNzIHx8ICFnZXRBZGRyZXNzKGFkZHJlc3MpKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYWRkcmVzcycpO1xyXG4gIH1cclxuXHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHsgaWRlbnRpdHlDb250cmFjdCB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XHJcbiAgICBjb25zdCByb2xlVmFsdWUgPSBhd2FpdCBpZGVudGl0eUNvbnRyYWN0LmdldFVzZXJSb2xlKGFkZHJlc3MpO1xyXG4gICAgcmV0dXJuIHJvbGVNYXBbcm9sZVZhbHVlIGFzIFJvbGVWYWx1ZV0gfHwgJ25vbmUnO1xyXG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgdXNlciByb2xlOicsIGVycm9yKTtcclxuICAgIHJldHVybiAnbm9uZSc7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGlzc3VlQ2VydGlmaWNhdGUgPSBhc3luYyAoc3R1ZGVudEFkZHJlc3M6IHN0cmluZywgaXBmc0hhc2g6IHN0cmluZykgPT4ge1xyXG4gIGlmICghc3R1ZGVudEFkZHJlc3MgfHwgIWlwZnNIYXNoKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0dWRlbnQgYWRkcmVzcyBhbmQgSVBGUyBoYXNoIGFyZSByZXF1aXJlZCcpO1xyXG4gIH1cclxuXHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHsgY2VydGlmaWNhdGVzQ29udHJhY3QgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xyXG4gICAgY29uc3QgdHggPSBhd2FpdCBjZXJ0aWZpY2F0ZXNDb250cmFjdC5pc3N1ZUNlcnRpZmljYXRlKHN0dWRlbnRBZGRyZXNzLCBpcGZzSGFzaCk7XHJcbiAgICBhd2FpdCB0eC53YWl0KCk7XHJcbiAgICByZXR1cm4gdHg7XHJcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaXNzdWluZyBjZXJ0aWZpY2F0ZTonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBlcnJvcjtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgdmVyaWZ5Q2VydGlmaWNhdGUgPSBhc3luYyAoY2VydGlmaWNhdGVJZDogc3RyaW5nKSA9PiB7XHJcbiAgaWYgKCFjZXJ0aWZpY2F0ZUlkKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NlcnRpZmljYXRlIElEIGlzIHJlcXVpcmVkJyk7XHJcbiAgfVxyXG5cclxuICB0cnkge1xyXG4gICAgY29uc3QgeyBjZXJ0aWZpY2F0ZXNDb250cmFjdCB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XHJcbiAgICBjb25zdCBpc1ZhbGlkID0gYXdhaXQgY2VydGlmaWNhdGVzQ29udHJhY3QudmVyaWZ5Q2VydGlmaWNhdGUoY2VydGlmaWNhdGVJZCk7XHJcbiAgICByZXR1cm4gaXNWYWxpZDtcclxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciB2ZXJpZnlpbmcgY2VydGlmaWNhdGU6JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldENlcnRpZmljYXRlcyA9IGFzeW5jIChhZGRyZXNzOiBzdHJpbmcpID0+IHtcclxuICBpZiAoIWFkZHJlc3MgfHwgIWdldEFkZHJlc3MoYWRkcmVzcykpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhZGRyZXNzJyk7XHJcbiAgfVxyXG5cclxuICB0cnkge1xyXG4gICAgY29uc29sZS5sb2coJ0dldHRpbmcgY2VydGlmaWNhdGVzIGZvciBhZGRyZXNzOicsIGFkZHJlc3MpO1xyXG4gICAgY29uc3QgeyBjZXJ0aWZpY2F0ZXNDb250cmFjdCB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XHJcblxyXG4gICAgLy8gR2V0IGNlcnRpZmljYXRlIElEcyBmaXJzdFxyXG4gICAgY29uc29sZS5sb2coJ0dldHRpbmcgY2VydGlmaWNhdGUgSURzLi4uJyk7XHJcbiAgICBjb25zdCBjZXJ0aWZpY2F0ZUlkcyA9IGF3YWl0IGNlcnRpZmljYXRlc0NvbnRyYWN0LmdldFN0dWRlbnRDZXJ0aWZpY2F0ZXMoYWRkcmVzcyk7XHJcbiAgICBjb25zb2xlLmxvZygnQ2VydGlmaWNhdGUgSURzOicsIGNlcnRpZmljYXRlSWRzKTtcclxuXHJcbiAgICBpZiAoIWNlcnRpZmljYXRlSWRzIHx8IGNlcnRpZmljYXRlSWRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICBjb25zb2xlLmxvZygnTm8gY2VydGlmaWNhdGVzIGZvdW5kJyk7XHJcbiAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBHZXQgZGV0YWlscyBmb3IgZWFjaCBjZXJ0aWZpY2F0ZVxyXG4gICAgY29uc29sZS5sb2coJ0dldHRpbmcgY2VydGlmaWNhdGUgZGV0YWlscy4uLicpO1xyXG4gICAgY29uc3QgY2VydGlmaWNhdGVzID0gYXdhaXQgUHJvbWlzZS5hbGwoXHJcbiAgICAgIGNlcnRpZmljYXRlSWRzLm1hcChhc3luYyAoaWQ6IHN0cmluZykgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNlcnQgPSBhd2FpdCBjZXJ0aWZpY2F0ZXNDb250cmFjdC52ZXJpZnlDZXJ0aWZpY2F0ZShpZCk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgaXBmc0hhc2g6IGNlcnQuaXBmc0hhc2gsXHJcbiAgICAgICAgICBpc3N1ZXI6IGNlcnQuaW5zdGl0dXRpb24sXHJcbiAgICAgICAgICB0aW1lc3RhbXA6IGNlcnQuaXNzdWVkQXQudG9TdHJpbmcoKSxcclxuICAgICAgICAgIGlzVmFsaWQ6IGNlcnQuaXNWYWxpZFxyXG4gICAgICAgIH07XHJcbiAgICAgIH0pXHJcbiAgICApO1xyXG5cclxuICAgIGNvbnNvbGUubG9nKCdDZXJ0aWZpY2F0ZSBkZXRhaWxzOicsIGNlcnRpZmljYXRlcyk7XHJcbiAgICByZXR1cm4gY2VydGlmaWNhdGVzO1xyXG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGdldENlcnRpZmljYXRlczonLCBlcnJvcik7XHJcbiAgICBpZiAoZXJyb3IucmVhc29uKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ29udHJhY3QgZXJyb3I6ICR7ZXJyb3IucmVhc29ufWApO1xyXG4gICAgfVxyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGlzVmVyaWZpZWRVc2VyID0gYXN5bmMgKGFkZHJlc3M6IHN0cmluZykgPT4ge1xyXG4gIGlmICghYWRkcmVzcyB8fCAhZ2V0QWRkcmVzcyhhZGRyZXNzKSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFkZHJlc3MnKTtcclxuICB9XHJcblxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB7IGlkZW50aXR5Q29udHJhY3QgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xyXG4gICAgcmV0dXJuIGF3YWl0IGlkZW50aXR5Q29udHJhY3QuaXNWZXJpZmllZFVzZXIoYWRkcmVzcyk7XHJcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY2hlY2tpbmcgdmVyaWZpY2F0aW9uIHN0YXR1czonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBlcnJvcjtcclxuICB9XHJcbn07XHJcblxyXG4vLyBBZG1pbiBmdW5jdGlvbnNcclxuZXhwb3J0IGNvbnN0IGlzT3duZXIgPSBhc3luYyAoYWRkcmVzczogc3RyaW5nKSA9PiB7XHJcbiAgaWYgKCFhZGRyZXNzIHx8ICFnZXRBZGRyZXNzKGFkZHJlc3MpKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYWRkcmVzcycpO1xyXG4gIH1cclxuXHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHsgaWRlbnRpdHlDb250cmFjdCB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XHJcbiAgICBjb25zdCBvd25lciA9IGF3YWl0IGlkZW50aXR5Q29udHJhY3Qub3duZXIoKTtcclxuXHJcbiAgICAvLyBBZGQgYWRkaXRpb25hbCBjaGVja3NcclxuICAgIGlmICghb3duZXIpIHtcclxuICAgICAgY29uc29sZS53YXJuKCdPd25lciBhZGRyZXNzIGlzIG51bGwgb3IgdW5kZWZpbmVkJyk7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3duZXIudG9Mb3dlckNhc2UoKSA9PT0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xyXG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNoZWNraW5nIG93bmVyIHN0YXR1czonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBlcnJvcjtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgdmVyaWZ5SW5zdGl0dXRpb24gPSBhc3luYyAoaW5zdGl0dXRpb25BZGRyZXNzOiBzdHJpbmcpID0+IHtcclxuICBpZiAoIWluc3RpdHV0aW9uQWRkcmVzcyB8fCAhZ2V0QWRkcmVzcyhpbnN0aXR1dGlvbkFkZHJlc3MpKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5zdGl0dXRpb24gYWRkcmVzcycpO1xyXG4gIH1cclxuXHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGlkZW50aXR5Q29udHJhY3QgPSBhd2FpdCBnZXRJZGVudGl0eUNvbnRyYWN0KCk7XHJcbiAgICBjb25zdCBleGFtTWFuYWdlbWVudENvbnRyYWN0ID0gYXdhaXQgZ2V0RXhhbU1hbmFnZW1lbnRDb250cmFjdCgpO1xyXG4gICAgLy8gY29uc3QgaWRlbnRpdHlUeCA9IGF3YWl0IGlkZW50aXR5Q29udHJhY3QudmVyaWZ5VXNlcihpbnN0aXR1dGlvbkFkZHJlc3MpO1xyXG4gICAgLy8gYXdhaXQgaWRlbnRpdHlUeC53YWl0KCk7XHJcbiAgICBjb25zdCBleGFtTWFuYWdlbWVudFR4ID0gYXdhaXQgZXhhbU1hbmFnZW1lbnRDb250cmFjdC52ZXJpZnlJbnN0aXR1dGlvbihpbnN0aXR1dGlvbkFkZHJlc3MpO1xyXG4gICAgYXdhaXQgZXhhbU1hbmFnZW1lbnRUeC53YWl0KCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAvLyBpZGVudGl0eUhhc2g6IGlkZW50aXR5VHguaGFzaCxcclxuICAgICAgZXhhbU1hbmFnZW1lbnRIYXNoOiBleGFtTWFuYWdlbWVudFR4Lmhhc2hcclxuICAgIH07XHJcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgdmVyaWZ5aW5nIGluc3RpdHV0aW9uOicsIGVycm9yKTtcclxuICAgIHRocm93IGVycm9yO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRPd25lckFkZHJlc3MgPSBhc3luYyAoKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHsgaWRlbnRpdHlDb250cmFjdCB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XHJcbiAgICBjb25zdCBvd25lciA9IGF3YWl0IGlkZW50aXR5Q29udHJhY3Qub3duZXIoKTtcclxuICAgIHJldHVybiBvd25lcjtcclxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIG93bmVyIGFkZHJlc3M6JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gQWRkIGV4YW0gbWFuYWdlbWVudCBjb250cmFjdCBhZGRyZXNzIGFuZCBBQklcclxuY29uc3QgRVhBTV9NQU5BR0VNRU5UX0FERFJFU1MgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19FWEFNX01BTkFHRU1FTlRfQUREUkVTUyB8fCBcIlwiO1xyXG5jb25zdCBFWEFNX01BTkFHRU1FTlRfQUJJID0gRXhhbU1hbmFnZW1lbnRBQkk7XHJcblxyXG4vLyBBZGQgZXhhbSBtYW5hZ2VtZW50IGZ1bmN0aW9uc1xyXG5leHBvcnQgY29uc3QgY3JlYXRlRXhhbSA9IGFzeW5jIChcclxuICBpZDogc3RyaW5nLFxyXG4gIHRpdGxlOiBzdHJpbmcsXHJcbiAgZGVzY3JpcHRpb246IHN0cmluZyxcclxuICBkYXRlOiBudW1iZXIsXHJcbiAgZHVyYXRpb246IG51bWJlcixcclxuICBpcGZzSGFzaDogc3RyaW5nXHJcbikgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBpZiAoIXdpbmRvdy5ldGhlcmV1bSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGV0aGVyZXVtIHByb3ZpZGVyIGZvdW5kJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwcm92aWRlciA9IG5ldyBldGhlcnMuSnNvblJwY1Byb3ZpZGVyKEVYUEVDVEVEX05FVFdPUksucnBjVXJsKTtcclxuICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IHByb3ZpZGVyLmdldFNpZ25lcigpO1xyXG4gICAgY29uc3QgY29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KEVYQU1fTUFOQUdFTUVOVF9BRERSRVNTLCBFWEFNX01BTkFHRU1FTlRfQUJJLCBzaWduZXIpO1xyXG5cclxuICAgIGNvbnN0IHR4ID0gYXdhaXQgY29udHJhY3QuY3JlYXRlRXhhbShpZCwgdGl0bGUsIGRlc2NyaXB0aW9uLCBkYXRlLCBkdXJhdGlvbiwgaXBmc0hhc2gpO1xyXG4gICAgYXdhaXQgdHgud2FpdCgpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIGV4YW06JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHN1Ym1pdEV4YW1SZXN1bHQgPSBhc3luYyAoXHJcbiAgZXhhbUlkOiBzdHJpbmcsXHJcbiAgc3R1ZGVudDogc3RyaW5nLFxyXG4gIHNjb3JlOiBudW1iZXIsXHJcbiAgZ3JhZGU6IHN0cmluZyxcclxuICBpcGZzSGFzaDogc3RyaW5nXHJcbikgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBpZiAoIXdpbmRvdy5ldGhlcmV1bSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGV0aGVyZXVtIHByb3ZpZGVyIGZvdW5kJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwcm92aWRlciA9IG5ldyBldGhlcnMuSnNvblJwY1Byb3ZpZGVyKEVYUEVDVEVEX05FVFdPUksucnBjVXJsKTtcclxuICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IHByb3ZpZGVyLmdldFNpZ25lcigpO1xyXG4gICAgY29uc3QgY29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KEVYQU1fTUFOQUdFTUVOVF9BRERSRVNTLCBFWEFNX01BTkFHRU1FTlRfQUJJLCBzaWduZXIpO1xyXG5cclxuICAgIGNvbnN0IHR4ID0gYXdhaXQgY29udHJhY3Quc3VibWl0RXhhbVJlc3VsdChleGFtSWQsIHN0dWRlbnQsIHNjb3JlLCBncmFkZSwgaXBmc0hhc2gpO1xyXG4gICAgYXdhaXQgdHgud2FpdCgpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHN1Ym1pdHRpbmcgZXhhbSByZXN1bHQ6JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHVwZGF0ZUV4YW1TdGF0dXMgPSBhc3luYyAoZXhhbUlkOiBzdHJpbmcsIHN0YXR1czogc3RyaW5nKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGlmICghd2luZG93LmV0aGVyZXVtKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZXRoZXJldW0gcHJvdmlkZXIgZm91bmQnKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IGV0aGVycy5Kc29uUnBjUHJvdmlkZXIoRVhQRUNURURfTkVUV09SSy5ycGNVcmwpO1xyXG4gICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgcHJvdmlkZXIuZ2V0U2lnbmVyKCk7XHJcbiAgICBjb25zdCBjb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoRVhBTV9NQU5BR0VNRU5UX0FERFJFU1MsIEVYQU1fTUFOQUdFTUVOVF9BQkksIHNpZ25lcik7XHJcblxyXG4gICAgY29uc3QgdHggPSBhd2FpdCBjb250cmFjdC51cGRhdGVFeGFtU3RhdHVzKGV4YW1JZCwgc3RhdHVzKTtcclxuICAgIGF3YWl0IHR4LndhaXQoKTtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBleGFtIHN0YXR1czonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBlcnJvcjtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0RXhhbSA9IGFzeW5jIChleGFtSWQ6IHN0cmluZykgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBpZiAoIXdpbmRvdy5ldGhlcmV1bSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGV0aGVyZXVtIHByb3ZpZGVyIGZvdW5kJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwcm92aWRlciA9IG5ldyBldGhlcnMuSnNvblJwY1Byb3ZpZGVyKEVYUEVDVEVEX05FVFdPUksucnBjVXJsKTtcclxuICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChFWEFNX01BTkFHRU1FTlRfQUREUkVTUywgRVhBTV9NQU5BR0VNRU5UX0FCSSwgcHJvdmlkZXIpO1xyXG5cclxuICAgIGNvbnN0IGV4YW0gPSBhd2FpdCBjb250cmFjdC5nZXRFeGFtKGV4YW1JZCk7XHJcbiAgICByZXR1cm4gZXhhbTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBleGFtOicsIGVycm9yKTtcclxuICAgIHRocm93IGVycm9yO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRFeGFtUmVzdWx0ID0gYXN5bmMgKGV4YW1JZDogc3RyaW5nLCBzdHVkZW50OiBzdHJpbmcpID0+IHtcclxuICB0cnkge1xyXG4gICAgaWYgKCF3aW5kb3cuZXRoZXJldW0pIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBldGhlcmV1bSBwcm92aWRlciBmb3VuZCcpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgZXRoZXJzLkpzb25ScGNQcm92aWRlcihFWFBFQ1RFRF9ORVRXT1JLLnJwY1VybCk7XHJcbiAgICBjb25zdCBjb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoRVhBTV9NQU5BR0VNRU5UX0FERFJFU1MsIEVYQU1fTUFOQUdFTUVOVF9BQkksIHByb3ZpZGVyKTtcclxuXHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb250cmFjdC5nZXRFeGFtUmVzdWx0KGV4YW1JZCwgc3R1ZGVudCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIGV4YW0gcmVzdWx0OicsIGVycm9yKTtcclxuICAgIHRocm93IGVycm9yO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRJbnN0aXR1dGlvbkV4YW1zID0gYXN5bmMgKGluc3RpdHV0aW9uOiBzdHJpbmcpID0+IHtcclxuICB0cnkge1xyXG4gICAgaWYgKCF3aW5kb3cuZXRoZXJldW0pIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBldGhlcmV1bSBwcm92aWRlciBmb3VuZCcpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgZXRoZXJzLkpzb25ScGNQcm92aWRlcihFWFBFQ1RFRF9ORVRXT1JLLnJwY1VybCk7XHJcbiAgICBjb25zdCBjb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoRVhBTV9NQU5BR0VNRU5UX0FERFJFU1MsIEVYQU1fTUFOQUdFTUVOVF9BQkksIHByb3ZpZGVyKTtcclxuXHJcbiAgICBjb25zdCBleGFtcyA9IGF3YWl0IGNvbnRyYWN0LmdldEluc3RpdHV0aW9uRXhhbXMoaW5zdGl0dXRpb24pO1xyXG4gICAgcmV0dXJuIGV4YW1zO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIGluc3RpdHV0aW9uIGV4YW1zOicsIGVycm9yKTtcclxuICAgIHRocm93IGVycm9yO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRTdHVkZW50RXhhbXMgPSBhc3luYyAoc3R1ZGVudDogc3RyaW5nKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGlmICghd2luZG93LmV0aGVyZXVtKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZXRoZXJldW0gcHJvdmlkZXIgZm91bmQnKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IGV0aGVycy5Kc29uUnBjUHJvdmlkZXIoRVhQRUNURURfTkVUV09SSy5ycGNVcmwpO1xyXG4gICAgY29uc3QgY29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KEVYQU1fTUFOQUdFTUVOVF9BRERSRVNTLCBFWEFNX01BTkFHRU1FTlRfQUJJLCBwcm92aWRlcik7XHJcblxyXG4gICAgY29uc3QgZXhhbXMgPSBhd2FpdCBjb250cmFjdC5nZXRTdHVkZW50RXhhbXMoc3R1ZGVudCk7XHJcbiAgICByZXR1cm4gZXhhbXM7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgc3R1ZGVudCBleGFtczonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBlcnJvcjtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZW5yb2xsU3R1ZGVudCA9IGFzeW5jIChleGFtSWQ6IHN0cmluZywgc3R1ZGVudEFkZHJlc3M6IHN0cmluZykgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBpZiAoIXdpbmRvdy5ldGhlcmV1bSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGV0aGVyZXVtIHByb3ZpZGVyIGZvdW5kJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwcm92aWRlciA9IG5ldyBldGhlcnMuSnNvblJwY1Byb3ZpZGVyKEVYUEVDVEVEX05FVFdPUksucnBjVXJsKTtcclxuICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IHByb3ZpZGVyLmdldFNpZ25lcigpO1xyXG4gICAgY29uc3QgY29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KEVYQU1fTUFOQUdFTUVOVF9BRERSRVNTLCBFWEFNX01BTkFHRU1FTlRfQUJJLCBzaWduZXIpO1xyXG5cclxuICAgIGNvbnN0IHR4ID0gYXdhaXQgY29udHJhY3QuZW5yb2xsU3R1ZGVudChleGFtSWQsIHN0dWRlbnRBZGRyZXNzKTtcclxuICAgIGF3YWl0IHR4LndhaXQoKTtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBlbnJvbGxpbmcgc3R1ZGVudDonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBlcnJvcjtcclxuICB9XHJcbn07Il0sIm5hbWVzIjpbImV0aGVycyIsIkV4YW1NYW5hZ2VtZW50QUJJIiwiSWRlbnRpdHlBQkkiLCJDZXJ0aWZpY2F0ZXNBQkkiLCJnZXRQcm92aWRlciIsImdldFNpZ25lciIsIkVYUEVDVEVEX05FVFdPUksiLCJnZXRBZGRyZXNzIiwiZ2V0Q29uZmlnIiwiZ2V0SWRlbnRpdHlDb250cmFjdCIsImdldEV4YW1NYW5hZ2VtZW50Q29udHJhY3QiLCJJREVOVElUWV9DT05UUkFDVF9BRERSRVNTIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0lERU5USVRZX0NPTlRSQUNUX0FERFJFU1MiLCJDRVJUSUZJQ0FURVNfQ09OVFJBQ1RfQUREUkVTUyIsIk5FWFRfUFVCTElDX0NFUlRJRklDQVRFU19DT05UUkFDVF9BRERSRVNTIiwiRVhBTV9NQU5BR0VNRU5UX0NPTlRSQUNUX0FERFJFU1MiLCJORVhUX1BVQkxJQ19FWEFNX01BTkFHRU1FTlRfQ09OVFJBQ1RfQUREUkVTUyIsIlVTRVJfUk9MRVMiLCJOT05FIiwiU1RVREVOVCIsIklOU1RJVFVUSU9OIiwiRU1QTE9ZRVIiLCJyb2xlTWFwIiwiY29uc29sZSIsImVycm9yIiwiZ2V0Q29udHJhY3RzIiwicHJvdmlkZXIiLCJzaWduZXIiLCJpZGVudGl0eUNvbnRyYWN0IiwiQ29udHJhY3QiLCJjZXJ0aWZpY2F0ZXNDb250cmFjdCIsImV4YW1NYW5hZ2VtZW50Q29udHJhY3QiLCJFcnJvciIsIm1lc3NhZ2UiLCJyZWdpc3RlclVzZXIiLCJyb2xlIiwid2luZG93IiwiZXRoZXJldW0iLCJCcm93c2VyUHJvdmlkZXIiLCJpZGVudGl0eUFkZHJlc3MiLCJyb2xlVmFsdWUiLCJ0b0xvd2VyQ2FzZSIsInVuZGVmaW5lZCIsInR4Iiwid2FpdCIsInN0YXR1cyIsInZlcmlmeVVzZXIiLCJhZGRyZXNzIiwiZ2V0VXNlclJvbGUiLCJpc3N1ZUNlcnRpZmljYXRlIiwic3R1ZGVudEFkZHJlc3MiLCJpcGZzSGFzaCIsInZlcmlmeUNlcnRpZmljYXRlIiwiY2VydGlmaWNhdGVJZCIsImlzVmFsaWQiLCJnZXRDZXJ0aWZpY2F0ZXMiLCJsb2ciLCJjZXJ0aWZpY2F0ZUlkcyIsImdldFN0dWRlbnRDZXJ0aWZpY2F0ZXMiLCJsZW5ndGgiLCJjZXJ0aWZpY2F0ZXMiLCJQcm9taXNlIiwiYWxsIiwibWFwIiwiaWQiLCJjZXJ0IiwiaXNzdWVyIiwiaW5zdGl0dXRpb24iLCJ0aW1lc3RhbXAiLCJpc3N1ZWRBdCIsInRvU3RyaW5nIiwicmVhc29uIiwiaXNWZXJpZmllZFVzZXIiLCJpc093bmVyIiwib3duZXIiLCJ3YXJuIiwidmVyaWZ5SW5zdGl0dXRpb24iLCJpbnN0aXR1dGlvbkFkZHJlc3MiLCJleGFtTWFuYWdlbWVudFR4IiwiZXhhbU1hbmFnZW1lbnRIYXNoIiwiaGFzaCIsImdldE93bmVyQWRkcmVzcyIsIkVYQU1fTUFOQUdFTUVOVF9BRERSRVNTIiwiTkVYVF9QVUJMSUNfRVhBTV9NQU5BR0VNRU5UX0FERFJFU1MiLCJFWEFNX01BTkFHRU1FTlRfQUJJIiwiY3JlYXRlRXhhbSIsInRpdGxlIiwiZGVzY3JpcHRpb24iLCJkYXRlIiwiZHVyYXRpb24iLCJKc29uUnBjUHJvdmlkZXIiLCJycGNVcmwiLCJjb250cmFjdCIsInN1Ym1pdEV4YW1SZXN1bHQiLCJleGFtSWQiLCJzdHVkZW50Iiwic2NvcmUiLCJncmFkZSIsInVwZGF0ZUV4YW1TdGF0dXMiLCJnZXRFeGFtIiwiZXhhbSIsImdldEV4YW1SZXN1bHQiLCJyZXN1bHQiLCJnZXRJbnN0aXR1dGlvbkV4YW1zIiwiZXhhbXMiLCJnZXRTdHVkZW50RXhhbXMiLCJlbnJvbGxTdHVkZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./utils/contracts.ts\n"));

/***/ })

});