"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./utils/contracts.ts":
/*!****************************!*\
  !*** ./utils/contracts.ts ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createExam: function() { return /* binding */ createExam; },\n/* harmony export */   enrollStudent: function() { return /* binding */ enrollStudent; },\n/* harmony export */   getCertificates: function() { return /* binding */ getCertificates; },\n/* harmony export */   getContracts: function() { return /* binding */ getContracts; },\n/* harmony export */   getExam: function() { return /* binding */ getExam; },\n/* harmony export */   getExamResult: function() { return /* binding */ getExamResult; },\n/* harmony export */   getInstitutionExams: function() { return /* binding */ getInstitutionExams; },\n/* harmony export */   getOwnerAddress: function() { return /* binding */ getOwnerAddress; },\n/* harmony export */   getStudentExams: function() { return /* binding */ getStudentExams; },\n/* harmony export */   getUserRole: function() { return /* binding */ getUserRole; },\n/* harmony export */   isOwner: function() { return /* binding */ isOwner; },\n/* harmony export */   isVerifiedUser: function() { return /* binding */ isVerifiedUser; },\n/* harmony export */   issueCertificate: function() { return /* binding */ issueCertificate; },\n/* harmony export */   registerUser: function() { return /* binding */ registerUser; },\n/* harmony export */   submitExamResult: function() { return /* binding */ submitExamResult; },\n/* harmony export */   updateExamStatus: function() { return /* binding */ updateExamStatus; },\n/* harmony export */   verifyCertificate: function() { return /* binding */ verifyCertificate; },\n/* harmony export */   verifyInstitution: function() { return /* binding */ verifyInstitution; },\n/* harmony export */   verifyUser: function() { return /* binding */ verifyUser; }\n/* harmony export */ });\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ethers */ \"./node_modules/.pnpm/ethers@6.13.5_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/ethers/lib.esm/index.js\");\n/* harmony import */ var _constants_abis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/abis */ \"./constants/abis.ts\");\n/* harmony import */ var _ethersConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ethersConfig */ \"./utils/ethersConfig.ts\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/process/browser.js\");\n\n\n\n// Contract ABIs\nconst IdentityABI = [\n    \"function registerUser(uint8 _role, string memory _ipfsHash) external\",\n    \"function verifyUser(address _userAddress) external returns (bool)\",\n    \"function getUserRole(address _userAddress) external view returns (uint8)\",\n    \"function isVerifiedUser(address _userAddress) external view returns (bool)\",\n    \"function updateUserIPFS(string memory _newIpfsHash) external\",\n    // \"function owner() external view returns (address)\"\n    \"function owner() view returns (address)\"\n];\nconst CertificatesABI = [\n    \"function issueCertificate(address _studentAddress, string memory _ipfsHash) external returns (bytes32)\",\n    \"function getStudentCertificates(address _student) external view returns (bytes32[])\",\n    \"function verifyCertificate(bytes32 _certificateId) external view returns (address student, address institution, string ipfsHash, uint256 issuedAt, bool isValid)\"\n];\n// Contract addresses from .env\nconst IDENTITY_CONTRACT_ADDRESS = \"0xbEBcD3099b6766b4224f0624887616E099E4dCb4\";\nconst CERTIFICATES_CONTRACT_ADDRESS = \"0x82Ba41429a7ff6e503707c4E62b8073A39d6C98d\";\n// Role mapping with proper types\nconst USER_ROLES = {\n    NONE: 0,\n    STUDENT: 1,\n    INSTITUTION: 2,\n    EMPLOYER: 3\n};\nconst roleMap = {\n    [USER_ROLES.NONE]: \"none\",\n    [USER_ROLES.STUDENT]: \"student\",\n    [USER_ROLES.INSTITUTION]: \"institution\",\n    [USER_ROLES.EMPLOYER]: \"employer\"\n};\n// Validate environment variables\nif (!IDENTITY_CONTRACT_ADDRESS) {\n    console.error(\"NEXT_PUBLIC_IDENTITY_CONTRACT_ADDRESS is not set in .env\");\n}\nif (!CERTIFICATES_CONTRACT_ADDRESS) {\n    console.error(\"NEXT_PUBLIC_CERTIFICATES_CONTRACT_ADDRESS is not set in .env\");\n}\nconst getContracts = async ()=>{\n    try {\n        const provider = await (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getProvider)();\n        const signer = await (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getSigner)();\n        const identityContract = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.Contract(IDENTITY_CONTRACT_ADDRESS, IdentityABI, signer);\n        const certificatesContract = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.Contract(CERTIFICATES_CONTRACT_ADDRESS, CertificatesABI, signer);\n        return {\n            identityContract,\n            certificatesContract,\n            provider,\n            signer\n        };\n    } catch (error) {\n        console.error(\"Error initializing contracts:\", error);\n        throw new Error(\"Failed to initialize contracts: \".concat(error.message));\n    }\n};\nconst registerUser = async (role)=>{\n    if (!role) {\n        throw new Error(\"Role is required\");\n    }\n    try {\n        // Error.1 missing revert data  \n        // const provider = await getProvider();\n        // solve error.1\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.BrowserProvider(window.ethereum);\n        const signer = await provider.getSigner();\n        const contractAddress = \"0xbEBcD3099b6766b4224f0624887616E099E4dCb4\";\n        if (!contractAddress) {\n            throw new Error(\"Contract address is not configured\");\n        }\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.Contract(contractAddress, IdentityABI, signer);\n        // Convert role string to enum value\n        const roleMap = {\n            \"student\": 1,\n            \"institution\": 2,\n            \"employer\": 3\n        };\n        const roleValue = roleMap[role.toLowerCase()];\n        if (roleValue === undefined) {\n            throw new Error(\"Invalid role: \".concat(role, \". Must be one of: student, institution, employer\"));\n        }\n        // solve error.1 (option)\n        // const overrides = {\n        //   gasLimit: 500000, // Set a specific gas limit\n        // };\n        const tx = await contract.registerUser(roleValue, \"\" /*, overrides*/ );\n        await tx.wait();\n        return {\n            status: \"success\"\n        };\n    } catch (error) {\n        console.error(\"Registration error:\", error);\n        throw error;\n    }\n};\nconst verifyUser = async (address)=>{\n    if (!address || !(0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getAddress)(address)) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        const { identityContract } = await getContracts();\n        return await identityContract.verifyUser(address);\n    } catch (error) {\n        console.error(\"Error verifying user:\", error);\n        throw new Error(error.message || \"Failed to verify user\");\n    }\n};\nconst getUserRole = async (address)=>{\n    if (!address || !(0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getAddress)(address)) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        const { identityContract } = await getContracts();\n        const roleValue = await identityContract.getUserRole(address);\n        return roleMap[roleValue] || \"none\";\n    } catch (error) {\n        console.error(\"Error getting user role:\", error);\n        return \"none\";\n    }\n};\nconst issueCertificate = async (studentAddress, ipfsHash)=>{\n    if (!studentAddress || !ipfsHash) {\n        throw new Error(\"Student address and IPFS hash are required\");\n    }\n    try {\n        const { certificatesContract } = await getContracts();\n        const tx = await certificatesContract.issueCertificate(studentAddress, ipfsHash);\n        await tx.wait();\n        return tx;\n    } catch (error) {\n        console.error(\"Error issuing certificate:\", error);\n        throw error;\n    }\n};\nconst verifyCertificate = async (certificateId)=>{\n    if (!certificateId) {\n        throw new Error(\"Certificate ID is required\");\n    }\n    try {\n        const { certificatesContract } = await getContracts();\n        const isValid = await certificatesContract.verifyCertificate(certificateId);\n        return isValid;\n    } catch (error) {\n        console.error(\"Error verifying certificate:\", error);\n        throw error;\n    }\n};\nconst getCertificates = async (address)=>{\n    if (!address || !(0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getAddress)(address)) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        console.log(\"Getting certificates for address:\", address);\n        const { certificatesContract } = await getContracts();\n        // Get certificate IDs first\n        console.log(\"Getting certificate IDs...\");\n        const certificateIds = await certificatesContract.getStudentCertificates(address);\n        console.log(\"Certificate IDs:\", certificateIds);\n        if (!certificateIds || certificateIds.length === 0) {\n            console.log(\"No certificates found\");\n            return [];\n        }\n        // Get details for each certificate\n        console.log(\"Getting certificate details...\");\n        const certificates = await Promise.all(certificateIds.map(async (id)=>{\n            const cert = await certificatesContract.verifyCertificate(id);\n            return {\n                id,\n                ipfsHash: cert.ipfsHash,\n                issuer: cert.institution,\n                timestamp: cert.issuedAt.toString(),\n                isValid: cert.isValid\n            };\n        }));\n        console.log(\"Certificate details:\", certificates);\n        return certificates;\n    } catch (error) {\n        console.error(\"Error in getCertificates:\", error);\n        if (error.reason) {\n            throw new Error(\"Contract error: \".concat(error.reason));\n        }\n        throw error;\n    }\n};\nconst isVerifiedUser = async (address)=>{\n    if (!address || !(0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getAddress)(address)) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        const { identityContract } = await getContracts();\n        return await identityContract.isVerifiedUser(address);\n    } catch (error) {\n        console.error(\"Error checking verification status:\", error);\n        throw error;\n    }\n};\n// Admin functions\nconst isOwner = async (address)=>{\n    if (!address || !(0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getAddress)(address)) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        const { identityContract } = await getContracts();\n        const owner = await identityContract.owner();\n        // Add additional checks\n        if (!owner) {\n            console.warn(\"Owner address is null or undefined\");\n            return false;\n        }\n        return owner.toLowerCase() === address.toLowerCase();\n    } catch (error) {\n        console.error(\"Error checking owner status:\", error);\n        throw error;\n    }\n};\nconst verifyInstitution = async (institutionAddress)=>{\n    if (!institutionAddress || !(0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getAddress)(institutionAddress)) {\n        throw new Error(\"Invalid institution address\");\n    }\n    try {\n        const { identityContract } = await getContracts();\n        const tx = await identityContract.verifyUser(institutionAddress);\n        await tx.wait();\n        return tx;\n    } catch (error) {\n        console.error(\"Error verifying institution:\", error);\n        throw error;\n    }\n};\nconst getOwnerAddress = async ()=>{\n    try {\n        const { identityContract } = await getContracts();\n        const owner = await identityContract.owner();\n        return owner;\n    } catch (error) {\n        console.error(\"Error getting owner address:\", error);\n        throw error;\n    }\n};\n// Add exam management contract address and ABI\nconst EXAM_MANAGEMENT_ADDRESS = process.env.NEXT_PUBLIC_EXAM_MANAGEMENT_ADDRESS || \"\";\nconst EXAM_MANAGEMENT_ABI = _constants_abis__WEBPACK_IMPORTED_MODULE_0__.ExamManagementABI;\n// Add exam management functions\nconst createExam = async (id, title, description, date, duration, ipfsHash)=>{\n    try {\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.JsonRpcProvider(_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl);\n        const signer = await provider.getSigner();\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.Contract(EXAM_MANAGEMENT_ADDRESS, EXAM_MANAGEMENT_ABI, signer);\n        const tx = await contract.createExam(id, title, description, date, duration, ipfsHash);\n        await tx.wait();\n        return true;\n    } catch (error) {\n        console.error(\"Error creating exam:\", error);\n        throw error;\n    }\n};\nconst submitExamResult = async (examId, student, score, grade, ipfsHash)=>{\n    try {\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.JsonRpcProvider(_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl);\n        const signer = await provider.getSigner();\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.Contract(EXAM_MANAGEMENT_ADDRESS, EXAM_MANAGEMENT_ABI, signer);\n        const tx = await contract.submitExamResult(examId, student, score, grade, ipfsHash);\n        await tx.wait();\n        return true;\n    } catch (error) {\n        console.error(\"Error submitting exam result:\", error);\n        throw error;\n    }\n};\nconst updateExamStatus = async (examId, status)=>{\n    try {\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.JsonRpcProvider(_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl);\n        const signer = await provider.getSigner();\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.Contract(EXAM_MANAGEMENT_ADDRESS, EXAM_MANAGEMENT_ABI, signer);\n        const tx = await contract.updateExamStatus(examId, status);\n        await tx.wait();\n        return true;\n    } catch (error) {\n        console.error(\"Error updating exam status:\", error);\n        throw error;\n    }\n};\nconst getExam = async (examId)=>{\n    try {\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.JsonRpcProvider(_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl);\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.Contract(EXAM_MANAGEMENT_ADDRESS, EXAM_MANAGEMENT_ABI, provider);\n        const exam = await contract.getExam(examId);\n        return exam;\n    } catch (error) {\n        console.error(\"Error getting exam:\", error);\n        throw error;\n    }\n};\nconst getExamResult = async (examId, student)=>{\n    try {\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.JsonRpcProvider(_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl);\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.Contract(EXAM_MANAGEMENT_ADDRESS, EXAM_MANAGEMENT_ABI, provider);\n        const result = await contract.getExamResult(examId, student);\n        return result;\n    } catch (error) {\n        console.error(\"Error getting exam result:\", error);\n        throw error;\n    }\n};\nconst getInstitutionExams = async (institution)=>{\n    try {\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.JsonRpcProvider(_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl);\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.Contract(EXAM_MANAGEMENT_ADDRESS, EXAM_MANAGEMENT_ABI, provider);\n        const exams = await contract.getInstitutionExams(institution);\n        return exams;\n    } catch (error) {\n        console.error(\"Error getting institution exams:\", error);\n        throw error;\n    }\n};\nconst getStudentExams = async (student)=>{\n    try {\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.JsonRpcProvider(_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl);\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.Contract(EXAM_MANAGEMENT_ADDRESS, EXAM_MANAGEMENT_ABI, provider);\n        const exams = await contract.getStudentExams(student);\n        return exams;\n    } catch (error) {\n        console.error(\"Error getting student exams:\", error);\n        throw error;\n    }\n};\nconst enrollStudent = async (examId, studentAddress)=>{\n    try {\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.JsonRpcProvider(_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl);\n        const signer = await provider.getSigner();\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.Contract(EXAM_MANAGEMENT_ADDRESS, EXAM_MANAGEMENT_ABI, signer);\n        const tx = await contract.enrollStudent(examId, studentAddress);\n        await tx.wait();\n        return true;\n    } catch (error) {\n        console.error(\"Error enrolling student:\", error);\n        throw error;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RTtBQUVLLE1BQU04RSxnQkFBZ0IsT0FBT1osUUFBZ0J4QztJQUNsRCxJQUFJO1FBQ0YsSUFBSSxDQUFDZixPQUFPQyxRQUFRLEVBQUU7WUFDcEIsTUFBTSxJQUFJTCxNQUFNO1FBQ2xCO1FBQ0EsTUFBTUwsV0FBVyxJQUFJdkIsMENBQU1BLENBQUNvRixlQUFlLENBQUNoRiwyREFBZ0JBLENBQUNpRixNQUFNO1FBQ25FLE1BQU03RCxTQUFTLE1BQU1ELFNBQVNwQixTQUFTO1FBQ3ZDLE1BQU1pQyxXQUFXLElBQUlwQywwQ0FBTUEsQ0FBQzBCLFFBQVEsQ0FBQ2tELHlCQUF5QkUscUJBQXFCdEQ7UUFFbkYsTUFBTWdCLEtBQUssTUFBTUosU0FBUytELGFBQWEsQ0FBQ1osUUFBUXhDO1FBQ2hELE1BQU1QLEdBQUdDLElBQUk7UUFDYixPQUFPO0lBQ1QsRUFBRSxPQUFPcEIsT0FBTztRQUNkRCxRQUFRQyxLQUFLLENBQUMsNEJBQTRCQTtRQUMxQyxNQUFNQTtJQUNSO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi91dGlscy9jb250cmFjdHMudHM/OTg1NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBldGhlcnMgfSBmcm9tICdldGhlcnMnO1xuaW1wb3J0IHsgRXhhbU1hbmFnZW1lbnRBQkkgfSBmcm9tICcuLi9jb25zdGFudHMvYWJpcyc7XG5pbXBvcnQge1xuICBnZXRQcm92aWRlcixcbiAgZ2V0U2lnbmVyLFxuICBFWFBFQ1RFRF9ORVRXT1JLLFxuICB2YWxpZGF0ZU5ldHdvcmssXG4gIGZvcm1hdEV0aGVyLFxuICBoYW5kbGVDb250cmFjdEVycm9yLFxuICBnZXRBZGRyZXNzLFxuICB0eXBlIEV0aGVyZXVtUHJvdmlkZXJcbn0gZnJvbSAnLi9ldGhlcnNDb25maWcnO1xuXG4vLyBDb250cmFjdCBBQklzXG5jb25zdCBJZGVudGl0eUFCSSA9IFtcbiAgXCJmdW5jdGlvbiByZWdpc3RlclVzZXIodWludDggX3JvbGUsIHN0cmluZyBtZW1vcnkgX2lwZnNIYXNoKSBleHRlcm5hbFwiLFxuICBcImZ1bmN0aW9uIHZlcmlmeVVzZXIoYWRkcmVzcyBfdXNlckFkZHJlc3MpIGV4dGVybmFsIHJldHVybnMgKGJvb2wpXCIsXG4gIFwiZnVuY3Rpb24gZ2V0VXNlclJvbGUoYWRkcmVzcyBfdXNlckFkZHJlc3MpIGV4dGVybmFsIHZpZXcgcmV0dXJucyAodWludDgpXCIsXG4gIFwiZnVuY3Rpb24gaXNWZXJpZmllZFVzZXIoYWRkcmVzcyBfdXNlckFkZHJlc3MpIGV4dGVybmFsIHZpZXcgcmV0dXJucyAoYm9vbClcIixcbiAgXCJmdW5jdGlvbiB1cGRhdGVVc2VySVBGUyhzdHJpbmcgbWVtb3J5IF9uZXdJcGZzSGFzaCkgZXh0ZXJuYWxcIixcbiAgLy8gXCJmdW5jdGlvbiBvd25lcigpIGV4dGVybmFsIHZpZXcgcmV0dXJucyAoYWRkcmVzcylcIlxuICBcImZ1bmN0aW9uIG93bmVyKCkgdmlldyByZXR1cm5zIChhZGRyZXNzKVwiXG5dO1xuXG5jb25zdCBDZXJ0aWZpY2F0ZXNBQkkgPSBbXG4gIFwiZnVuY3Rpb24gaXNzdWVDZXJ0aWZpY2F0ZShhZGRyZXNzIF9zdHVkZW50QWRkcmVzcywgc3RyaW5nIG1lbW9yeSBfaXBmc0hhc2gpIGV4dGVybmFsIHJldHVybnMgKGJ5dGVzMzIpXCIsXG4gIFwiZnVuY3Rpb24gZ2V0U3R1ZGVudENlcnRpZmljYXRlcyhhZGRyZXNzIF9zdHVkZW50KSBleHRlcm5hbCB2aWV3IHJldHVybnMgKGJ5dGVzMzJbXSlcIixcbiAgXCJmdW5jdGlvbiB2ZXJpZnlDZXJ0aWZpY2F0ZShieXRlczMyIF9jZXJ0aWZpY2F0ZUlkKSBleHRlcm5hbCB2aWV3IHJldHVybnMgKGFkZHJlc3Mgc3R1ZGVudCwgYWRkcmVzcyBpbnN0aXR1dGlvbiwgc3RyaW5nIGlwZnNIYXNoLCB1aW50MjU2IGlzc3VlZEF0LCBib29sIGlzVmFsaWQpXCJcbl07XG5cbi8vIENvbnRyYWN0IGFkZHJlc3NlcyBmcm9tIC5lbnZcbmNvbnN0IElERU5USVRZX0NPTlRSQUNUX0FERFJFU1MgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19JREVOVElUWV9DT05UUkFDVF9BRERSRVNTO1xuY29uc3QgQ0VSVElGSUNBVEVTX0NPTlRSQUNUX0FERFJFU1MgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19DRVJUSUZJQ0FURVNfQ09OVFJBQ1RfQUREUkVTUztcblxuLy8gUm9sZSBtYXBwaW5nIHdpdGggcHJvcGVyIHR5cGVzXG5jb25zdCBVU0VSX1JPTEVTID0ge1xuICBOT05FOiAwLFxuICBTVFVERU5UOiAxLFxuICBJTlNUSVRVVElPTjogMixcbiAgRU1QTE9ZRVI6IDNcbn0gYXMgY29uc3Q7XG5cbnR5cGUgUm9sZVZhbHVlID0gdHlwZW9mIFVTRVJfUk9MRVNba2V5b2YgdHlwZW9mIFVTRVJfUk9MRVNdO1xudHlwZSBSb2xlU3RyaW5nID0gJ25vbmUnIHwgJ3N0dWRlbnQnIHwgJ2luc3RpdHV0aW9uJyB8ICdlbXBsb3llcic7XG5cbmNvbnN0IHJvbGVNYXA6IFJlY29yZDxSb2xlVmFsdWUsIFJvbGVTdHJpbmc+ID0ge1xuICBbVVNFUl9ST0xFUy5OT05FXTogJ25vbmUnLFxuICBbVVNFUl9ST0xFUy5TVFVERU5UXTogJ3N0dWRlbnQnLFxuICBbVVNFUl9ST0xFUy5JTlNUSVRVVElPTl06ICdpbnN0aXR1dGlvbicsXG4gIFtVU0VSX1JPTEVTLkVNUExPWUVSXTogJ2VtcGxveWVyJ1xufTtcblxuLy8gVmFsaWRhdGUgZW52aXJvbm1lbnQgdmFyaWFibGVzXG5pZiAoIUlERU5USVRZX0NPTlRSQUNUX0FERFJFU1MpIHtcbiAgY29uc29sZS5lcnJvcignTkVYVF9QVUJMSUNfSURFTlRJVFlfQ09OVFJBQ1RfQUREUkVTUyBpcyBub3Qgc2V0IGluIC5lbnYnKTtcbn1cbmlmICghQ0VSVElGSUNBVEVTX0NPTlRSQUNUX0FERFJFU1MpIHtcbiAgY29uc29sZS5lcnJvcignTkVYVF9QVUJMSUNfQ0VSVElGSUNBVEVTX0NPTlRSQUNUX0FERFJFU1MgaXMgbm90IHNldCBpbiAuZW52Jyk7XG59XG5cbmV4cG9ydCBjb25zdCBnZXRDb250cmFjdHMgPSBhc3luYyAoKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCBnZXRQcm92aWRlcigpO1xuICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IGdldFNpZ25lcigpO1xuXG4gICAgY29uc3QgaWRlbnRpdHlDb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoXG4gICAgICBJREVOVElUWV9DT05UUkFDVF9BRERSRVNTISxcbiAgICAgIElkZW50aXR5QUJJLFxuICAgICAgc2lnbmVyXG4gICAgKTtcblxuICAgIGNvbnN0IGNlcnRpZmljYXRlc0NvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChcbiAgICAgIENFUlRJRklDQVRFU19DT05UUkFDVF9BRERSRVNTISxcbiAgICAgIENlcnRpZmljYXRlc0FCSSxcbiAgICAgIHNpZ25lclxuICAgICk7XG5cbiAgICByZXR1cm4geyBpZGVudGl0eUNvbnRyYWN0LCBjZXJ0aWZpY2F0ZXNDb250cmFjdCwgcHJvdmlkZXIsIHNpZ25lciB9O1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW5pdGlhbGl6aW5nIGNvbnRyYWN0czonLCBlcnJvcik7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gaW5pdGlhbGl6ZSBjb250cmFjdHM6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHJlZ2lzdGVyVXNlciA9IGFzeW5jIChyb2xlOiBzdHJpbmcpID0+IHtcbiAgaWYgKCFyb2xlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSb2xlIGlzIHJlcXVpcmVkJyk7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIEVycm9yLjEgbWlzc2luZyByZXZlcnQgZGF0YSAgXG4gICAgLy8gY29uc3QgcHJvdmlkZXIgPSBhd2FpdCBnZXRQcm92aWRlcigpO1xuICAgIFxuICAgIC8vIHNvbHZlIGVycm9yLjFcbiAgICBpZiAoIXdpbmRvdy5ldGhlcmV1bSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBldGhlcmV1bSBwcm92aWRlciBmb3VuZCcpO1xuICAgIH1cbiAgICBjb25zdCBwcm92aWRlciA9IG5ldyBldGhlcnMuQnJvd3NlclByb3ZpZGVyKHdpbmRvdy5ldGhlcmV1bSk7XG5cbiAgICBjb25zdCBzaWduZXIgPSBhd2FpdCBwcm92aWRlci5nZXRTaWduZXIoKTtcbiAgICBjb25zdCBjb250cmFjdEFkZHJlc3MgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19JREVOVElUWV9DT05UUkFDVF9BRERSRVNTO1xuICAgIFxuICAgIGlmICghY29udHJhY3RBZGRyZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnRyYWN0IGFkZHJlc3MgaXMgbm90IGNvbmZpZ3VyZWQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoY29udHJhY3RBZGRyZXNzLCBJZGVudGl0eUFCSSwgc2lnbmVyKTtcblxuICAgIC8vIENvbnZlcnQgcm9sZSBzdHJpbmcgdG8gZW51bSB2YWx1ZVxuICAgIGNvbnN0IHJvbGVNYXA6IHsgW2tleTogc3RyaW5nXTogbnVtYmVyIH0gPSB7XG4gICAgICAnc3R1ZGVudCc6IDEsXG4gICAgICAnaW5zdGl0dXRpb24nOiAyLFxuICAgICAgJ2VtcGxveWVyJzogM1xuICAgIH07XG5cbiAgICBjb25zdCByb2xlVmFsdWUgPSByb2xlTWFwW3JvbGUudG9Mb3dlckNhc2UoKV07XG4gICAgaWYgKHJvbGVWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcm9sZTogJHtyb2xlfS4gTXVzdCBiZSBvbmUgb2Y6IHN0dWRlbnQsIGluc3RpdHV0aW9uLCBlbXBsb3llcmApO1xuICAgIH1cblxuICAgIC8vIHNvbHZlIGVycm9yLjEgKG9wdGlvbilcbiAgICAvLyBjb25zdCBvdmVycmlkZXMgPSB7XG4gICAgLy8gICBnYXNMaW1pdDogNTAwMDAwLCAvLyBTZXQgYSBzcGVjaWZpYyBnYXMgbGltaXRcbiAgICAvLyB9O1xuXG4gICAgY29uc3QgdHggPSBhd2FpdCBjb250cmFjdC5yZWdpc3RlclVzZXIocm9sZVZhbHVlLCBcIlwiLyosIG92ZXJyaWRlcyovKTtcbiAgICBhd2FpdCB0eC53YWl0KCk7XG4gICAgcmV0dXJuIHsgc3RhdHVzOiAnc3VjY2VzcycgfTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1JlZ2lzdHJhdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCB2ZXJpZnlVc2VyID0gYXN5bmMgKGFkZHJlc3M6IHN0cmluZykgPT4ge1xuICBpZiAoIWFkZHJlc3MgfHwgIWdldEFkZHJlc3MoYWRkcmVzcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYWRkcmVzcycpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCB7IGlkZW50aXR5Q29udHJhY3QgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xuICAgIHJldHVybiBhd2FpdCBpZGVudGl0eUNvbnRyYWN0LnZlcmlmeVVzZXIoYWRkcmVzcyk7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciB2ZXJpZnlpbmcgdXNlcjonLCBlcnJvcik7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVycm9yLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byB2ZXJpZnkgdXNlcicpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0VXNlclJvbGUgPSBhc3luYyAoYWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTxSb2xlU3RyaW5nPiA9PiB7XG4gIGlmICghYWRkcmVzcyB8fCAhZ2V0QWRkcmVzcyhhZGRyZXNzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhZGRyZXNzJyk7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IHsgaWRlbnRpdHlDb250cmFjdCB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XG4gICAgY29uc3Qgcm9sZVZhbHVlID0gYXdhaXQgaWRlbnRpdHlDb250cmFjdC5nZXRVc2VyUm9sZShhZGRyZXNzKTtcbiAgICByZXR1cm4gcm9sZU1hcFtyb2xlVmFsdWUgYXMgUm9sZVZhbHVlXSB8fCAnbm9uZSc7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHVzZXIgcm9sZTonLCBlcnJvcik7XG4gICAgcmV0dXJuICdub25lJztcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGlzc3VlQ2VydGlmaWNhdGUgPSBhc3luYyAoc3R1ZGVudEFkZHJlc3M6IHN0cmluZywgaXBmc0hhc2g6IHN0cmluZykgPT4ge1xuICBpZiAoIXN0dWRlbnRBZGRyZXNzIHx8ICFpcGZzSGFzaCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU3R1ZGVudCBhZGRyZXNzIGFuZCBJUEZTIGhhc2ggYXJlIHJlcXVpcmVkJyk7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IHsgY2VydGlmaWNhdGVzQ29udHJhY3QgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xuICAgIGNvbnN0IHR4ID0gYXdhaXQgY2VydGlmaWNhdGVzQ29udHJhY3QuaXNzdWVDZXJ0aWZpY2F0ZShzdHVkZW50QWRkcmVzcywgaXBmc0hhc2gpO1xuICAgIGF3YWl0IHR4LndhaXQoKTtcbiAgICByZXR1cm4gdHg7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpc3N1aW5nIGNlcnRpZmljYXRlOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHZlcmlmeUNlcnRpZmljYXRlID0gYXN5bmMgKGNlcnRpZmljYXRlSWQ6IHN0cmluZykgPT4ge1xuICBpZiAoIWNlcnRpZmljYXRlSWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NlcnRpZmljYXRlIElEIGlzIHJlcXVpcmVkJyk7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IHsgY2VydGlmaWNhdGVzQ29udHJhY3QgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xuICAgIGNvbnN0IGlzVmFsaWQgPSBhd2FpdCBjZXJ0aWZpY2F0ZXNDb250cmFjdC52ZXJpZnlDZXJ0aWZpY2F0ZShjZXJ0aWZpY2F0ZUlkKTtcbiAgICByZXR1cm4gaXNWYWxpZDtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHZlcmlmeWluZyBjZXJ0aWZpY2F0ZTonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBnZXRDZXJ0aWZpY2F0ZXMgPSBhc3luYyAoYWRkcmVzczogc3RyaW5nKSA9PiB7XG4gIGlmICghYWRkcmVzcyB8fCAhZ2V0QWRkcmVzcyhhZGRyZXNzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhZGRyZXNzJyk7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCdHZXR0aW5nIGNlcnRpZmljYXRlcyBmb3IgYWRkcmVzczonLCBhZGRyZXNzKTtcbiAgICBjb25zdCB7IGNlcnRpZmljYXRlc0NvbnRyYWN0IH0gPSBhd2FpdCBnZXRDb250cmFjdHMoKTtcblxuICAgIC8vIEdldCBjZXJ0aWZpY2F0ZSBJRHMgZmlyc3RcbiAgICBjb25zb2xlLmxvZygnR2V0dGluZyBjZXJ0aWZpY2F0ZSBJRHMuLi4nKTtcbiAgICBjb25zdCBjZXJ0aWZpY2F0ZUlkcyA9IGF3YWl0IGNlcnRpZmljYXRlc0NvbnRyYWN0LmdldFN0dWRlbnRDZXJ0aWZpY2F0ZXMoYWRkcmVzcyk7XG4gICAgY29uc29sZS5sb2coJ0NlcnRpZmljYXRlIElEczonLCBjZXJ0aWZpY2F0ZUlkcyk7XG5cbiAgICBpZiAoIWNlcnRpZmljYXRlSWRzIHx8IGNlcnRpZmljYXRlSWRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc29sZS5sb2coJ05vIGNlcnRpZmljYXRlcyBmb3VuZCcpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIC8vIEdldCBkZXRhaWxzIGZvciBlYWNoIGNlcnRpZmljYXRlXG4gICAgY29uc29sZS5sb2coJ0dldHRpbmcgY2VydGlmaWNhdGUgZGV0YWlscy4uLicpO1xuICAgIGNvbnN0IGNlcnRpZmljYXRlcyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgY2VydGlmaWNhdGVJZHMubWFwKGFzeW5jIChpZDogc3RyaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0IGNlcnQgPSBhd2FpdCBjZXJ0aWZpY2F0ZXNDb250cmFjdC52ZXJpZnlDZXJ0aWZpY2F0ZShpZCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaWQsXG4gICAgICAgICAgaXBmc0hhc2g6IGNlcnQuaXBmc0hhc2gsXG4gICAgICAgICAgaXNzdWVyOiBjZXJ0Lmluc3RpdHV0aW9uLFxuICAgICAgICAgIHRpbWVzdGFtcDogY2VydC5pc3N1ZWRBdC50b1N0cmluZygpLFxuICAgICAgICAgIGlzVmFsaWQ6IGNlcnQuaXNWYWxpZFxuICAgICAgICB9O1xuICAgICAgfSlcbiAgICApO1xuXG4gICAgY29uc29sZS5sb2coJ0NlcnRpZmljYXRlIGRldGFpbHM6JywgY2VydGlmaWNhdGVzKTtcbiAgICByZXR1cm4gY2VydGlmaWNhdGVzO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gZ2V0Q2VydGlmaWNhdGVzOicsIGVycm9yKTtcbiAgICBpZiAoZXJyb3IucmVhc29uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbnRyYWN0IGVycm9yOiAke2Vycm9yLnJlYXNvbn1gKTtcbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBpc1ZlcmlmaWVkVXNlciA9IGFzeW5jIChhZGRyZXNzOiBzdHJpbmcpID0+IHtcbiAgaWYgKCFhZGRyZXNzIHx8ICFnZXRBZGRyZXNzKGFkZHJlc3MpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFkZHJlc3MnKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgeyBpZGVudGl0eUNvbnRyYWN0IH0gPSBhd2FpdCBnZXRDb250cmFjdHMoKTtcbiAgICByZXR1cm4gYXdhaXQgaWRlbnRpdHlDb250cmFjdC5pc1ZlcmlmaWVkVXNlcihhZGRyZXNzKTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNoZWNraW5nIHZlcmlmaWNhdGlvbiBzdGF0dXM6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG4vLyBBZG1pbiBmdW5jdGlvbnNcbmV4cG9ydCBjb25zdCBpc093bmVyID0gYXN5bmMgKGFkZHJlc3M6IHN0cmluZykgPT4ge1xuICBpZiAoIWFkZHJlc3MgfHwgIWdldEFkZHJlc3MoYWRkcmVzcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYWRkcmVzcycpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCB7IGlkZW50aXR5Q29udHJhY3QgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xuICAgIGNvbnN0IG93bmVyID0gYXdhaXQgaWRlbnRpdHlDb250cmFjdC5vd25lcigpO1xuXG4gICAgLy8gQWRkIGFkZGl0aW9uYWwgY2hlY2tzXG4gICAgaWYgKCFvd25lcikge1xuICAgICAgY29uc29sZS53YXJuKCdPd25lciBhZGRyZXNzIGlzIG51bGwgb3IgdW5kZWZpbmVkJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIG93bmVyLnRvTG93ZXJDYXNlKCkgPT09IGFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNoZWNraW5nIG93bmVyIHN0YXR1czonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCB2ZXJpZnlJbnN0aXR1dGlvbiA9IGFzeW5jIChpbnN0aXR1dGlvbkFkZHJlc3M6IHN0cmluZykgPT4ge1xuICBpZiAoIWluc3RpdHV0aW9uQWRkcmVzcyB8fCAhZ2V0QWRkcmVzcyhpbnN0aXR1dGlvbkFkZHJlc3MpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGluc3RpdHV0aW9uIGFkZHJlc3MnKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgeyBpZGVudGl0eUNvbnRyYWN0IH0gPSBhd2FpdCBnZXRDb250cmFjdHMoKTtcbiAgICBjb25zdCB0eCA9IGF3YWl0IGlkZW50aXR5Q29udHJhY3QudmVyaWZ5VXNlcihpbnN0aXR1dGlvbkFkZHJlc3MpO1xuICAgIGF3YWl0IHR4LndhaXQoKTtcbiAgICByZXR1cm4gdHg7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciB2ZXJpZnlpbmcgaW5zdGl0dXRpb246JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0T3duZXJBZGRyZXNzID0gYXN5bmMgKCkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgaWRlbnRpdHlDb250cmFjdCB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XG4gICAgY29uc3Qgb3duZXIgPSBhd2FpdCBpZGVudGl0eUNvbnRyYWN0Lm93bmVyKCk7XG4gICAgcmV0dXJuIG93bmVyO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBvd25lciBhZGRyZXNzOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxuLy8gQWRkIGV4YW0gbWFuYWdlbWVudCBjb250cmFjdCBhZGRyZXNzIGFuZCBBQklcbmNvbnN0IEVYQU1fTUFOQUdFTUVOVF9BRERSRVNTID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRVhBTV9NQU5BR0VNRU5UX0FERFJFU1MgfHwgXCJcIjtcbmNvbnN0IEVYQU1fTUFOQUdFTUVOVF9BQkkgPSBFeGFtTWFuYWdlbWVudEFCSTtcblxuLy8gQWRkIGV4YW0gbWFuYWdlbWVudCBmdW5jdGlvbnNcbmV4cG9ydCBjb25zdCBjcmVhdGVFeGFtID0gYXN5bmMgKFxuICBpZDogc3RyaW5nLFxuICB0aXRsZTogc3RyaW5nLFxuICBkZXNjcmlwdGlvbjogc3RyaW5nLFxuICBkYXRlOiBudW1iZXIsXG4gIGR1cmF0aW9uOiBudW1iZXIsXG4gIGlwZnNIYXNoOiBzdHJpbmdcbikgPT4ge1xuICB0cnkge1xuICAgIGlmICghd2luZG93LmV0aGVyZXVtKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGV0aGVyZXVtIHByb3ZpZGVyIGZvdW5kJyk7XG4gICAgfVxuICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IGV0aGVycy5Kc29uUnBjUHJvdmlkZXIoRVhQRUNURURfTkVUV09SSy5ycGNVcmwpO1xuICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IHByb3ZpZGVyLmdldFNpZ25lcigpO1xuICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChFWEFNX01BTkFHRU1FTlRfQUREUkVTUywgRVhBTV9NQU5BR0VNRU5UX0FCSSwgc2lnbmVyKTtcblxuICAgIGNvbnN0IHR4ID0gYXdhaXQgY29udHJhY3QuY3JlYXRlRXhhbShpZCwgdGl0bGUsIGRlc2NyaXB0aW9uLCBkYXRlLCBkdXJhdGlvbiwgaXBmc0hhc2gpO1xuICAgIGF3YWl0IHR4LndhaXQoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBleGFtOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHN1Ym1pdEV4YW1SZXN1bHQgPSBhc3luYyAoXG4gIGV4YW1JZDogc3RyaW5nLFxuICBzdHVkZW50OiBzdHJpbmcsXG4gIHNjb3JlOiBudW1iZXIsXG4gIGdyYWRlOiBzdHJpbmcsXG4gIGlwZnNIYXNoOiBzdHJpbmdcbikgPT4ge1xuICB0cnkge1xuICAgIGlmICghd2luZG93LmV0aGVyZXVtKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGV0aGVyZXVtIHByb3ZpZGVyIGZvdW5kJyk7XG4gICAgfVxuICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IGV0aGVycy5Kc29uUnBjUHJvdmlkZXIoRVhQRUNURURfTkVUV09SSy5ycGNVcmwpO1xuICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IHByb3ZpZGVyLmdldFNpZ25lcigpO1xuICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChFWEFNX01BTkFHRU1FTlRfQUREUkVTUywgRVhBTV9NQU5BR0VNRU5UX0FCSSwgc2lnbmVyKTtcblxuICAgIGNvbnN0IHR4ID0gYXdhaXQgY29udHJhY3Quc3VibWl0RXhhbVJlc3VsdChleGFtSWQsIHN0dWRlbnQsIHNjb3JlLCBncmFkZSwgaXBmc0hhc2gpO1xuICAgIGF3YWl0IHR4LndhaXQoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzdWJtaXR0aW5nIGV4YW0gcmVzdWx0OicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHVwZGF0ZUV4YW1TdGF0dXMgPSBhc3luYyAoZXhhbUlkOiBzdHJpbmcsIHN0YXR1czogc3RyaW5nKSA9PiB7XG4gIHRyeSB7XG4gICAgaWYgKCF3aW5kb3cuZXRoZXJldW0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZXRoZXJldW0gcHJvdmlkZXIgZm91bmQnKTtcbiAgICB9XG4gICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgZXRoZXJzLkpzb25ScGNQcm92aWRlcihFWFBFQ1RFRF9ORVRXT1JLLnJwY1VybCk7XG4gICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgcHJvdmlkZXIuZ2V0U2lnbmVyKCk7XG4gICAgY29uc3QgY29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KEVYQU1fTUFOQUdFTUVOVF9BRERSRVNTLCBFWEFNX01BTkFHRU1FTlRfQUJJLCBzaWduZXIpO1xuXG4gICAgY29uc3QgdHggPSBhd2FpdCBjb250cmFjdC51cGRhdGVFeGFtU3RhdHVzKGV4YW1JZCwgc3RhdHVzKTtcbiAgICBhd2FpdCB0eC53YWl0KCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgZXhhbSBzdGF0dXM6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0RXhhbSA9IGFzeW5jIChleGFtSWQ6IHN0cmluZykgPT4ge1xuICB0cnkge1xuICAgIGlmICghd2luZG93LmV0aGVyZXVtKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGV0aGVyZXVtIHByb3ZpZGVyIGZvdW5kJyk7XG4gICAgfVxuICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IGV0aGVycy5Kc29uUnBjUHJvdmlkZXIoRVhQRUNURURfTkVUV09SSy5ycGNVcmwpO1xuICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChFWEFNX01BTkFHRU1FTlRfQUREUkVTUywgRVhBTV9NQU5BR0VNRU5UX0FCSSwgcHJvdmlkZXIpO1xuXG4gICAgY29uc3QgZXhhbSA9IGF3YWl0IGNvbnRyYWN0LmdldEV4YW0oZXhhbUlkKTtcbiAgICByZXR1cm4gZXhhbTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIGV4YW06JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0RXhhbVJlc3VsdCA9IGFzeW5jIChleGFtSWQ6IHN0cmluZywgc3R1ZGVudDogc3RyaW5nKSA9PiB7XG4gIHRyeSB7XG4gICAgaWYgKCF3aW5kb3cuZXRoZXJldW0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZXRoZXJldW0gcHJvdmlkZXIgZm91bmQnKTtcbiAgICB9XG4gICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgZXRoZXJzLkpzb25ScGNQcm92aWRlcihFWFBFQ1RFRF9ORVRXT1JLLnJwY1VybCk7XG4gICAgY29uc3QgY29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KEVYQU1fTUFOQUdFTUVOVF9BRERSRVNTLCBFWEFNX01BTkFHRU1FTlRfQUJJLCBwcm92aWRlcik7XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb250cmFjdC5nZXRFeGFtUmVzdWx0KGV4YW1JZCwgc3R1ZGVudCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIGV4YW0gcmVzdWx0OicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGdldEluc3RpdHV0aW9uRXhhbXMgPSBhc3luYyAoaW5zdGl0dXRpb246IHN0cmluZykgPT4ge1xuICB0cnkge1xuICAgIGlmICghd2luZG93LmV0aGVyZXVtKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGV0aGVyZXVtIHByb3ZpZGVyIGZvdW5kJyk7XG4gICAgfVxuICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IGV0aGVycy5Kc29uUnBjUHJvdmlkZXIoRVhQRUNURURfTkVUV09SSy5ycGNVcmwpO1xuICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChFWEFNX01BTkFHRU1FTlRfQUREUkVTUywgRVhBTV9NQU5BR0VNRU5UX0FCSSwgcHJvdmlkZXIpO1xuXG4gICAgY29uc3QgZXhhbXMgPSBhd2FpdCBjb250cmFjdC5nZXRJbnN0aXR1dGlvbkV4YW1zKGluc3RpdHV0aW9uKTtcbiAgICByZXR1cm4gZXhhbXM7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBpbnN0aXR1dGlvbiBleGFtczonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBnZXRTdHVkZW50RXhhbXMgPSBhc3luYyAoc3R1ZGVudDogc3RyaW5nKSA9PiB7XG4gIHRyeSB7XG4gICAgaWYgKCF3aW5kb3cuZXRoZXJldW0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZXRoZXJldW0gcHJvdmlkZXIgZm91bmQnKTtcbiAgICB9XG4gICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgZXRoZXJzLkpzb25ScGNQcm92aWRlcihFWFBFQ1RFRF9ORVRXT1JLLnJwY1VybCk7XG4gICAgY29uc3QgY29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KEVYQU1fTUFOQUdFTUVOVF9BRERSRVNTLCBFWEFNX01BTkFHRU1FTlRfQUJJLCBwcm92aWRlcik7XG5cbiAgICBjb25zdCBleGFtcyA9IGF3YWl0IGNvbnRyYWN0LmdldFN0dWRlbnRFeGFtcyhzdHVkZW50KTtcbiAgICByZXR1cm4gZXhhbXM7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBzdHVkZW50IGV4YW1zOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGVucm9sbFN0dWRlbnQgPSBhc3luYyAoZXhhbUlkOiBzdHJpbmcsIHN0dWRlbnRBZGRyZXNzOiBzdHJpbmcpID0+IHtcbiAgdHJ5IHtcbiAgICBpZiAoIXdpbmRvdy5ldGhlcmV1bSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBldGhlcmV1bSBwcm92aWRlciBmb3VuZCcpO1xuICAgIH1cbiAgICBjb25zdCBwcm92aWRlciA9IG5ldyBldGhlcnMuSnNvblJwY1Byb3ZpZGVyKEVYUEVDVEVEX05FVFdPUksucnBjVXJsKTtcbiAgICBjb25zdCBzaWduZXIgPSBhd2FpdCBwcm92aWRlci5nZXRTaWduZXIoKTtcbiAgICBjb25zdCBjb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoRVhBTV9NQU5BR0VNRU5UX0FERFJFU1MsIEVYQU1fTUFOQUdFTUVOVF9BQkksIHNpZ25lcik7XG5cbiAgICBjb25zdCB0eCA9IGF3YWl0IGNvbnRyYWN0LmVucm9sbFN0dWRlbnQoZXhhbUlkLCBzdHVkZW50QWRkcmVzcyk7XG4gICAgYXdhaXQgdHgud2FpdCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGVucm9sbGluZyBzdHVkZW50OicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTsiXSwibmFtZXMiOlsiZXRoZXJzIiwiRXhhbU1hbmFnZW1lbnRBQkkiLCJnZXRQcm92aWRlciIsImdldFNpZ25lciIsIkVYUEVDVEVEX05FVFdPUksiLCJnZXRBZGRyZXNzIiwiSWRlbnRpdHlBQkkiLCJDZXJ0aWZpY2F0ZXNBQkkiLCJJREVOVElUWV9DT05UUkFDVF9BRERSRVNTIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0lERU5USVRZX0NPTlRSQUNUX0FERFJFU1MiLCJDRVJUSUZJQ0FURVNfQ09OVFJBQ1RfQUREUkVTUyIsIk5FWFRfUFVCTElDX0NFUlRJRklDQVRFU19DT05UUkFDVF9BRERSRVNTIiwiVVNFUl9ST0xFUyIsIk5PTkUiLCJTVFVERU5UIiwiSU5TVElUVVRJT04iLCJFTVBMT1lFUiIsInJvbGVNYXAiLCJjb25zb2xlIiwiZXJyb3IiLCJnZXRDb250cmFjdHMiLCJwcm92aWRlciIsInNpZ25lciIsImlkZW50aXR5Q29udHJhY3QiLCJDb250cmFjdCIsImNlcnRpZmljYXRlc0NvbnRyYWN0IiwiRXJyb3IiLCJtZXNzYWdlIiwicmVnaXN0ZXJVc2VyIiwicm9sZSIsIndpbmRvdyIsImV0aGVyZXVtIiwiQnJvd3NlclByb3ZpZGVyIiwiY29udHJhY3RBZGRyZXNzIiwiY29udHJhY3QiLCJyb2xlVmFsdWUiLCJ0b0xvd2VyQ2FzZSIsInVuZGVmaW5lZCIsInR4Iiwid2FpdCIsInN0YXR1cyIsInZlcmlmeVVzZXIiLCJhZGRyZXNzIiwiZ2V0VXNlclJvbGUiLCJpc3N1ZUNlcnRpZmljYXRlIiwic3R1ZGVudEFkZHJlc3MiLCJpcGZzSGFzaCIsInZlcmlmeUNlcnRpZmljYXRlIiwiY2VydGlmaWNhdGVJZCIsImlzVmFsaWQiLCJnZXRDZXJ0aWZpY2F0ZXMiLCJsb2ciLCJjZXJ0aWZpY2F0ZUlkcyIsImdldFN0dWRlbnRDZXJ0aWZpY2F0ZXMiLCJsZW5ndGgiLCJjZXJ0aWZpY2F0ZXMiLCJQcm9taXNlIiwiYWxsIiwibWFwIiwiaWQiLCJjZXJ0IiwiaXNzdWVyIiwiaW5zdGl0dXRpb24iLCJ0aW1lc3RhbXAiLCJpc3N1ZWRBdCIsInRvU3RyaW5nIiwicmVhc29uIiwiaXNWZXJpZmllZFVzZXIiLCJpc093bmVyIiwib3duZXIiLCJ3YXJuIiwidmVyaWZ5SW5zdGl0dXRpb24iLCJpbnN0aXR1dGlvbkFkZHJlc3MiLCJnZXRPd25lckFkZHJlc3MiLCJFWEFNX01BTkFHRU1FTlRfQUREUkVTUyIsIk5FWFRfUFVCTElDX0VYQU1fTUFOQUdFTUVOVF9BRERSRVNTIiwiRVhBTV9NQU5BR0VNRU5UX0FCSSIsImNyZWF0ZUV4YW0iLCJ0aXRsZSIsImRlc2NyaXB0aW9uIiwiZGF0ZSIsImR1cmF0aW9uIiwiSnNvblJwY1Byb3ZpZGVyIiwicnBjVXJsIiwic3VibWl0RXhhbVJlc3VsdCIsImV4YW1JZCIsInN0dWRlbnQiLCJzY29yZSIsImdyYWRlIiwidXBkYXRlRXhhbVN0YXR1cyIsImdldEV4YW0iLCJleGFtIiwiZ2V0RXhhbVJlc3VsdCIsInJlc3VsdCIsImdldEluc3RpdHV0aW9uRXhhbXMiLCJleGFtcyIsImdldFN0dWRlbnRFeGFtcyIsImVucm9sbFN0dWRlbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./utils/contracts.ts\n"));

/***/ })

});