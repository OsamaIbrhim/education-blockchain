"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./utils/contracts.ts":
/*!****************************!*\
  !*** ./utils/contracts.ts ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createExam: function() { return /* binding */ createExam; },\n/* harmony export */   enrollStudent: function() { return /* binding */ enrollStudent; },\n/* harmony export */   getCertificates: function() { return /* binding */ getCertificates; },\n/* harmony export */   getContracts: function() { return /* binding */ getContracts; },\n/* harmony export */   getExam: function() { return /* binding */ getExam; },\n/* harmony export */   getExamResult: function() { return /* binding */ getExamResult; },\n/* harmony export */   getInstitutionExams: function() { return /* binding */ getInstitutionExams; },\n/* harmony export */   getOwnerAddress: function() { return /* binding */ getOwnerAddress; },\n/* harmony export */   getStudentExams: function() { return /* binding */ getStudentExams; },\n/* harmony export */   getUserRole: function() { return /* binding */ getUserRole; },\n/* harmony export */   isOwner: function() { return /* binding */ isOwner; },\n/* harmony export */   isVerifiedUser: function() { return /* binding */ isVerifiedUser; },\n/* harmony export */   issueCertificate: function() { return /* binding */ issueCertificate; },\n/* harmony export */   registerUser: function() { return /* binding */ registerUser; },\n/* harmony export */   submitExamResult: function() { return /* binding */ submitExamResult; },\n/* harmony export */   updateExamStatus: function() { return /* binding */ updateExamStatus; },\n/* harmony export */   verifyCertificate: function() { return /* binding */ verifyCertificate; },\n/* harmony export */   verifyInstitution: function() { return /* binding */ verifyInstitution; },\n/* harmony export */   verifyUser: function() { return /* binding */ verifyUser; }\n/* harmony export */ });\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ethers */ \"./node_modules/ethers/lib.esm/index.js\");\n/* harmony import */ var _constants_abis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/abis */ \"./constants/abis.ts\");\n/* harmony import */ var _ethersConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ethersConfig */ \"./utils/ethersConfig.ts\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./config */ \"./utils/config.ts\");\n/* harmony import */ var services_examManagement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! services/examManagement */ \"./services/examManagement.ts\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/process/browser.js\");\n\n\n\n\n\n// Contract addresses from .env\nconst IDENTITY_CONTRACT_ADDRESS = \"0x911E250f1398F007704D0F6A527a6a71560a3B93\";\nconst CERTIFICATES_CONTRACT_ADDRESS = \"0xB5Afb0f327F7776Bff1fb9FB257eed8dC2336161\";\nconst EXAM_MANAGEMENT_CONTRACT_ADDRESS = \"0x37458DD5C9E778CF2e149E44f806D8C914bF1CE2\";\n// Role mapping with proper types\nconst USER_ROLES = {\n    NONE: 0,\n    STUDENT: 1,\n    INSTITUTION: 2,\n    EMPLOYER: 3\n};\nconst roleMap = {\n    [USER_ROLES.NONE]: \"none\",\n    [USER_ROLES.STUDENT]: \"student\",\n    [USER_ROLES.INSTITUTION]: \"institution\",\n    [USER_ROLES.EMPLOYER]: \"employer\"\n};\n// Validate environment variables\nif (!IDENTITY_CONTRACT_ADDRESS) {\n    console.error(\"NEXT_PUBLIC_IDENTITY_CONTRACT_ADDRESS is not set in .env\");\n}\nif (!CERTIFICATES_CONTRACT_ADDRESS) {\n    console.error(\"NEXT_PUBLIC_CERTIFICATES_CONTRACT_ADDRESS is not set in .env\");\n}\nconst getContracts = async ()=>{\n    try {\n        const provider = await (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getProvider)();\n        const signer = await (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getSigner)();\n        const identityContract = new ethers__WEBPACK_IMPORTED_MODULE_4__.ethers.Contract(IDENTITY_CONTRACT_ADDRESS, _constants_abis__WEBPACK_IMPORTED_MODULE_0__.IdentityABI, signer);\n        const certificatesContract = new ethers__WEBPACK_IMPORTED_MODULE_4__.ethers.Contract(CERTIFICATES_CONTRACT_ADDRESS, _constants_abis__WEBPACK_IMPORTED_MODULE_0__.CertificatesABI, signer);\n        const examManagementContract = new ethers__WEBPACK_IMPORTED_MODULE_4__.ethers.Contract(EXAM_MANAGEMENT_CONTRACT_ADDRESS, _constants_abis__WEBPACK_IMPORTED_MODULE_0__.ExamManagementABI, signer);\n        return {\n            identityContract,\n            certificatesContract,\n            examManagementContract,\n            provider,\n            signer\n        };\n    } catch (error) {\n        console.error(\"Error initializing contracts:\", error);\n        throw new Error(\"Failed to initialize contracts: \".concat(error.message));\n    }\n};\nconst registerUser = async (role)=>{\n    if (!role) {\n        throw new Error(\"Role is required\");\n    }\n    try {\n        // Error.1 missing revert data  \n        // const provider = await getProvider();\n        // solve error.1\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_4__.ethers.BrowserProvider(window.ethereum);\n        const signer = await provider.getSigner();\n        const identityAddress = (0,_config__WEBPACK_IMPORTED_MODULE_2__.getConfig)(\"IDENTITY_CONTRACT_ADDRESS\");\n        if (!identityAddress) {\n            throw new Error(\"Contract address is not configured\");\n        }\n        const identityContract = new ethers__WEBPACK_IMPORTED_MODULE_4__.ethers.Contract(identityAddress, _constants_abis__WEBPACK_IMPORTED_MODULE_0__.IdentityABI, signer);\n        // Convert role string to enum value\n        const roleMap = {\n            \"student\": 1,\n            \"institution\": 2,\n            \"employer\": 3\n        };\n        const roleValue = roleMap[role.toLowerCase()];\n        if (roleValue === undefined) {\n            throw new Error(\"Invalid role: \".concat(role, \". Must be one of: student, institution, employer\"));\n        }\n        const tx = await identityContract.registerUser(roleValue, \"\" /*, overrides*/ );\n        await tx.wait();\n        return {\n            status: \"success\"\n        };\n    } catch (error) {\n        console.error(\"Registration error:\", error);\n        throw error;\n    }\n};\nconst verifyUser = async (address)=>{\n    if (!address || !(0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getAddress)(address)) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        const { identityContract } = await getContracts();\n        return await identityContract.verifyUser(address);\n    } catch (error) {\n        console.error(\"Error verifying user:\", error);\n        throw new Error(error.message || \"Failed to verify user\");\n    }\n};\nconst getUserRole = async (address)=>{\n    if (!address || !(0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getAddress)(address)) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        const { identityContract } = await getContracts();\n        const roleValue = await identityContract.getUserRole(address);\n        return roleMap[roleValue] || \"none\";\n    } catch (error) {\n        console.error(\"Error getting user role:\", error);\n        return \"none\";\n    }\n};\nconst issueCertificate = async (studentAddress, ipfsHash)=>{\n    if (!studentAddress || !ipfsHash) {\n        throw new Error(\"Student address and IPFS hash are required\");\n    }\n    try {\n        const { certificatesContract } = await getContracts();\n        const tx = await certificatesContract.issueCertificate(studentAddress, ipfsHash);\n        await tx.wait();\n        return tx;\n    } catch (error) {\n        console.error(\"Error issuing certificate:\", error);\n        throw error;\n    }\n};\nconst verifyCertificate = async (certificateId)=>{\n    if (!certificateId) {\n        throw new Error(\"Certificate ID is required\");\n    }\n    try {\n        const { certificatesContract } = await getContracts();\n        const isValid = await certificatesContract.verifyCertificate(certificateId);\n        return isValid;\n    } catch (error) {\n        console.error(\"Error verifying certificate:\", error);\n        throw error;\n    }\n};\nconst getCertificates = async (address)=>{\n    if (!address || !(0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getAddress)(address)) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        console.log(\"Getting certificates for address:\", address);\n        const { certificatesContract } = await getContracts();\n        // Get certificate IDs first\n        console.log(\"Getting certificate IDs...\");\n        const certificateIds = await certificatesContract.getStudentCertificates(address);\n        console.log(\"Certificate IDs:\", certificateIds);\n        if (!certificateIds || certificateIds.length === 0) {\n            console.log(\"No certificates found\");\n            return [];\n        }\n        // Get details for each certificate\n        console.log(\"Getting certificate details...\");\n        const certificates = await Promise.all(certificateIds.map(async (id)=>{\n            const cert = await certificatesContract.verifyCertificate(id);\n            return {\n                id,\n                ipfsHash: cert.ipfsHash,\n                issuer: cert.institution,\n                timestamp: cert.issuedAt.toString(),\n                isValid: cert.isValid\n            };\n        }));\n        console.log(\"Certificate details:\", certificates);\n        return certificates;\n    } catch (error) {\n        console.error(\"Error in getCertificates:\", error);\n        if (error.reason) {\n            throw new Error(\"Contract error: \".concat(error.reason));\n        }\n        throw error;\n    }\n};\nconst isVerifiedUser = async (address)=>{\n    if (!address || !(0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getAddress)(address)) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        const { identityContract } = await getContracts();\n        return await identityContract.isVerifiedUser(address);\n    } catch (error) {\n        console.error(\"Error checking verification status:\", error);\n        throw error;\n    }\n};\n// Admin functions\nconst isOwner = async (address)=>{\n    if (!address || !(0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getAddress)(address)) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        const { identityContract } = await getContracts();\n        const owner = await identityContract.owner();\n        // Add additional checks\n        if (!owner) {\n            console.warn(\"Owner address is null or undefined\");\n            return false;\n        }\n        return owner.toLowerCase() === address.toLowerCase();\n    } catch (error) {\n        console.error(\"Error checking owner status:\", error);\n        throw error;\n    }\n};\nconst verifyInstitution = async (institutionAddress)=>{\n    if (!institutionAddress || !(0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getAddress)(institutionAddress)) {\n        throw new Error(\"Invalid institution address\");\n    }\n    try {\n        const signer = await (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getSigner)();\n        const examManagementContract = await (0,services_examManagement__WEBPACK_IMPORTED_MODULE_3__.getExamManagementContract)();\n        // Connect the contract to the signer before calling write functions\n        const contractWithSigner = examManagementContract.connect(signer);\n        const examManagementTx = await contractWithSigner.verifyInstitution(institutionAddress);\n        await examManagementTx.wait();\n        return {\n            examManagementHash: examManagementTx.hash\n        };\n    } catch (error) {\n        console.error(\"Error verifying institution:\", error);\n        throw error;\n    }\n};\nconst getOwnerAddress = async ()=>{\n    try {\n        const { identityContract } = await getContracts();\n        const owner = await identityContract.owner();\n        return owner;\n    } catch (error) {\n        console.error(\"Error getting owner address:\", error);\n        throw error;\n    }\n};\n// Add exam management contract address and ABI\nconst EXAM_MANAGEMENT_ADDRESS = process.env.NEXT_PUBLIC_EXAM_MANAGEMENT_ADDRESS || \"\";\nconst EXAM_MANAGEMENT_ABI = _constants_abis__WEBPACK_IMPORTED_MODULE_0__.ExamManagementABI;\n// Add exam management functions\nconst createExam = async (id, title, description, date, duration, ipfsHash)=>{\n    try {\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_4__.ethers.JsonRpcProvider(_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl);\n        const signer = await provider.getSigner();\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_4__.ethers.Contract(EXAM_MANAGEMENT_ADDRESS, EXAM_MANAGEMENT_ABI, signer);\n        const tx = await contract.createExam(id, title, description, date, duration, ipfsHash);\n        await tx.wait();\n        return true;\n    } catch (error) {\n        console.error(\"Error creating exam:\", error);\n        throw error;\n    }\n};\nconst submitExamResult = async (examId, student, score, grade, ipfsHash)=>{\n    try {\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_4__.ethers.JsonRpcProvider(_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl);\n        const signer = await provider.getSigner();\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_4__.ethers.Contract(EXAM_MANAGEMENT_ADDRESS, EXAM_MANAGEMENT_ABI, signer);\n        const tx = await contract.submitExamResult(examId, student, score, grade, ipfsHash);\n        await tx.wait();\n        return true;\n    } catch (error) {\n        console.error(\"Error submitting exam result:\", error);\n        throw error;\n    }\n};\nconst updateExamStatus = async (examId, status)=>{\n    try {\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_4__.ethers.JsonRpcProvider(_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl);\n        const signer = await provider.getSigner();\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_4__.ethers.Contract(EXAM_MANAGEMENT_ADDRESS, EXAM_MANAGEMENT_ABI, signer);\n        const tx = await contract.updateExamStatus(examId, status);\n        await tx.wait();\n        return true;\n    } catch (error) {\n        console.error(\"Error updating exam status:\", error);\n        throw error;\n    }\n};\nconst getExam = async (examId)=>{\n    try {\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_4__.ethers.JsonRpcProvider(_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl);\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_4__.ethers.Contract(EXAM_MANAGEMENT_ADDRESS, EXAM_MANAGEMENT_ABI, provider);\n        const exam = await contract.getExam(examId);\n        return exam;\n    } catch (error) {\n        console.error(\"Error getting exam:\", error);\n        throw error;\n    }\n};\nconst getExamResult = async (examId, student)=>{\n    try {\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_4__.ethers.JsonRpcProvider(_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl);\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_4__.ethers.Contract(EXAM_MANAGEMENT_ADDRESS, EXAM_MANAGEMENT_ABI, provider);\n        const result = await contract.getExamResult(examId, student);\n        return result;\n    } catch (error) {\n        console.error(\"Error getting exam result:\", error);\n        throw error;\n    }\n};\nconst getInstitutionExams = async (institution)=>{\n    try {\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_4__.ethers.JsonRpcProvider(_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl);\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_4__.ethers.Contract(EXAM_MANAGEMENT_ADDRESS, EXAM_MANAGEMENT_ABI, provider);\n        const exams = await contract.getInstitutionExams(institution);\n        return exams;\n    } catch (error) {\n        console.error(\"Error getting institution exams:\", error);\n        throw error;\n    }\n};\nconst getStudentExams = async (student)=>{\n    try {\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_4__.ethers.JsonRpcProvider(_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl);\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_4__.ethers.Contract(EXAM_MANAGEMENT_ADDRESS, EXAM_MANAGEMENT_ABI, provider);\n        const exams = await contract.getStudentExams(student);\n        return exams;\n    } catch (error) {\n        console.error(\"Error getting student exams:\", error);\n        throw error;\n    }\n};\nconst enrollStudent = async (examId, studentAddress)=>{\n    try {\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_4__.ethers.JsonRpcProvider(_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl);\n        const signer = await provider.getSigner();\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_4__.ethers.Contract(EXAM_MANAGEMENT_ADDRESS, EXAM_MANAGEMENT_ABI, signer);\n        const tx = await contract.enrollStudent(examId, studentAddress);\n        await tx.wait();\n        return true;\n    } catch (error) {\n        console.error(\"Error enrolling student:\", error);\n        throw error;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QyxPQUFPUztJQUNULEVBQUUsT0FBT2xGLE9BQU87UUFDZEQsUUFBUUMsS0FBSyxDQUFDLGdDQUFnQ0E7UUFDOUMsTUFBTUE7SUFDUjtBQUNGLEVBQUU7QUFFSyxNQUFNb0YsZ0JBQWdCLE9BQU9aLFFBQWdCOUM7SUFDbEQsSUFBSTtRQUNGLElBQUksQ0FBQ2QsT0FBT0MsUUFBUSxFQUFFO1lBQ3BCLE1BQU0sSUFBSUwsTUFBTTtRQUNsQjtRQUNBLE1BQU1OLFdBQVcsSUFBSTNCLDBDQUFNQSxDQUFDNkYsZUFBZSxDQUFDdkYsMkRBQWdCQSxDQUFDd0YsTUFBTTtRQUNuRSxNQUFNbEUsU0FBUyxNQUFNRCxTQUFTdEIsU0FBUztRQUN2QyxNQUFNMEYsV0FBVyxJQUFJL0YsMENBQU1BLENBQUM4QixRQUFRLENBQUN1RCx5QkFBeUJFLHFCQUFxQjNEO1FBRW5GLE1BQU1nQixLQUFLLE1BQU1tRCxTQUFTYyxhQUFhLENBQUNaLFFBQVE5QztRQUNoRCxNQUFNUCxHQUFHQyxJQUFJO1FBQ2IsT0FBTztJQUNULEVBQUUsT0FBT3BCLE9BQU87UUFDZEQsUUFBUUMsS0FBSyxDQUFDLDRCQUE0QkE7UUFDMUMsTUFBTUE7SUFDUjtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vdXRpbHMvY29udHJhY3RzLnRzPzk4NTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXRoZXJzIH0gZnJvbSAnZXRoZXJzJztcclxuaW1wb3J0IHsgRXhhbU1hbmFnZW1lbnRBQkksIElkZW50aXR5QUJJLCBDZXJ0aWZpY2F0ZXNBQkkgfSBmcm9tICcuLi9jb25zdGFudHMvYWJpcyc7XHJcbmltcG9ydCB7XHJcbiAgZ2V0UHJvdmlkZXIsXHJcbiAgZ2V0U2lnbmVyLFxyXG4gIEVYUEVDVEVEX05FVFdPUkssXHJcbiAgdmFsaWRhdGVOZXR3b3JrLFxyXG4gIGZvcm1hdEV0aGVyLFxyXG4gIGhhbmRsZUNvbnRyYWN0RXJyb3IsXHJcbiAgZ2V0QWRkcmVzcyxcclxuICB0eXBlIEV0aGVyZXVtUHJvdmlkZXJcclxufSBmcm9tICcuL2V0aGVyc0NvbmZpZyc7XHJcbmltcG9ydCB7IGdldENvbmZpZyB9IGZyb20gJy4vY29uZmlnJztcclxuaW1wb3J0IHsgZ2V0SWRlbnRpdHlDb250cmFjdCB9IGZyb20gJ3NlcnZpY2VzL2FkbWluJztcclxuaW1wb3J0IHsgZ2V0RXhhbU1hbmFnZW1lbnRDb250cmFjdCB9IGZyb20gJ3NlcnZpY2VzL2V4YW1NYW5hZ2VtZW50JztcclxuXHJcbi8vIENvbnRyYWN0IGFkZHJlc3NlcyBmcm9tIC5lbnZcclxuY29uc3QgSURFTlRJVFlfQ09OVFJBQ1RfQUREUkVTUyA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0lERU5USVRZX0NPTlRSQUNUX0FERFJFU1M7XHJcbmNvbnN0IENFUlRJRklDQVRFU19DT05UUkFDVF9BRERSRVNTID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQ0VSVElGSUNBVEVTX0NPTlRSQUNUX0FERFJFU1M7XHJcbmNvbnN0IEVYQU1fTUFOQUdFTUVOVF9DT05UUkFDVF9BRERSRVNTID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRVhBTV9NQU5BR0VNRU5UX0NPTlRSQUNUX0FERFJFU1M7XHJcblxyXG4vLyBSb2xlIG1hcHBpbmcgd2l0aCBwcm9wZXIgdHlwZXNcclxuY29uc3QgVVNFUl9ST0xFUyA9IHtcclxuICBOT05FOiAwLFxyXG4gIFNUVURFTlQ6IDEsXHJcbiAgSU5TVElUVVRJT046IDIsXHJcbiAgRU1QTE9ZRVI6IDNcclxufSBhcyBjb25zdDtcclxuXHJcbnR5cGUgUm9sZVZhbHVlID0gdHlwZW9mIFVTRVJfUk9MRVNba2V5b2YgdHlwZW9mIFVTRVJfUk9MRVNdO1xyXG50eXBlIFJvbGVTdHJpbmcgPSAnbm9uZScgfCAnc3R1ZGVudCcgfCAnaW5zdGl0dXRpb24nIHwgJ2VtcGxveWVyJztcclxuXHJcbmNvbnN0IHJvbGVNYXA6IFJlY29yZDxSb2xlVmFsdWUsIFJvbGVTdHJpbmc+ID0ge1xyXG4gIFtVU0VSX1JPTEVTLk5PTkVdOiAnbm9uZScsXHJcbiAgW1VTRVJfUk9MRVMuU1RVREVOVF06ICdzdHVkZW50JyxcclxuICBbVVNFUl9ST0xFUy5JTlNUSVRVVElPTl06ICdpbnN0aXR1dGlvbicsXHJcbiAgW1VTRVJfUk9MRVMuRU1QTE9ZRVJdOiAnZW1wbG95ZXInXHJcbn07XHJcblxyXG4vLyBWYWxpZGF0ZSBlbnZpcm9ubWVudCB2YXJpYWJsZXNcclxuaWYgKCFJREVOVElUWV9DT05UUkFDVF9BRERSRVNTKSB7XHJcbiAgY29uc29sZS5lcnJvcignTkVYVF9QVUJMSUNfSURFTlRJVFlfQ09OVFJBQ1RfQUREUkVTUyBpcyBub3Qgc2V0IGluIC5lbnYnKTtcclxufVxyXG5pZiAoIUNFUlRJRklDQVRFU19DT05UUkFDVF9BRERSRVNTKSB7XHJcbiAgY29uc29sZS5lcnJvcignTkVYVF9QVUJMSUNfQ0VSVElGSUNBVEVTX0NPTlRSQUNUX0FERFJFU1MgaXMgbm90IHNldCBpbiAuZW52Jyk7XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBnZXRDb250cmFjdHMgPSBhc3luYyAoKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgZ2V0UHJvdmlkZXIoKTtcclxuICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IGdldFNpZ25lcigpO1xyXG5cclxuICAgIGNvbnN0IGlkZW50aXR5Q29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KFxyXG4gICAgICBJREVOVElUWV9DT05UUkFDVF9BRERSRVNTISxcclxuICAgICAgSWRlbnRpdHlBQkksXHJcbiAgICAgIHNpZ25lclxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCBjZXJ0aWZpY2F0ZXNDb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoXHJcbiAgICAgIENFUlRJRklDQVRFU19DT05UUkFDVF9BRERSRVNTISxcclxuICAgICAgQ2VydGlmaWNhdGVzQUJJLFxyXG4gICAgICBzaWduZXJcclxuICAgICk7XHJcblxyXG4gICAgY29uc3QgZXhhbU1hbmFnZW1lbnRDb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoXHJcbiAgICAgIEVYQU1fTUFOQUdFTUVOVF9DT05UUkFDVF9BRERSRVNTISxcclxuICAgICAgRXhhbU1hbmFnZW1lbnRBQkksXHJcbiAgICAgIHNpZ25lclxyXG4gICAgKTtcclxuXHJcbiAgICByZXR1cm4geyBpZGVudGl0eUNvbnRyYWN0LCBjZXJ0aWZpY2F0ZXNDb250cmFjdCwgZXhhbU1hbmFnZW1lbnRDb250cmFjdCwgcHJvdmlkZXIsIHNpZ25lciB9O1xyXG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluaXRpYWxpemluZyBjb250cmFjdHM6JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gaW5pdGlhbGl6ZSBjb250cmFjdHM6ICR7ZXJyb3IubWVzc2FnZX1gKTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgcmVnaXN0ZXJVc2VyID0gYXN5bmMgKHJvbGU6IHN0cmluZykgPT4ge1xyXG4gIGlmICghcm9sZSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdSb2xlIGlzIHJlcXVpcmVkJyk7XHJcbiAgfVxyXG5cclxuICB0cnkge1xyXG4gICAgLy8gRXJyb3IuMSBtaXNzaW5nIHJldmVydCBkYXRhICBcclxuICAgIC8vIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgZ2V0UHJvdmlkZXIoKTtcclxuXHJcbiAgICAvLyBzb2x2ZSBlcnJvci4xXHJcbiAgICBpZiAoIXdpbmRvdy5ldGhlcmV1bSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGV0aGVyZXVtIHByb3ZpZGVyIGZvdW5kJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwcm92aWRlciA9IG5ldyBldGhlcnMuQnJvd3NlclByb3ZpZGVyKHdpbmRvdy5ldGhlcmV1bSk7XHJcblxyXG4gICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgcHJvdmlkZXIuZ2V0U2lnbmVyKCk7XHJcbiAgICBjb25zdCBpZGVudGl0eUFkZHJlc3MgPSBnZXRDb25maWcoJ0lERU5USVRZX0NPTlRSQUNUX0FERFJFU1MnKTtcclxuXHJcbiAgICBpZiAoIWlkZW50aXR5QWRkcmVzcykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnRyYWN0IGFkZHJlc3MgaXMgbm90IGNvbmZpZ3VyZWQnKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBpZGVudGl0eUNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChpZGVudGl0eUFkZHJlc3MsIElkZW50aXR5QUJJLCBzaWduZXIpO1xyXG5cclxuICAgIC8vIENvbnZlcnQgcm9sZSBzdHJpbmcgdG8gZW51bSB2YWx1ZVxyXG4gICAgY29uc3Qgcm9sZU1hcDogeyBba2V5OiBzdHJpbmddOiBudW1iZXIgfSA9IHtcclxuICAgICAgJ3N0dWRlbnQnOiAxLFxyXG4gICAgICAnaW5zdGl0dXRpb24nOiAyLFxyXG4gICAgICAnZW1wbG95ZXInOiAzXHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IHJvbGVWYWx1ZSA9IHJvbGVNYXBbcm9sZS50b0xvd2VyQ2FzZSgpXTtcclxuICAgIGlmIChyb2xlVmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcm9sZTogJHtyb2xlfS4gTXVzdCBiZSBvbmUgb2Y6IHN0dWRlbnQsIGluc3RpdHV0aW9uLCBlbXBsb3llcmApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHR4ID0gYXdhaXQgaWRlbnRpdHlDb250cmFjdC5yZWdpc3RlclVzZXIocm9sZVZhbHVlLCBcIlwiLyosIG92ZXJyaWRlcyovKTtcclxuICAgIGF3YWl0IHR4LndhaXQoKTtcclxuXHJcbiAgICByZXR1cm4geyBzdGF0dXM6ICdzdWNjZXNzJyB9O1xyXG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ1JlZ2lzdHJhdGlvbiBlcnJvcjonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBlcnJvcjtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgdmVyaWZ5VXNlciA9IGFzeW5jIChhZGRyZXNzOiBzdHJpbmcpID0+IHtcclxuICBpZiAoIWFkZHJlc3MgfHwgIWdldEFkZHJlc3MoYWRkcmVzcykpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhZGRyZXNzJyk7XHJcbiAgfVxyXG5cclxuICB0cnkge1xyXG4gICAgY29uc3QgeyBpZGVudGl0eUNvbnRyYWN0IH0gPSBhd2FpdCBnZXRDb250cmFjdHMoKTtcclxuICAgIHJldHVybiBhd2FpdCBpZGVudGl0eUNvbnRyYWN0LnZlcmlmeVVzZXIoYWRkcmVzcyk7XHJcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgdmVyaWZ5aW5nIHVzZXI6JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGVycm9yLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byB2ZXJpZnkgdXNlcicpO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRVc2VyUm9sZSA9IGFzeW5jIChhZGRyZXNzOiBzdHJpbmcpOiBQcm9taXNlPFJvbGVTdHJpbmc+ID0+IHtcclxuICBpZiAoIWFkZHJlc3MgfHwgIWdldEFkZHJlc3MoYWRkcmVzcykpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhZGRyZXNzJyk7XHJcbiAgfVxyXG5cclxuICB0cnkge1xyXG4gICAgY29uc3QgeyBpZGVudGl0eUNvbnRyYWN0IH0gPSBhd2FpdCBnZXRDb250cmFjdHMoKTtcclxuICAgIGNvbnN0IHJvbGVWYWx1ZSA9IGF3YWl0IGlkZW50aXR5Q29udHJhY3QuZ2V0VXNlclJvbGUoYWRkcmVzcyk7XHJcbiAgICByZXR1cm4gcm9sZU1hcFtyb2xlVmFsdWUgYXMgUm9sZVZhbHVlXSB8fCAnbm9uZSc7XHJcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyB1c2VyIHJvbGU6JywgZXJyb3IpO1xyXG4gICAgcmV0dXJuICdub25lJztcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgaXNzdWVDZXJ0aWZpY2F0ZSA9IGFzeW5jIChzdHVkZW50QWRkcmVzczogc3RyaW5nLCBpcGZzSGFzaDogc3RyaW5nKSA9PiB7XHJcbiAgaWYgKCFzdHVkZW50QWRkcmVzcyB8fCAhaXBmc0hhc2gpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignU3R1ZGVudCBhZGRyZXNzIGFuZCBJUEZTIGhhc2ggYXJlIHJlcXVpcmVkJyk7XHJcbiAgfVxyXG5cclxuICB0cnkge1xyXG4gICAgY29uc3QgeyBjZXJ0aWZpY2F0ZXNDb250cmFjdCB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XHJcbiAgICBjb25zdCB0eCA9IGF3YWl0IGNlcnRpZmljYXRlc0NvbnRyYWN0Lmlzc3VlQ2VydGlmaWNhdGUoc3R1ZGVudEFkZHJlc3MsIGlwZnNIYXNoKTtcclxuICAgIGF3YWl0IHR4LndhaXQoKTtcclxuICAgIHJldHVybiB0eDtcclxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpc3N1aW5nIGNlcnRpZmljYXRlOicsIGVycm9yKTtcclxuICAgIHRocm93IGVycm9yO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCB2ZXJpZnlDZXJ0aWZpY2F0ZSA9IGFzeW5jIChjZXJ0aWZpY2F0ZUlkOiBzdHJpbmcpID0+IHtcclxuICBpZiAoIWNlcnRpZmljYXRlSWQpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignQ2VydGlmaWNhdGUgSUQgaXMgcmVxdWlyZWQnKTtcclxuICB9XHJcblxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB7IGNlcnRpZmljYXRlc0NvbnRyYWN0IH0gPSBhd2FpdCBnZXRDb250cmFjdHMoKTtcclxuICAgIGNvbnN0IGlzVmFsaWQgPSBhd2FpdCBjZXJ0aWZpY2F0ZXNDb250cmFjdC52ZXJpZnlDZXJ0aWZpY2F0ZShjZXJ0aWZpY2F0ZUlkKTtcclxuICAgIHJldHVybiBpc1ZhbGlkO1xyXG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHZlcmlmeWluZyBjZXJ0aWZpY2F0ZTonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBlcnJvcjtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0Q2VydGlmaWNhdGVzID0gYXN5bmMgKGFkZHJlc3M6IHN0cmluZykgPT4ge1xyXG4gIGlmICghYWRkcmVzcyB8fCAhZ2V0QWRkcmVzcyhhZGRyZXNzKSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFkZHJlc3MnKTtcclxuICB9XHJcblxyXG4gIHRyeSB7XHJcbiAgICBjb25zb2xlLmxvZygnR2V0dGluZyBjZXJ0aWZpY2F0ZXMgZm9yIGFkZHJlc3M6JywgYWRkcmVzcyk7XHJcbiAgICBjb25zdCB7IGNlcnRpZmljYXRlc0NvbnRyYWN0IH0gPSBhd2FpdCBnZXRDb250cmFjdHMoKTtcclxuXHJcbiAgICAvLyBHZXQgY2VydGlmaWNhdGUgSURzIGZpcnN0XHJcbiAgICBjb25zb2xlLmxvZygnR2V0dGluZyBjZXJ0aWZpY2F0ZSBJRHMuLi4nKTtcclxuICAgIGNvbnN0IGNlcnRpZmljYXRlSWRzID0gYXdhaXQgY2VydGlmaWNhdGVzQ29udHJhY3QuZ2V0U3R1ZGVudENlcnRpZmljYXRlcyhhZGRyZXNzKTtcclxuICAgIGNvbnNvbGUubG9nKCdDZXJ0aWZpY2F0ZSBJRHM6JywgY2VydGlmaWNhdGVJZHMpO1xyXG5cclxuICAgIGlmICghY2VydGlmaWNhdGVJZHMgfHwgY2VydGlmaWNhdGVJZHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdObyBjZXJ0aWZpY2F0ZXMgZm91bmQnKTtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEdldCBkZXRhaWxzIGZvciBlYWNoIGNlcnRpZmljYXRlXHJcbiAgICBjb25zb2xlLmxvZygnR2V0dGluZyBjZXJ0aWZpY2F0ZSBkZXRhaWxzLi4uJyk7XHJcbiAgICBjb25zdCBjZXJ0aWZpY2F0ZXMgPSBhd2FpdCBQcm9taXNlLmFsbChcclxuICAgICAgY2VydGlmaWNhdGVJZHMubWFwKGFzeW5jIChpZDogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgY29uc3QgY2VydCA9IGF3YWl0IGNlcnRpZmljYXRlc0NvbnRyYWN0LnZlcmlmeUNlcnRpZmljYXRlKGlkKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgaWQsXHJcbiAgICAgICAgICBpcGZzSGFzaDogY2VydC5pcGZzSGFzaCxcclxuICAgICAgICAgIGlzc3VlcjogY2VydC5pbnN0aXR1dGlvbixcclxuICAgICAgICAgIHRpbWVzdGFtcDogY2VydC5pc3N1ZWRBdC50b1N0cmluZygpLFxyXG4gICAgICAgICAgaXNWYWxpZDogY2VydC5pc1ZhbGlkXHJcbiAgICAgICAgfTtcclxuICAgICAgfSlcclxuICAgICk7XHJcblxyXG4gICAgY29uc29sZS5sb2coJ0NlcnRpZmljYXRlIGRldGFpbHM6JywgY2VydGlmaWNhdGVzKTtcclxuICAgIHJldHVybiBjZXJ0aWZpY2F0ZXM7XHJcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gZ2V0Q2VydGlmaWNhdGVzOicsIGVycm9yKTtcclxuICAgIGlmIChlcnJvci5yZWFzb24pIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb250cmFjdCBlcnJvcjogJHtlcnJvci5yZWFzb259YCk7XHJcbiAgICB9XHJcbiAgICB0aHJvdyBlcnJvcjtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgaXNWZXJpZmllZFVzZXIgPSBhc3luYyAoYWRkcmVzczogc3RyaW5nKSA9PiB7XHJcbiAgaWYgKCFhZGRyZXNzIHx8ICFnZXRBZGRyZXNzKGFkZHJlc3MpKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYWRkcmVzcycpO1xyXG4gIH1cclxuXHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHsgaWRlbnRpdHlDb250cmFjdCB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XHJcbiAgICByZXR1cm4gYXdhaXQgaWRlbnRpdHlDb250cmFjdC5pc1ZlcmlmaWVkVXNlcihhZGRyZXNzKTtcclxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyB2ZXJpZmljYXRpb24gc3RhdHVzOicsIGVycm9yKTtcclxuICAgIHRocm93IGVycm9yO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIEFkbWluIGZ1bmN0aW9uc1xyXG5leHBvcnQgY29uc3QgaXNPd25lciA9IGFzeW5jIChhZGRyZXNzOiBzdHJpbmcpID0+IHtcclxuICBpZiAoIWFkZHJlc3MgfHwgIWdldEFkZHJlc3MoYWRkcmVzcykpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhZGRyZXNzJyk7XHJcbiAgfVxyXG5cclxuICB0cnkge1xyXG4gICAgY29uc3QgeyBpZGVudGl0eUNvbnRyYWN0IH0gPSBhd2FpdCBnZXRDb250cmFjdHMoKTtcclxuICAgIGNvbnN0IG93bmVyID0gYXdhaXQgaWRlbnRpdHlDb250cmFjdC5vd25lcigpO1xyXG5cclxuICAgIC8vIEFkZCBhZGRpdGlvbmFsIGNoZWNrc1xyXG4gICAgaWYgKCFvd25lcikge1xyXG4gICAgICBjb25zb2xlLndhcm4oJ093bmVyIGFkZHJlc3MgaXMgbnVsbCBvciB1bmRlZmluZWQnKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvd25lci50b0xvd2VyQ2FzZSgpID09PSBhZGRyZXNzLnRvTG93ZXJDYXNlKCk7XHJcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY2hlY2tpbmcgb3duZXIgc3RhdHVzOicsIGVycm9yKTtcclxuICAgIHRocm93IGVycm9yO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCB2ZXJpZnlJbnN0aXR1dGlvbiA9IGFzeW5jIChpbnN0aXR1dGlvbkFkZHJlc3M6IHN0cmluZykgPT4ge1xyXG4gIGlmICghaW5zdGl0dXRpb25BZGRyZXNzIHx8ICFnZXRBZGRyZXNzKGluc3RpdHV0aW9uQWRkcmVzcykpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnN0aXR1dGlvbiBhZGRyZXNzJyk7XHJcbiAgfVxyXG5cclxuICB0cnkge1xyXG4gICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgZ2V0U2lnbmVyKCk7XHJcbiAgICBjb25zdCBleGFtTWFuYWdlbWVudENvbnRyYWN0ID0gYXdhaXQgZ2V0RXhhbU1hbmFnZW1lbnRDb250cmFjdCgpO1xyXG4gICAgXHJcbiAgICAvLyBDb25uZWN0IHRoZSBjb250cmFjdCB0byB0aGUgc2lnbmVyIGJlZm9yZSBjYWxsaW5nIHdyaXRlIGZ1bmN0aW9uc1xyXG4gICAgY29uc3QgY29udHJhY3RXaXRoU2lnbmVyID0gZXhhbU1hbmFnZW1lbnRDb250cmFjdC5jb25uZWN0KHNpZ25lcik7XHJcbiAgICBcclxuICAgIGNvbnN0IGV4YW1NYW5hZ2VtZW50VHggPSBhd2FpdCBjb250cmFjdFdpdGhTaWduZXIudmVyaWZ5SW5zdGl0dXRpb24oaW5zdGl0dXRpb25BZGRyZXNzKTtcclxuICAgIGF3YWl0IGV4YW1NYW5hZ2VtZW50VHgud2FpdCgpO1xyXG4gICAgXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBleGFtTWFuYWdlbWVudEhhc2g6IGV4YW1NYW5hZ2VtZW50VHguaGFzaFxyXG4gICAgfTtcclxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciB2ZXJpZnlpbmcgaW5zdGl0dXRpb246JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldE93bmVyQWRkcmVzcyA9IGFzeW5jICgpID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgeyBpZGVudGl0eUNvbnRyYWN0IH0gPSBhd2FpdCBnZXRDb250cmFjdHMoKTtcclxuICAgIGNvbnN0IG93bmVyID0gYXdhaXQgaWRlbnRpdHlDb250cmFjdC5vd25lcigpO1xyXG4gICAgcmV0dXJuIG93bmVyO1xyXG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgb3duZXIgYWRkcmVzczonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBlcnJvcjtcclxuICB9XHJcbn07XHJcblxyXG4vLyBBZGQgZXhhbSBtYW5hZ2VtZW50IGNvbnRyYWN0IGFkZHJlc3MgYW5kIEFCSVxyXG5jb25zdCBFWEFNX01BTkFHRU1FTlRfQUREUkVTUyA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0VYQU1fTUFOQUdFTUVOVF9BRERSRVNTIHx8IFwiXCI7XHJcbmNvbnN0IEVYQU1fTUFOQUdFTUVOVF9BQkkgPSBFeGFtTWFuYWdlbWVudEFCSTtcclxuXHJcbi8vIEFkZCBleGFtIG1hbmFnZW1lbnQgZnVuY3Rpb25zXHJcbmV4cG9ydCBjb25zdCBjcmVhdGVFeGFtID0gYXN5bmMgKFxyXG4gIGlkOiBzdHJpbmcsXHJcbiAgdGl0bGU6IHN0cmluZyxcclxuICBkZXNjcmlwdGlvbjogc3RyaW5nLFxyXG4gIGRhdGU6IG51bWJlcixcclxuICBkdXJhdGlvbjogbnVtYmVyLFxyXG4gIGlwZnNIYXNoOiBzdHJpbmdcclxuKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGlmICghd2luZG93LmV0aGVyZXVtKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZXRoZXJldW0gcHJvdmlkZXIgZm91bmQnKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IGV0aGVycy5Kc29uUnBjUHJvdmlkZXIoRVhQRUNURURfTkVUV09SSy5ycGNVcmwpO1xyXG4gICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgcHJvdmlkZXIuZ2V0U2lnbmVyKCk7XHJcbiAgICBjb25zdCBjb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoRVhBTV9NQU5BR0VNRU5UX0FERFJFU1MsIEVYQU1fTUFOQUdFTUVOVF9BQkksIHNpZ25lcik7XHJcblxyXG4gICAgY29uc3QgdHggPSBhd2FpdCBjb250cmFjdC5jcmVhdGVFeGFtKGlkLCB0aXRsZSwgZGVzY3JpcHRpb24sIGRhdGUsIGR1cmF0aW9uLCBpcGZzSGFzaCk7XHJcbiAgICBhd2FpdCB0eC53YWl0KCk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgZXhhbTonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBlcnJvcjtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3Qgc3VibWl0RXhhbVJlc3VsdCA9IGFzeW5jIChcclxuICBleGFtSWQ6IHN0cmluZyxcclxuICBzdHVkZW50OiBzdHJpbmcsXHJcbiAgc2NvcmU6IG51bWJlcixcclxuICBncmFkZTogc3RyaW5nLFxyXG4gIGlwZnNIYXNoOiBzdHJpbmdcclxuKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGlmICghd2luZG93LmV0aGVyZXVtKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZXRoZXJldW0gcHJvdmlkZXIgZm91bmQnKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IGV0aGVycy5Kc29uUnBjUHJvdmlkZXIoRVhQRUNURURfTkVUV09SSy5ycGNVcmwpO1xyXG4gICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgcHJvdmlkZXIuZ2V0U2lnbmVyKCk7XHJcbiAgICBjb25zdCBjb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoRVhBTV9NQU5BR0VNRU5UX0FERFJFU1MsIEVYQU1fTUFOQUdFTUVOVF9BQkksIHNpZ25lcik7XHJcblxyXG4gICAgY29uc3QgdHggPSBhd2FpdCBjb250cmFjdC5zdWJtaXRFeGFtUmVzdWx0KGV4YW1JZCwgc3R1ZGVudCwgc2NvcmUsIGdyYWRlLCBpcGZzSGFzaCk7XHJcbiAgICBhd2FpdCB0eC53YWl0KCk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3Igc3VibWl0dGluZyBleGFtIHJlc3VsdDonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBlcnJvcjtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgdXBkYXRlRXhhbVN0YXR1cyA9IGFzeW5jIChleGFtSWQ6IHN0cmluZywgc3RhdHVzOiBzdHJpbmcpID0+IHtcclxuICB0cnkge1xyXG4gICAgaWYgKCF3aW5kb3cuZXRoZXJldW0pIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBldGhlcmV1bSBwcm92aWRlciBmb3VuZCcpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgZXRoZXJzLkpzb25ScGNQcm92aWRlcihFWFBFQ1RFRF9ORVRXT1JLLnJwY1VybCk7XHJcbiAgICBjb25zdCBzaWduZXIgPSBhd2FpdCBwcm92aWRlci5nZXRTaWduZXIoKTtcclxuICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChFWEFNX01BTkFHRU1FTlRfQUREUkVTUywgRVhBTV9NQU5BR0VNRU5UX0FCSSwgc2lnbmVyKTtcclxuXHJcbiAgICBjb25zdCB0eCA9IGF3YWl0IGNvbnRyYWN0LnVwZGF0ZUV4YW1TdGF0dXMoZXhhbUlkLCBzdGF0dXMpO1xyXG4gICAgYXdhaXQgdHgud2FpdCgpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIGV4YW0gc3RhdHVzOicsIGVycm9yKTtcclxuICAgIHRocm93IGVycm9yO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRFeGFtID0gYXN5bmMgKGV4YW1JZDogc3RyaW5nKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGlmICghd2luZG93LmV0aGVyZXVtKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZXRoZXJldW0gcHJvdmlkZXIgZm91bmQnKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IGV0aGVycy5Kc29uUnBjUHJvdmlkZXIoRVhQRUNURURfTkVUV09SSy5ycGNVcmwpO1xyXG4gICAgY29uc3QgY29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KEVYQU1fTUFOQUdFTUVOVF9BRERSRVNTLCBFWEFNX01BTkFHRU1FTlRfQUJJLCBwcm92aWRlcik7XHJcblxyXG4gICAgY29uc3QgZXhhbSA9IGF3YWl0IGNvbnRyYWN0LmdldEV4YW0oZXhhbUlkKTtcclxuICAgIHJldHVybiBleGFtO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIGV4YW06JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldEV4YW1SZXN1bHQgPSBhc3luYyAoZXhhbUlkOiBzdHJpbmcsIHN0dWRlbnQ6IHN0cmluZykgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBpZiAoIXdpbmRvdy5ldGhlcmV1bSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGV0aGVyZXVtIHByb3ZpZGVyIGZvdW5kJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwcm92aWRlciA9IG5ldyBldGhlcnMuSnNvblJwY1Byb3ZpZGVyKEVYUEVDVEVEX05FVFdPUksucnBjVXJsKTtcclxuICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChFWEFNX01BTkFHRU1FTlRfQUREUkVTUywgRVhBTV9NQU5BR0VNRU5UX0FCSSwgcHJvdmlkZXIpO1xyXG5cclxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbnRyYWN0LmdldEV4YW1SZXN1bHQoZXhhbUlkLCBzdHVkZW50KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgZXhhbSByZXN1bHQ6JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldEluc3RpdHV0aW9uRXhhbXMgPSBhc3luYyAoaW5zdGl0dXRpb246IHN0cmluZykgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBpZiAoIXdpbmRvdy5ldGhlcmV1bSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGV0aGVyZXVtIHByb3ZpZGVyIGZvdW5kJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwcm92aWRlciA9IG5ldyBldGhlcnMuSnNvblJwY1Byb3ZpZGVyKEVYUEVDVEVEX05FVFdPUksucnBjVXJsKTtcclxuICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChFWEFNX01BTkFHRU1FTlRfQUREUkVTUywgRVhBTV9NQU5BR0VNRU5UX0FCSSwgcHJvdmlkZXIpO1xyXG5cclxuICAgIGNvbnN0IGV4YW1zID0gYXdhaXQgY29udHJhY3QuZ2V0SW5zdGl0dXRpb25FeGFtcyhpbnN0aXR1dGlvbik7XHJcbiAgICByZXR1cm4gZXhhbXM7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgaW5zdGl0dXRpb24gZXhhbXM6JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldFN0dWRlbnRFeGFtcyA9IGFzeW5jIChzdHVkZW50OiBzdHJpbmcpID0+IHtcclxuICB0cnkge1xyXG4gICAgaWYgKCF3aW5kb3cuZXRoZXJldW0pIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBldGhlcmV1bSBwcm92aWRlciBmb3VuZCcpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgZXRoZXJzLkpzb25ScGNQcm92aWRlcihFWFBFQ1RFRF9ORVRXT1JLLnJwY1VybCk7XHJcbiAgICBjb25zdCBjb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoRVhBTV9NQU5BR0VNRU5UX0FERFJFU1MsIEVYQU1fTUFOQUdFTUVOVF9BQkksIHByb3ZpZGVyKTtcclxuXHJcbiAgICBjb25zdCBleGFtcyA9IGF3YWl0IGNvbnRyYWN0LmdldFN0dWRlbnRFeGFtcyhzdHVkZW50KTtcclxuICAgIHJldHVybiBleGFtcztcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBzdHVkZW50IGV4YW1zOicsIGVycm9yKTtcclxuICAgIHRocm93IGVycm9yO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBlbnJvbGxTdHVkZW50ID0gYXN5bmMgKGV4YW1JZDogc3RyaW5nLCBzdHVkZW50QWRkcmVzczogc3RyaW5nKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGlmICghd2luZG93LmV0aGVyZXVtKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZXRoZXJldW0gcHJvdmlkZXIgZm91bmQnKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IGV0aGVycy5Kc29uUnBjUHJvdmlkZXIoRVhQRUNURURfTkVUV09SSy5ycGNVcmwpO1xyXG4gICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgcHJvdmlkZXIuZ2V0U2lnbmVyKCk7XHJcbiAgICBjb25zdCBjb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoRVhBTV9NQU5BR0VNRU5UX0FERFJFU1MsIEVYQU1fTUFOQUdFTUVOVF9BQkksIHNpZ25lcik7XHJcblxyXG4gICAgY29uc3QgdHggPSBhd2FpdCBjb250cmFjdC5lbnJvbGxTdHVkZW50KGV4YW1JZCwgc3R1ZGVudEFkZHJlc3MpO1xyXG4gICAgYXdhaXQgdHgud2FpdCgpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGVucm9sbGluZyBzdHVkZW50OicsIGVycm9yKTtcclxuICAgIHRocm93IGVycm9yO1xyXG4gIH1cclxufTsiXSwibmFtZXMiOlsiZXRoZXJzIiwiRXhhbU1hbmFnZW1lbnRBQkkiLCJJZGVudGl0eUFCSSIsIkNlcnRpZmljYXRlc0FCSSIsImdldFByb3ZpZGVyIiwiZ2V0U2lnbmVyIiwiRVhQRUNURURfTkVUV09SSyIsImdldEFkZHJlc3MiLCJnZXRDb25maWciLCJnZXRFeGFtTWFuYWdlbWVudENvbnRyYWN0IiwiSURFTlRJVFlfQ09OVFJBQ1RfQUREUkVTUyIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19JREVOVElUWV9DT05UUkFDVF9BRERSRVNTIiwiQ0VSVElGSUNBVEVTX0NPTlRSQUNUX0FERFJFU1MiLCJORVhUX1BVQkxJQ19DRVJUSUZJQ0FURVNfQ09OVFJBQ1RfQUREUkVTUyIsIkVYQU1fTUFOQUdFTUVOVF9DT05UUkFDVF9BRERSRVNTIiwiTkVYVF9QVUJMSUNfRVhBTV9NQU5BR0VNRU5UX0NPTlRSQUNUX0FERFJFU1MiLCJVU0VSX1JPTEVTIiwiTk9ORSIsIlNUVURFTlQiLCJJTlNUSVRVVElPTiIsIkVNUExPWUVSIiwicm9sZU1hcCIsImNvbnNvbGUiLCJlcnJvciIsImdldENvbnRyYWN0cyIsInByb3ZpZGVyIiwic2lnbmVyIiwiaWRlbnRpdHlDb250cmFjdCIsIkNvbnRyYWN0IiwiY2VydGlmaWNhdGVzQ29udHJhY3QiLCJleGFtTWFuYWdlbWVudENvbnRyYWN0IiwiRXJyb3IiLCJtZXNzYWdlIiwicmVnaXN0ZXJVc2VyIiwicm9sZSIsIndpbmRvdyIsImV0aGVyZXVtIiwiQnJvd3NlclByb3ZpZGVyIiwiaWRlbnRpdHlBZGRyZXNzIiwicm9sZVZhbHVlIiwidG9Mb3dlckNhc2UiLCJ1bmRlZmluZWQiLCJ0eCIsIndhaXQiLCJzdGF0dXMiLCJ2ZXJpZnlVc2VyIiwiYWRkcmVzcyIsImdldFVzZXJSb2xlIiwiaXNzdWVDZXJ0aWZpY2F0ZSIsInN0dWRlbnRBZGRyZXNzIiwiaXBmc0hhc2giLCJ2ZXJpZnlDZXJ0aWZpY2F0ZSIsImNlcnRpZmljYXRlSWQiLCJpc1ZhbGlkIiwiZ2V0Q2VydGlmaWNhdGVzIiwibG9nIiwiY2VydGlmaWNhdGVJZHMiLCJnZXRTdHVkZW50Q2VydGlmaWNhdGVzIiwibGVuZ3RoIiwiY2VydGlmaWNhdGVzIiwiUHJvbWlzZSIsImFsbCIsIm1hcCIsImlkIiwiY2VydCIsImlzc3VlciIsImluc3RpdHV0aW9uIiwidGltZXN0YW1wIiwiaXNzdWVkQXQiLCJ0b1N0cmluZyIsInJlYXNvbiIsImlzVmVyaWZpZWRVc2VyIiwiaXNPd25lciIsIm93bmVyIiwid2FybiIsInZlcmlmeUluc3RpdHV0aW9uIiwiaW5zdGl0dXRpb25BZGRyZXNzIiwiY29udHJhY3RXaXRoU2lnbmVyIiwiY29ubmVjdCIsImV4YW1NYW5hZ2VtZW50VHgiLCJleGFtTWFuYWdlbWVudEhhc2giLCJoYXNoIiwiZ2V0T3duZXJBZGRyZXNzIiwiRVhBTV9NQU5BR0VNRU5UX0FERFJFU1MiLCJORVhUX1BVQkxJQ19FWEFNX01BTkFHRU1FTlRfQUREUkVTUyIsIkVYQU1fTUFOQUdFTUVOVF9BQkkiLCJjcmVhdGVFeGFtIiwidGl0bGUiLCJkZXNjcmlwdGlvbiIsImRhdGUiLCJkdXJhdGlvbiIsIkpzb25ScGNQcm92aWRlciIsInJwY1VybCIsImNvbnRyYWN0Iiwic3VibWl0RXhhbVJlc3VsdCIsImV4YW1JZCIsInN0dWRlbnQiLCJzY29yZSIsImdyYWRlIiwidXBkYXRlRXhhbVN0YXR1cyIsImdldEV4YW0iLCJleGFtIiwiZ2V0RXhhbVJlc3VsdCIsInJlc3VsdCIsImdldEluc3RpdHV0aW9uRXhhbXMiLCJleGFtcyIsImdldFN0dWRlbnRFeGFtcyIsImVucm9sbFN0dWRlbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./utils/contracts.ts\n"));

/***/ })

});