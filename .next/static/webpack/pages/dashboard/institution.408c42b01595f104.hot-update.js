"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/dashboard/institution",{

/***/ "./utils/config.ts":
/*!*************************!*\
  !*** ./utils/config.ts ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CONFIG: function() { return /* binding */ CONFIG; },\n/* harmony export */   getConfig: function() { return /* binding */ getConfig; },\n/* harmony export */   validateConfig: function() { return /* binding */ validateConfig; }\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/process/browser.js\");\n// تكوين ثابت للنظام\nconst CONFIG = {\n    ADMIN_ADDRESS: \"0x2C84aE14df11a456a8aE48793a3C5989Bf9D5ab4\",\n    NETWORK_URL: \"http://127.0.0.1:7545\",\n    CHAIN_ID: \"1337\",\n    SECURITY_UTILS_CONTRACT_ADDRESS: \"0xCaACAB1FA696347532070E8c82B4CBa4dc4Dc21b\",\n    IDENTITY_CONTRACT_ADDRESS: \"0xbEBcD3099b6766b4224f0624887616E099E4dCb4\",\n    CERTIFICATES_CONTRACT_ADDRESS: \"0x82Ba41429a7ff6e503707c4E62b8073A39d6C98d\",\n    EXAMINATIONS_CONTRACT_ADDRESS: \"0x1E3cc1831e2910A1C25b49AA47977Ba3aac629Ec\",\n    EXAM_MANAGEMENT_CONTRACT_ADDRESS: \"0xA82719824037C6e51eED8616d96F874E4fa19B91\"\n};\n// وظيفة للحصول على قيمة التكوين\nconst getConfig = (key)=>{\n    // محاولة الحصول على القيمة من متغيرات البيئة أولاً\n    const envValue = process.env[\"NEXT_PUBLIC_\".concat(key)] || process.env[key];\n    // إذا لم يتم العثور على القيمة في متغيرات البيئة، استخدم القيمة الثابتة\n    return envValue || CONFIG[key];\n};\n// وظيفة للتحقق من صحة التكوين\nconst validateConfig = ()=>{\n    const missingKeys = [];\n    Object.keys(CONFIG).forEach((key)=>{\n        const value = getConfig(key);\n        if (!value) {\n            missingKeys.push(key);\n        }\n    });\n    if (missingKeys.length > 0) {\n        throw new Error(\"Missing configuration values for: \".concat(missingKeys.join(\", \")));\n    }\n    return true;\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi91dGlscy9jb25maWcudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLG9CQUFvQjtBQUNiLE1BQU1BLFNBQVM7SUFDcEJDLGVBQWU7SUFDZkMsYUFBYTtJQUNiQyxVQUFVO0lBQ1ZDLGlDQUFpQztJQUNqQ0MsMkJBQTJCO0lBQzNCQywrQkFBK0I7SUFDL0JDLCtCQUErQjtJQUMvQkMsa0NBQWtDO0FBQ3BDLEVBQUU7QUFFRixnQ0FBZ0M7QUFDekIsTUFBTUMsWUFBWSxDQUFDQztJQUN4QixtREFBbUQ7SUFDbkQsTUFBTUMsV0FBV0MsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDLGVBQW1CLE9BQUpILEtBQU0sSUFBSUUsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDSCxJQUFJO0lBRXRFLHdFQUF3RTtJQUN4RSxPQUFPQyxZQUFZWCxNQUFNLENBQUNVLElBQUk7QUFDaEMsRUFBRTtBQUVGLDhCQUE4QjtBQUN2QixNQUFNSSxpQkFBaUI7SUFDNUIsTUFBTUMsY0FBd0IsRUFBRTtJQUVoQ0MsT0FBT0MsSUFBSSxDQUFDakIsUUFBUWtCLE9BQU8sQ0FBQyxDQUFDUjtRQUMzQixNQUFNUyxRQUFRVixVQUFVQztRQUN4QixJQUFJLENBQUNTLE9BQU87WUFDVkosWUFBWUssSUFBSSxDQUFDVjtRQUNuQjtJQUNGO0lBRUEsSUFBSUssWUFBWU0sTUFBTSxHQUFHLEdBQUc7UUFDMUIsTUFBTSxJQUFJQyxNQUFNLHFDQUE0RCxPQUF2QlAsWUFBWVEsSUFBSSxDQUFDO0lBQ3hFO0lBRUEsT0FBTztBQUNULEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vdXRpbHMvY29uZmlnLnRzPzBiMWMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8g2KrZg9mI2YrZhiDYq9in2KjYqiDZhNmE2YbYuNin2YVcbmV4cG9ydCBjb25zdCBDT05GSUcgPSB7XG4gIEFETUlOX0FERFJFU1M6ICcweDJDODRhRTE0ZGYxMWE0NTZhOGFFNDg3OTNhM0M1OTg5QmY5RDVhYjQnLFxuICBORVRXT1JLX1VSTDogJ2h0dHA6Ly8xMjcuMC4wLjE6NzU0NScsXG4gIENIQUlOX0lEOiAnMTMzNycsXG4gIFNFQ1VSSVRZX1VUSUxTX0NPTlRSQUNUX0FERFJFU1M6ICcweENhQUNBQjFGQTY5NjM0NzUzMjA3MEU4YzgyQjRDQmE0ZGM0RGMyMWInLFxuICBJREVOVElUWV9DT05UUkFDVF9BRERSRVNTOiAnMHhiRUJjRDMwOTliNjc2NmI0MjI0ZjA2MjQ4ODc2MTZFMDk5RTRkQ2I0JyxcbiAgQ0VSVElGSUNBVEVTX0NPTlRSQUNUX0FERFJFU1M6ICcweDgyQmE0MTQyOWE3ZmY2ZTUwMzcwN2M0RTYyYjgwNzNBMzlkNkM5OGQnLFxuICBFWEFNSU5BVElPTlNfQ09OVFJBQ1RfQUREUkVTUzogJzB4MUUzY2MxODMxZTI5MTBBMUMyNWI0OUFBNDc5NzdCYTNhYWM2MjlFYycsXG4gIEVYQU1fTUFOQUdFTUVOVF9DT05UUkFDVF9BRERSRVNTOiAnMHhBODI3MTk4MjQwMzdDNmU1MWVFRDg2MTZkOTZGODc0RTRmYTE5QjkxJ1xufTtcblxuLy8g2YjYuNmK2YHYqSDZhNmE2K3YtdmI2YQg2LnZhNmJINmC2YrZhdipINin2YTYqtmD2YjZitmGXG5leHBvcnQgY29uc3QgZ2V0Q29uZmlnID0gKGtleToga2V5b2YgdHlwZW9mIENPTkZJRyk6IHN0cmluZyA9PiB7XG4gIC8vINmF2K3Yp9mI2YTYqSDYp9mE2K3YtdmI2YQg2LnZhNmJINin2YTZgtmK2YXYqSDZhdmGINmF2KrYutmK2LHYp9iqINin2YTYqNmK2KbYqSDYo9mI2YTYp9mLXG4gIGNvbnN0IGVudlZhbHVlID0gcHJvY2Vzcy5lbnZbYE5FWFRfUFVCTElDXyR7a2V5fWBdIHx8IHByb2Nlc3MuZW52W2tleV07XG4gIFxuICAvLyDYpdiw2Kcg2YTZhSDZitiq2YUg2KfZhNi52KvZiNixINi52YTZiSDYp9mE2YLZitmF2Kkg2YHZiiDZhdiq2LrZitix2KfYqiDYp9mE2KjZitim2KnYjCDYp9iz2KrYrtiv2YUg2KfZhNmC2YrZhdipINin2YTYq9in2KjYqtipXG4gIHJldHVybiBlbnZWYWx1ZSB8fCBDT05GSUdba2V5XTtcbn07XG5cbi8vINmI2LjZitmB2Kkg2YTZhNiq2K3ZgtmCINmF2YYg2LXYrdipINin2YTYqtmD2YjZitmGXG5leHBvcnQgY29uc3QgdmFsaWRhdGVDb25maWcgPSAoKSA9PiB7XG4gIGNvbnN0IG1pc3NpbmdLZXlzOiBzdHJpbmdbXSA9IFtdO1xuICBcbiAgT2JqZWN0LmtleXMoQ09ORklHKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IGdldENvbmZpZyhrZXkgYXMga2V5b2YgdHlwZW9mIENPTkZJRyk7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgbWlzc2luZ0tleXMucHVzaChrZXkpO1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKG1pc3NpbmdLZXlzLmxlbmd0aCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgY29uZmlndXJhdGlvbiB2YWx1ZXMgZm9yOiAke21pc3NpbmdLZXlzLmpvaW4oJywgJyl9YCk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07ICJdLCJuYW1lcyI6WyJDT05GSUciLCJBRE1JTl9BRERSRVNTIiwiTkVUV09SS19VUkwiLCJDSEFJTl9JRCIsIlNFQ1VSSVRZX1VUSUxTX0NPTlRSQUNUX0FERFJFU1MiLCJJREVOVElUWV9DT05UUkFDVF9BRERSRVNTIiwiQ0VSVElGSUNBVEVTX0NPTlRSQUNUX0FERFJFU1MiLCJFWEFNSU5BVElPTlNfQ09OVFJBQ1RfQUREUkVTUyIsIkVYQU1fTUFOQUdFTUVOVF9DT05UUkFDVF9BRERSRVNTIiwiZ2V0Q29uZmlnIiwia2V5IiwiZW52VmFsdWUiLCJwcm9jZXNzIiwiZW52IiwidmFsaWRhdGVDb25maWciLCJtaXNzaW5nS2V5cyIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwidmFsdWUiLCJwdXNoIiwibGVuZ3RoIiwiRXJyb3IiLCJqb2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./utils/config.ts\n"));

/***/ }),

/***/ "./utils/contracts.ts":
/*!****************************!*\
  !*** ./utils/contracts.ts ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createExam: function() { return /* binding */ createExam; },\n/* harmony export */   enrollStudent: function() { return /* binding */ enrollStudent; },\n/* harmony export */   getCertificates: function() { return /* binding */ getCertificates; },\n/* harmony export */   getContract: function() { return /* binding */ getContract; },\n/* harmony export */   getContracts: function() { return /* binding */ getContracts; },\n/* harmony export */   getExam: function() { return /* binding */ getExam; },\n/* harmony export */   getExamResult: function() { return /* binding */ getExamResult; },\n/* harmony export */   getInstitutionExams: function() { return /* binding */ getInstitutionExams; },\n/* harmony export */   getOwnerAddress: function() { return /* binding */ getOwnerAddress; },\n/* harmony export */   getStudentExams: function() { return /* binding */ getStudentExams; },\n/* harmony export */   getUserRole: function() { return /* binding */ getUserRole; },\n/* harmony export */   isOwner: function() { return /* binding */ isOwner; },\n/* harmony export */   isVerifiedUser: function() { return /* binding */ isVerifiedUser; },\n/* harmony export */   issueCertificate: function() { return /* binding */ issueCertificate; },\n/* harmony export */   registerUser: function() { return /* binding */ registerUser; },\n/* harmony export */   setAdminRole: function() { return /* binding */ setAdminRole; },\n/* harmony export */   submitExamResult: function() { return /* binding */ submitExamResult; },\n/* harmony export */   updateExamStatus: function() { return /* binding */ updateExamStatus; },\n/* harmony export */   validateEnv: function() { return /* binding */ validateEnv; },\n/* harmony export */   verifyCertificate: function() { return /* binding */ verifyCertificate; },\n/* harmony export */   verifyInstitution: function() { return /* binding */ verifyInstitution; },\n/* harmony export */   verifyUser: function() { return /* binding */ verifyUser; }\n/* harmony export */ });\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"./node_modules/.pnpm/ethers@6.13.5_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/ethers/lib.esm/index.js\");\n/* harmony import */ var _constants_abis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/abis */ \"./constants/abis.ts\");\n/* harmony import */ var _ethersConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ethersConfig */ \"./utils/ethersConfig.ts\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./config */ \"./utils/config.ts\");\n\n\n\n\n// Contract ABIs\nconst IdentityABI = [\n    \"function registerUser(uint8 _role, string memory _ipfsHash) external\",\n    \"function verifyUser(address _userAddress) external\",\n    \"function getUserRole(address _userAddress) external view returns (uint8)\",\n    \"function isVerifiedUser(address _userAddress) external view returns (bool)\",\n    \"function updateUserIPFS(string memory _newIpfsHash) external\",\n    \"function owner() external view returns (address)\",\n    \"function isAdmin(address _address) external view returns (bool)\",\n    \"function addAdmin(address _newAdmin) external\",\n    \"function removeAdmin(address _admin) external\"\n];\nconst CertificatesABI = [\n    \"function issueCertificate(address _studentAddress, string memory _ipfsHash) external returns (bytes32)\",\n    \"function getStudentCertificates(address _student) external view returns (bytes32[])\",\n    \"function verifyCertificate(bytes32 _certificateId) external view returns (address student, address institution, string ipfsHash, uint256 issuedAt, bool isValid)\"\n];\n// Contract addresses from config\nconst IDENTITY_CONTRACT_ADDRESS = (0,_config__WEBPACK_IMPORTED_MODULE_2__.getConfig)(\"IDENTITY_CONTRACT_ADDRESS\");\nconst CERTIFICATES_CONTRACT_ADDRESS = (0,_config__WEBPACK_IMPORTED_MODULE_2__.getConfig)(\"CERTIFICATES_CONTRACT_ADDRESS\");\nconst ADMIN_ADDRESS = (0,_config__WEBPACK_IMPORTED_MODULE_2__.getConfig)(\"ADMIN_ADDRESS\");\nconst EXAM_MANAGEMENT_ADDRESS = (0,_config__WEBPACK_IMPORTED_MODULE_2__.getConfig)(\"EXAM_MANAGEMENT_CONTRACT_ADDRESS\");\n// Validate environment variables\nconst validateEnv = ()=>{\n    try {\n        // التحقق من صحة التكوين\n        (0,_config__WEBPACK_IMPORTED_MODULE_2__.validateConfig)();\n        // التحقق من صحة العناوين\n        if (!(0,ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress)(IDENTITY_CONTRACT_ADDRESS)) {\n            throw new Error(\"Invalid Identity contract address: \".concat(IDENTITY_CONTRACT_ADDRESS));\n        }\n        if (!(0,ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress)(CERTIFICATES_CONTRACT_ADDRESS)) {\n            throw new Error(\"Invalid Certificates contract address: \".concat(CERTIFICATES_CONTRACT_ADDRESS));\n        }\n        if (!(0,ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress)(ADMIN_ADDRESS)) {\n            throw new Error(\"Invalid Admin address: \".concat(ADMIN_ADDRESS));\n        }\n        if (!(0,ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress)(EXAM_MANAGEMENT_ADDRESS)) {\n            throw new Error(\"Invalid Exam Management contract address: \".concat(EXAM_MANAGEMENT_ADDRESS));\n        }\n        console.log(\"Configuration validated successfully:\", {\n            IDENTITY_CONTRACT_ADDRESS,\n            CERTIFICATES_CONTRACT_ADDRESS,\n            ADMIN_ADDRESS,\n            EXAM_MANAGEMENT_ADDRESS,\n            CHAIN_ID: (0,_config__WEBPACK_IMPORTED_MODULE_2__.getConfig)(\"CHAIN_ID\"),\n            NETWORK_URL: (0,_config__WEBPACK_IMPORTED_MODULE_2__.getConfig)(\"NETWORK_URL\")\n        });\n        return true;\n    } catch (error) {\n        console.error(\"Configuration validation failed:\", error);\n        throw error;\n    }\n};\n// Debug environment variables\nconsole.log(\"Environment variables check:\", {\n    IDENTITY_CONTRACT_ADDRESS,\n    CERTIFICATES_CONTRACT_ADDRESS,\n    ADMIN_ADDRESS,\n    EXAM_MANAGEMENT_ADDRESS,\n    CHAIN_ID: _ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.chainId,\n    NETWORK_URL: _ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl\n});\n// Role mapping with proper types\nconst USER_ROLES = {\n    NONE: 0,\n    STUDENT: 1,\n    INSTITUTION: 2,\n    EMPLOYER: 3,\n    ADMIN: 4\n};\nconst roleMap = {\n    [USER_ROLES.NONE]: \"none\",\n    [USER_ROLES.STUDENT]: \"student\",\n    [USER_ROLES.INSTITUTION]: \"institution\",\n    [USER_ROLES.EMPLOYER]: \"employer\",\n    [USER_ROLES.ADMIN]: \"admin\"\n};\nconst getContracts = async ()=>{\n    try {\n        console.log(\"Contract Addresses:\", {\n            Identity: IDENTITY_CONTRACT_ADDRESS,\n            Certificates: CERTIFICATES_CONTRACT_ADDRESS,\n            Admin: ADMIN_ADDRESS\n        });\n        const provider = await (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getProvider)();\n        await (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.validateNetwork)(provider);\n        console.log(\"Network validation passed\");\n        const signer = await (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getSigner)();\n        const userAddress = await signer.getAddress();\n        console.log(\"Connected with address:\", userAddress);\n        const userBalance = await provider.getBalance(userAddress);\n        console.log(\"User balance:\", (0,ethers__WEBPACK_IMPORTED_MODULE_3__.formatUnits)(userBalance, \"ether\"), \"ETH\");\n        const identityContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.Contract(IDENTITY_CONTRACT_ADDRESS, IdentityABI, signer);\n        console.log(\"Verifying contract exists at address:\", IDENTITY_CONTRACT_ADDRESS);\n        const code = await provider.getCode(IDENTITY_CONTRACT_ADDRESS);\n        console.log(\"Contract code length:\", code.length);\n        console.log(\"Contract exists:\", code !== \"0x\");\n        if (code === \"0x\") {\n            throw new Error(\"Identity contract not found at address: \".concat(IDENTITY_CONTRACT_ADDRESS));\n        }\n        const certificatesContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.Contract(CERTIFICATES_CONTRACT_ADDRESS, CertificatesABI, signer);\n        const examManagementContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.Contract(EXAM_MANAGEMENT_ADDRESS, _constants_abis__WEBPACK_IMPORTED_MODULE_0__.EXAM_MANAGEMENT_ABI, signer);\n        return {\n            identityContract,\n            certificatesContract,\n            examManagementContract,\n            provider,\n            signer\n        };\n    } catch (error) {\n        console.error(\"Error initializing contracts:\", error);\n        console.error(\"Error details:\", {\n            message: error.message,\n            code: error.code,\n            reason: error.reason\n        });\n        throw new Error(\"Failed to initialize contracts: \".concat(error.message));\n    }\n};\nconst registerUser = async (role)=>{\n    if (!role) {\n        throw new Error(\"Role is required\");\n    }\n    try {\n        const { identityContract, signer } = await getContracts();\n        // Get network details and user address\n        const userAddress = await signer.getAddress();\n        console.log(\"Registering address:\", userAddress);\n        console.log(\"With role:\", role);\n        // Special handling for admin address\n        if (ADMIN_ADDRESS && userAddress.toLowerCase() === ADMIN_ADDRESS.toLowerCase()) {\n            console.log(\"This is the admin address, setting admin role...\");\n            return await setAdminRole();\n        }\n        // Convert role string to enum value\n        const roleMap = {\n            \"student\": USER_ROLES.STUDENT,\n            \"institution\": USER_ROLES.INSTITUTION,\n            \"employer\": USER_ROLES.EMPLOYER,\n            \"admin\": USER_ROLES.ADMIN\n        };\n        const roleValue = roleMap[role.toLowerCase()];\n        if (roleValue === undefined) {\n            throw new Error(\"Invalid role: \".concat(role, \". Must be one of: student, institution, employer, admin\"));\n        }\n        console.log(\"Role value from mapping:\", roleValue);\n        // Check if user is already registered\n        try {\n            console.log(\"Checking if user already exists...\");\n            const existingRole = await identityContract.getUserRole(userAddress);\n            console.log(\"Existing role:\", existingRole);\n            if (existingRole > 0) {\n                console.log(\"User already registered with role:\", existingRole);\n                // If user exists but needs verification\n                const isVerified = await identityContract.isVerified(userAddress);\n                if (!isVerified) {\n                    console.log(\"User exists but not verified, attempting verification...\");\n                    const verifyTx = await identityContract.verifyUser(userAddress);\n                    await verifyTx.wait();\n                    console.log(\"User verified successfully\");\n                }\n                return {\n                    status: \"existing\",\n                    role: existingRole\n                };\n            }\n        } catch (error) {\n            if (!error.message.includes(\"User does not exist\")) {\n                throw error;\n            }\n            console.log(\"User does not exist, proceeding with registration\");\n        }\n        // Register user\n        console.log(\"Registering new user with role:\", roleValue);\n        const tx = await identityContract.registerUser(roleValue, \"\");\n        console.log(\"Registration transaction sent:\", tx.hash);\n        const receipt = await tx.wait();\n        console.log(\"Registration successful:\", receipt.hash);\n        // Verify the user automatically\n        try {\n            console.log(\"Attempting automatic verification...\");\n            const verifyTx = await identityContract.verifyUser(userAddress);\n            await verifyTx.wait();\n            console.log(\"User verified successfully\");\n        } catch (verifyError) {\n            console.warn(\"Automatic verification failed:\", verifyError);\n        // Continue even if verification fails\n        }\n        // If registering as admin, set admin role\n        if (role.toLowerCase() === \"admin\") {\n            console.log(\"Setting admin privileges...\");\n            await setAdminRole();\n        }\n        return {\n            status: \"success\",\n            role: roleValue,\n            transaction: tx\n        };\n    } catch (error) {\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst verifyUser = async (address)=>{\n    try {\n        (0,ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress)(address); // Using getAddress instead of isAddress\n    } catch (error) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        console.log(\"Verifying user:\", address);\n        const { identityContract } = await getContracts();\n        const isVerified = await identityContract.isVerified(address);\n        console.log(\"User verification status:\", isVerified);\n        return isVerified;\n    } catch (error) {\n        console.error(\"Error in verifyUser:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst getUserRole = async (address)=>{\n    try {\n        (0,ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress)(address);\n    } catch (error) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        console.log(\"Getting user role for:\", address);\n        const { identityContract } = await getContracts();\n        const role = await identityContract.getUserRole(address);\n        console.log(\"User role:\", role);\n        return role;\n    } catch (error) {\n        console.error(\"Error in getUserRole:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst issueCertificate = async (studentAddress, ipfsHash)=>{\n    if (!studentAddress || !ipfsHash) {\n        throw new Error(\"Student address and IPFS hash are required\");\n    }\n    try {\n        const { certificatesContract } = await getContracts();\n        const tx = await certificatesContract.issueCertificate(studentAddress, ipfsHash);\n        await tx.wait();\n        return tx;\n    } catch (error) {\n        console.error(\"Error issuing certificate:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst verifyCertificate = async (certificateId)=>{\n    if (!certificateId) {\n        throw new Error(\"Certificate ID is required\");\n    }\n    try {\n        const { certificatesContract } = await getContracts();\n        const isValid = await certificatesContract.verifyCertificate(certificateId);\n        return isValid;\n    } catch (error) {\n        console.error(\"Error verifying certificate:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst getCertificates = async (address)=>{\n    try {\n        (0,ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress)(address);\n    } catch (error) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        console.log(\"Getting certificates for:\", address);\n        const { certificatesContract } = await getContracts();\n        const certificates = await certificatesContract.getCertificates(address);\n        console.log(\"Certificates:\", certificates);\n        return certificates;\n    } catch (error) {\n        console.error(\"Error in getCertificates:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst isVerifiedUser = async (address)=>{\n    try {\n        (0,ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress)(address);\n    } catch (error) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        console.log(\"Checking if user is verified:\", address);\n        const { identityContract } = await getContracts();\n        const isVerified = await identityContract.isVerified(address);\n        console.log(\"User verification status:\", isVerified);\n        return isVerified;\n    } catch (error) {\n        console.error(\"Error in isVerifiedUser:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst isOwner = async (address)=>{\n    try {\n        (0,ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress)(address);\n    } catch (error) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        console.log(\"Checking if user is owner:\", address);\n        const { identityContract } = await getContracts();\n        const ownerAddress = await identityContract.owner();\n        const isOwnerRole = address.toLowerCase() === ownerAddress.toLowerCase();\n        console.log(\"User owner status:\", isOwnerRole);\n        return isOwnerRole;\n    } catch (error) {\n        console.error(\"Error in isOwner:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst verifyInstitution = async (institutionAddress)=>{\n    try {\n        (0,ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress)(institutionAddress);\n    } catch (error) {\n        throw new Error(\"Invalid institution address\");\n    }\n    try {\n        console.log(\"Verifying institution:\", institutionAddress);\n        const { identityContract } = await getContracts();\n        const tx = await identityContract.verifyUser(institutionAddress);\n        await tx.wait();\n        console.log(\"Institution verified successfully\");\n        return true;\n    } catch (error) {\n        console.error(\"Error in verifyInstitution:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst getOwnerAddress = async ()=>{\n    try {\n        const { identityContract } = await getContracts();\n        const owner = await identityContract.owner();\n        return owner;\n    } catch (error) {\n        console.error(\"Error getting owner address:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\n// Add exam management functions\nconst createExam = async (id, title, description, date, duration, ipfsHash)=>{\n    try {\n        const { examManagementContract } = await getContracts();\n        const tx = await examManagementContract.createExam(id, title, description, date, duration, ipfsHash);\n        await tx.wait();\n        return true;\n    } catch (error) {\n        console.error(\"Error creating exam:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst submitExamResult = async (examId, student, score, grade, ipfsHash)=>{\n    try {\n        const { examManagementContract } = await getContracts();\n        const tx = await examManagementContract.submitExamResult(examId, student, score, grade, ipfsHash);\n        await tx.wait();\n        return true;\n    } catch (error) {\n        console.error(\"Error submitting exam result:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst updateExamStatus = async (examId, status)=>{\n    try {\n        const { examManagementContract } = await getContracts();\n        const tx = await examManagementContract.updateExamStatus(examId, status);\n        await tx.wait();\n        return true;\n    } catch (error) {\n        console.error(\"Error updating exam status:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst getExam = async (examId)=>{\n    try {\n        const { examManagementContract } = await getContracts();\n        const exam = await examManagementContract.getExam(examId);\n        return exam;\n    } catch (error) {\n        console.error(\"Error getting exam:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst getExamResult = async (examId, student)=>{\n    try {\n        const { examManagementContract } = await getContracts();\n        const result = await examManagementContract.getExamResult(examId, student);\n        return result;\n    } catch (error) {\n        console.error(\"Error getting exam result:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst getInstitutionExams = async (institution)=>{\n    try {\n        const { examManagementContract } = await getContracts();\n        const exams = await examManagementContract.getInstitutionExams(institution);\n        return exams;\n    } catch (error) {\n        console.error(\"Error getting institution exams:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst getStudentExams = async (student)=>{\n    try {\n        const { examManagementContract } = await getContracts();\n        const exams = await examManagementContract.getStudentExams(student);\n        return exams;\n    } catch (error) {\n        console.error(\"Error getting student exams:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst enrollStudent = async (examId, studentAddress)=>{\n    try {\n        const { examManagementContract } = await getContracts();\n        const tx = await examManagementContract.enrollStudent(examId, studentAddress);\n        await tx.wait();\n        return true;\n    } catch (error) {\n        console.error(\"Error enrolling student:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst getContract = async ()=>{\n    const { examManagementContract } = await getContracts();\n    return examManagementContract;\n};\nconst setAdminRole = async ()=>{\n    try {\n        const { identityContract, signer } = await getContracts();\n        const userAddress = await signer.getAddress();\n        console.log(\"Setting admin role for address:\", userAddress);\n        console.log(\"Expected admin address:\", ADMIN_ADDRESS);\n        // First check if the address is already an admin\n        const isAdmin = await identityContract.isAdmin(userAddress);\n        console.log(\"Is already admin?\", isAdmin);\n        if (isAdmin) {\n            console.log(\"User is already an admin\");\n            return {\n                status: \"existing\",\n                isAdmin: true\n            };\n        }\n        // Check if this is the configured admin address\n        if (ADMIN_ADDRESS && userAddress.toLowerCase() === ADMIN_ADDRESS.toLowerCase()) {\n            console.log(\"Address matches configured admin, adding as admin...\");\n            // First try to register as admin if not already registered\n            try {\n                const role = await identityContract.getUserRole(userAddress);\n                if (role === 0) {\n                    console.log(\"Registering admin user first...\");\n                    const regTx = await identityContract.registerUser(USER_ROLES.ADMIN, \"\");\n                    await regTx.wait();\n                }\n            } catch (error) {\n                if (!error.message.includes(\"User does not exist\")) {\n                    throw error;\n                }\n                // If user doesn't exist, register them as admin\n                console.log(\"Registering new admin user...\");\n                const regTx = await identityContract.registerUser(USER_ROLES.ADMIN, \"\");\n                await regTx.wait();\n            }\n            // Verify the user\n            console.log(\"Verifying admin user...\");\n            const verifyTx = await identityContract.verifyUser(userAddress);\n            await verifyTx.wait();\n            // Add admin role\n            console.log(\"Adding admin role...\");\n            const tx = await identityContract.addAdmin(userAddress);\n            await tx.wait();\n            console.log(\"Successfully added as admin\");\n            return {\n                status: \"success\",\n                isAdmin: true\n            };\n        }\n        throw new Error(\"Only configured admin addresses can be set as admin\");\n    } catch (error) {\n        console.error(\"Error setting admin role:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QjtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vdXRpbHMvY29udHJhY3RzLnRzPzk4NTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgXG4gIENvbnRyYWN0LFxuICBmb3JtYXRVbml0cyxcbiAgZ2V0QWRkcmVzc1xufSBmcm9tICdldGhlcnMnO1xuaW1wb3J0IHsgRVhBTV9NQU5BR0VNRU5UX0FCSSB9IGZyb20gJy4uL2NvbnN0YW50cy9hYmlzJztcbmltcG9ydCB7IFxuICBnZXRQcm92aWRlciwgXG4gIGdldFNpZ25lciwgXG4gIEVYUEVDVEVEX05FVFdPUkssIFxuICB2YWxpZGF0ZU5ldHdvcmssXG4gIGZvcm1hdEV0aGVyLFxuICBoYW5kbGVDb250cmFjdEVycm9yXG59IGZyb20gJy4vZXRoZXJzQ29uZmlnJztcbmltcG9ydCB0eXBlIHsgRXRoZXJldW1Qcm92aWRlciB9IGZyb20gJy4vZXRoZXJzQ29uZmlnJztcbmltcG9ydCB7IGdldENvbmZpZywgdmFsaWRhdGVDb25maWcgfSBmcm9tICcuL2NvbmZpZyc7XG5cbi8vIENvbnRyYWN0IEFCSXNcbmNvbnN0IElkZW50aXR5QUJJID0gW1xuICBcImZ1bmN0aW9uIHJlZ2lzdGVyVXNlcih1aW50OCBfcm9sZSwgc3RyaW5nIG1lbW9yeSBfaXBmc0hhc2gpIGV4dGVybmFsXCIsXG4gIFwiZnVuY3Rpb24gdmVyaWZ5VXNlcihhZGRyZXNzIF91c2VyQWRkcmVzcykgZXh0ZXJuYWxcIixcbiAgXCJmdW5jdGlvbiBnZXRVc2VyUm9sZShhZGRyZXNzIF91c2VyQWRkcmVzcykgZXh0ZXJuYWwgdmlldyByZXR1cm5zICh1aW50OClcIixcbiAgXCJmdW5jdGlvbiBpc1ZlcmlmaWVkVXNlcihhZGRyZXNzIF91c2VyQWRkcmVzcykgZXh0ZXJuYWwgdmlldyByZXR1cm5zIChib29sKVwiLFxuICBcImZ1bmN0aW9uIHVwZGF0ZVVzZXJJUEZTKHN0cmluZyBtZW1vcnkgX25ld0lwZnNIYXNoKSBleHRlcm5hbFwiLFxuICBcImZ1bmN0aW9uIG93bmVyKCkgZXh0ZXJuYWwgdmlldyByZXR1cm5zIChhZGRyZXNzKVwiLFxuICBcImZ1bmN0aW9uIGlzQWRtaW4oYWRkcmVzcyBfYWRkcmVzcykgZXh0ZXJuYWwgdmlldyByZXR1cm5zIChib29sKVwiLFxuICBcImZ1bmN0aW9uIGFkZEFkbWluKGFkZHJlc3MgX25ld0FkbWluKSBleHRlcm5hbFwiLFxuICBcImZ1bmN0aW9uIHJlbW92ZUFkbWluKGFkZHJlc3MgX2FkbWluKSBleHRlcm5hbFwiXG5dO1xuXG5jb25zdCBDZXJ0aWZpY2F0ZXNBQkkgPSBbXG4gIFwiZnVuY3Rpb24gaXNzdWVDZXJ0aWZpY2F0ZShhZGRyZXNzIF9zdHVkZW50QWRkcmVzcywgc3RyaW5nIG1lbW9yeSBfaXBmc0hhc2gpIGV4dGVybmFsIHJldHVybnMgKGJ5dGVzMzIpXCIsXG4gIFwiZnVuY3Rpb24gZ2V0U3R1ZGVudENlcnRpZmljYXRlcyhhZGRyZXNzIF9zdHVkZW50KSBleHRlcm5hbCB2aWV3IHJldHVybnMgKGJ5dGVzMzJbXSlcIixcbiAgXCJmdW5jdGlvbiB2ZXJpZnlDZXJ0aWZpY2F0ZShieXRlczMyIF9jZXJ0aWZpY2F0ZUlkKSBleHRlcm5hbCB2aWV3IHJldHVybnMgKGFkZHJlc3Mgc3R1ZGVudCwgYWRkcmVzcyBpbnN0aXR1dGlvbiwgc3RyaW5nIGlwZnNIYXNoLCB1aW50MjU2IGlzc3VlZEF0LCBib29sIGlzVmFsaWQpXCJcbl07XG5cbi8vIENvbnRyYWN0IGFkZHJlc3NlcyBmcm9tIGNvbmZpZ1xuY29uc3QgSURFTlRJVFlfQ09OVFJBQ1RfQUREUkVTUyA9IGdldENvbmZpZygnSURFTlRJVFlfQ09OVFJBQ1RfQUREUkVTUycpO1xuY29uc3QgQ0VSVElGSUNBVEVTX0NPTlRSQUNUX0FERFJFU1MgPSBnZXRDb25maWcoJ0NFUlRJRklDQVRFU19DT05UUkFDVF9BRERSRVNTJyk7XG5jb25zdCBBRE1JTl9BRERSRVNTID0gZ2V0Q29uZmlnKCdBRE1JTl9BRERSRVNTJyk7XG5jb25zdCBFWEFNX01BTkFHRU1FTlRfQUREUkVTUyA9IGdldENvbmZpZygnRVhBTV9NQU5BR0VNRU5UX0NPTlRSQUNUX0FERFJFU1MnKTtcblxuLy8gVmFsaWRhdGUgZW52aXJvbm1lbnQgdmFyaWFibGVzXG5leHBvcnQgY29uc3QgdmFsaWRhdGVFbnYgPSAoKSA9PiB7XG4gIHRyeSB7XG4gICAgLy8g2KfZhNiq2K3ZgtmCINmF2YYg2LXYrdipINin2YTYqtmD2YjZitmGXG4gICAgdmFsaWRhdGVDb25maWcoKTtcblxuICAgIC8vINin2YTYqtit2YLZgiDZhdmGINi12K3YqSDYp9mE2LnZhtin2YjZitmGXG4gICAgaWYgKCFnZXRBZGRyZXNzKElERU5USVRZX0NPTlRSQUNUX0FERFJFU1MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgSWRlbnRpdHkgY29udHJhY3QgYWRkcmVzczogJHtJREVOVElUWV9DT05UUkFDVF9BRERSRVNTfWApO1xuICAgIH1cblxuICAgIGlmICghZ2V0QWRkcmVzcyhDRVJUSUZJQ0FURVNfQ09OVFJBQ1RfQUREUkVTUykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBDZXJ0aWZpY2F0ZXMgY29udHJhY3QgYWRkcmVzczogJHtDRVJUSUZJQ0FURVNfQ09OVFJBQ1RfQUREUkVTU31gKTtcbiAgICB9XG5cbiAgICBpZiAoIWdldEFkZHJlc3MoQURNSU5fQUREUkVTUykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBBZG1pbiBhZGRyZXNzOiAke0FETUlOX0FERFJFU1N9YCk7XG4gICAgfVxuXG4gICAgaWYgKCFnZXRBZGRyZXNzKEVYQU1fTUFOQUdFTUVOVF9BRERSRVNTKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEV4YW0gTWFuYWdlbWVudCBjb250cmFjdCBhZGRyZXNzOiAke0VYQU1fTUFOQUdFTUVOVF9BRERSRVNTfWApO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCdDb25maWd1cmF0aW9uIHZhbGlkYXRlZCBzdWNjZXNzZnVsbHk6Jywge1xuICAgICAgSURFTlRJVFlfQ09OVFJBQ1RfQUREUkVTUyxcbiAgICAgIENFUlRJRklDQVRFU19DT05UUkFDVF9BRERSRVNTLFxuICAgICAgQURNSU5fQUREUkVTUyxcbiAgICAgIEVYQU1fTUFOQUdFTUVOVF9BRERSRVNTLFxuICAgICAgQ0hBSU5fSUQ6IGdldENvbmZpZygnQ0hBSU5fSUQnKSxcbiAgICAgIE5FVFdPUktfVVJMOiBnZXRDb25maWcoJ05FVFdPUktfVVJMJylcbiAgICB9KTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0NvbmZpZ3VyYXRpb24gdmFsaWRhdGlvbiBmYWlsZWQ6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG4vLyBEZWJ1ZyBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbmNvbnNvbGUubG9nKCdFbnZpcm9ubWVudCB2YXJpYWJsZXMgY2hlY2s6Jywge1xuICBJREVOVElUWV9DT05UUkFDVF9BRERSRVNTLFxuICBDRVJUSUZJQ0FURVNfQ09OVFJBQ1RfQUREUkVTUyxcbiAgQURNSU5fQUREUkVTUyxcbiAgRVhBTV9NQU5BR0VNRU5UX0FERFJFU1MsXG4gIENIQUlOX0lEOiBFWFBFQ1RFRF9ORVRXT1JLLmNoYWluSWQsXG4gIE5FVFdPUktfVVJMOiBFWFBFQ1RFRF9ORVRXT1JLLnJwY1VybFxufSk7XG5cbi8vIFJvbGUgbWFwcGluZyB3aXRoIHByb3BlciB0eXBlc1xuY29uc3QgVVNFUl9ST0xFUyA9IHtcbiAgTk9ORTogMCxcbiAgU1RVREVOVDogMSxcbiAgSU5TVElUVVRJT046IDIsXG4gIEVNUExPWUVSOiAzLFxuICBBRE1JTjogNFxufSBhcyBjb25zdDtcblxudHlwZSBSb2xlVmFsdWUgPSB0eXBlb2YgVVNFUl9ST0xFU1trZXlvZiB0eXBlb2YgVVNFUl9ST0xFU107XG50eXBlIFJvbGVTdHJpbmcgPSAnbm9uZScgfCAnc3R1ZGVudCcgfCAnaW5zdGl0dXRpb24nIHwgJ2VtcGxveWVyJyB8ICdhZG1pbic7XG5cbmNvbnN0IHJvbGVNYXA6IFJlY29yZDxSb2xlVmFsdWUsIFJvbGVTdHJpbmc+ID0ge1xuICBbVVNFUl9ST0xFUy5OT05FXTogJ25vbmUnLFxuICBbVVNFUl9ST0xFUy5TVFVERU5UXTogJ3N0dWRlbnQnLFxuICBbVVNFUl9ST0xFUy5JTlNUSVRVVElPTl06ICdpbnN0aXR1dGlvbicsXG4gIFtVU0VSX1JPTEVTLkVNUExPWUVSXTogJ2VtcGxveWVyJyxcbiAgW1VTRVJfUk9MRVMuQURNSU5dOiAnYWRtaW4nXG59O1xuXG5leHBvcnQgY29uc3QgZ2V0Q29udHJhY3RzID0gYXN5bmMgKCkgPT4ge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCdDb250cmFjdCBBZGRyZXNzZXM6Jywge1xuICAgICAgSWRlbnRpdHk6IElERU5USVRZX0NPTlRSQUNUX0FERFJFU1MsXG4gICAgICBDZXJ0aWZpY2F0ZXM6IENFUlRJRklDQVRFU19DT05UUkFDVF9BRERSRVNTLFxuICAgICAgQWRtaW46IEFETUlOX0FERFJFU1NcbiAgICB9KTtcblxuICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgZ2V0UHJvdmlkZXIoKTtcbiAgICBhd2FpdCB2YWxpZGF0ZU5ldHdvcmsocHJvdmlkZXIpO1xuICAgIGNvbnNvbGUubG9nKCdOZXR3b3JrIHZhbGlkYXRpb24gcGFzc2VkJyk7XG4gICAgXG4gICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgZ2V0U2lnbmVyKCk7XG4gICAgY29uc3QgdXNlckFkZHJlc3MgPSBhd2FpdCBzaWduZXIuZ2V0QWRkcmVzcygpO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKCdDb25uZWN0ZWQgd2l0aCBhZGRyZXNzOicsIHVzZXJBZGRyZXNzKTtcbiAgICBcbiAgICBjb25zdCB1c2VyQmFsYW5jZSA9IGF3YWl0IHByb3ZpZGVyLmdldEJhbGFuY2UodXNlckFkZHJlc3MpO1xuICAgIGNvbnNvbGUubG9nKCdVc2VyIGJhbGFuY2U6JywgZm9ybWF0VW5pdHModXNlckJhbGFuY2UsICdldGhlcicpLCAnRVRIJyk7XG4gICAgXG4gICAgY29uc3QgaWRlbnRpdHlDb250cmFjdCA9IG5ldyBDb250cmFjdChcbiAgICAgIElERU5USVRZX0NPTlRSQUNUX0FERFJFU1MhLFxuICAgICAgSWRlbnRpdHlBQkksXG4gICAgICBzaWduZXJcbiAgICApO1xuXG4gICAgY29uc29sZS5sb2coJ1ZlcmlmeWluZyBjb250cmFjdCBleGlzdHMgYXQgYWRkcmVzczonLCBJREVOVElUWV9DT05UUkFDVF9BRERSRVNTKTtcbiAgICBjb25zdCBjb2RlID0gYXdhaXQgcHJvdmlkZXIuZ2V0Q29kZShJREVOVElUWV9DT05UUkFDVF9BRERSRVNTISk7XG4gICAgY29uc29sZS5sb2coJ0NvbnRyYWN0IGNvZGUgbGVuZ3RoOicsIGNvZGUubGVuZ3RoKTtcbiAgICBjb25zb2xlLmxvZygnQ29udHJhY3QgZXhpc3RzOicsIGNvZGUgIT09ICcweCcpO1xuICAgIFxuICAgIGlmIChjb2RlID09PSAnMHgnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYElkZW50aXR5IGNvbnRyYWN0IG5vdCBmb3VuZCBhdCBhZGRyZXNzOiAke0lERU5USVRZX0NPTlRSQUNUX0FERFJFU1N9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgY2VydGlmaWNhdGVzQ29udHJhY3QgPSBuZXcgQ29udHJhY3QoXG4gICAgICBDRVJUSUZJQ0FURVNfQ09OVFJBQ1RfQUREUkVTUyEsXG4gICAgICBDZXJ0aWZpY2F0ZXNBQkksXG4gICAgICBzaWduZXJcbiAgICApO1xuXG4gICAgY29uc3QgZXhhbU1hbmFnZW1lbnRDb250cmFjdCA9IG5ldyBDb250cmFjdChcbiAgICAgIEVYQU1fTUFOQUdFTUVOVF9BRERSRVNTISxcbiAgICAgIEVYQU1fTUFOQUdFTUVOVF9BQkksXG4gICAgICBzaWduZXJcbiAgICApO1xuXG4gICAgcmV0dXJuIHsgaWRlbnRpdHlDb250cmFjdCwgY2VydGlmaWNhdGVzQ29udHJhY3QsIGV4YW1NYW5hZ2VtZW50Q29udHJhY3QsIHByb3ZpZGVyLCBzaWduZXIgfTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluaXRpYWxpemluZyBjb250cmFjdHM6JywgZXJyb3IpO1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRldGFpbHM6Jywge1xuICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgIGNvZGU6IGVycm9yLmNvZGUsXG4gICAgICByZWFzb246IGVycm9yLnJlYXNvblxuICAgIH0pO1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGluaXRpYWxpemUgY29udHJhY3RzOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCByZWdpc3RlclVzZXIgPSBhc3luYyAocm9sZTogc3RyaW5nKSA9PiB7XG4gIGlmICghcm9sZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUm9sZSBpcyByZXF1aXJlZCcpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCB7IGlkZW50aXR5Q29udHJhY3QsIHNpZ25lciB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XG4gICAgXG4gICAgLy8gR2V0IG5ldHdvcmsgZGV0YWlscyBhbmQgdXNlciBhZGRyZXNzXG4gICAgY29uc3QgdXNlckFkZHJlc3MgPSBhd2FpdCBzaWduZXIuZ2V0QWRkcmVzcygpO1xuICAgIGNvbnNvbGUubG9nKCdSZWdpc3RlcmluZyBhZGRyZXNzOicsIHVzZXJBZGRyZXNzKTtcbiAgICBjb25zb2xlLmxvZygnV2l0aCByb2xlOicsIHJvbGUpO1xuICAgIFxuICAgIC8vIFNwZWNpYWwgaGFuZGxpbmcgZm9yIGFkbWluIGFkZHJlc3NcbiAgICBpZiAoQURNSU5fQUREUkVTUyAmJiB1c2VyQWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSBBRE1JTl9BRERSRVNTLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdUaGlzIGlzIHRoZSBhZG1pbiBhZGRyZXNzLCBzZXR0aW5nIGFkbWluIHJvbGUuLi4nKTtcbiAgICAgIHJldHVybiBhd2FpdCBzZXRBZG1pblJvbGUoKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ29udmVydCByb2xlIHN0cmluZyB0byBlbnVtIHZhbHVlXG4gICAgY29uc3Qgcm9sZU1hcDogeyBba2V5OiBzdHJpbmddOiBudW1iZXIgfSA9IHtcbiAgICAgICdzdHVkZW50JzogVVNFUl9ST0xFUy5TVFVERU5ULFxuICAgICAgJ2luc3RpdHV0aW9uJzogVVNFUl9ST0xFUy5JTlNUSVRVVElPTixcbiAgICAgICdlbXBsb3llcic6IFVTRVJfUk9MRVMuRU1QTE9ZRVIsXG4gICAgICAnYWRtaW4nOiBVU0VSX1JPTEVTLkFETUlOXG4gICAgfTtcbiAgICBcbiAgICBjb25zdCByb2xlVmFsdWUgPSByb2xlTWFwW3JvbGUudG9Mb3dlckNhc2UoKV07XG4gICAgaWYgKHJvbGVWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcm9sZTogJHtyb2xlfS4gTXVzdCBiZSBvbmUgb2Y6IHN0dWRlbnQsIGluc3RpdHV0aW9uLCBlbXBsb3llciwgYWRtaW5gKTtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygnUm9sZSB2YWx1ZSBmcm9tIG1hcHBpbmc6Jywgcm9sZVZhbHVlKTtcbiAgICBcbiAgICAvLyBDaGVjayBpZiB1c2VyIGlzIGFscmVhZHkgcmVnaXN0ZXJlZFxuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygnQ2hlY2tpbmcgaWYgdXNlciBhbHJlYWR5IGV4aXN0cy4uLicpO1xuICAgICAgY29uc3QgZXhpc3RpbmdSb2xlID0gYXdhaXQgaWRlbnRpdHlDb250cmFjdC5nZXRVc2VyUm9sZSh1c2VyQWRkcmVzcyk7XG4gICAgICBjb25zb2xlLmxvZygnRXhpc3Rpbmcgcm9sZTonLCBleGlzdGluZ1JvbGUpO1xuICAgICAgXG4gICAgICBpZiAoZXhpc3RpbmdSb2xlID4gMCkge1xuICAgICAgICBjb25zb2xlLmxvZygnVXNlciBhbHJlYWR5IHJlZ2lzdGVyZWQgd2l0aCByb2xlOicsIGV4aXN0aW5nUm9sZSk7XG4gICAgICAgIFxuICAgICAgICAvLyBJZiB1c2VyIGV4aXN0cyBidXQgbmVlZHMgdmVyaWZpY2F0aW9uXG4gICAgICAgIGNvbnN0IGlzVmVyaWZpZWQgPSBhd2FpdCBpZGVudGl0eUNvbnRyYWN0LmlzVmVyaWZpZWQodXNlckFkZHJlc3MpO1xuICAgICAgICBpZiAoIWlzVmVyaWZpZWQpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnVXNlciBleGlzdHMgYnV0IG5vdCB2ZXJpZmllZCwgYXR0ZW1wdGluZyB2ZXJpZmljYXRpb24uLi4nKTtcbiAgICAgICAgICBjb25zdCB2ZXJpZnlUeCA9IGF3YWl0IGlkZW50aXR5Q29udHJhY3QudmVyaWZ5VXNlcih1c2VyQWRkcmVzcyk7XG4gICAgICAgICAgYXdhaXQgdmVyaWZ5VHgud2FpdCgpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdVc2VyIHZlcmlmaWVkIHN1Y2Nlc3NmdWxseScpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4geyBzdGF0dXM6ICdleGlzdGluZycsIHJvbGU6IGV4aXN0aW5nUm9sZSB9O1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGlmICghZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnVXNlciBkb2VzIG5vdCBleGlzdCcpKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgY29uc29sZS5sb2coJ1VzZXIgZG9lcyBub3QgZXhpc3QsIHByb2NlZWRpbmcgd2l0aCByZWdpc3RyYXRpb24nKTtcbiAgICB9XG4gICAgXG4gICAgLy8gUmVnaXN0ZXIgdXNlclxuICAgIGNvbnNvbGUubG9nKCdSZWdpc3RlcmluZyBuZXcgdXNlciB3aXRoIHJvbGU6Jywgcm9sZVZhbHVlKTtcbiAgICBjb25zdCB0eCA9IGF3YWl0IGlkZW50aXR5Q29udHJhY3QucmVnaXN0ZXJVc2VyKHJvbGVWYWx1ZSwgXCJcIik7XG4gICAgY29uc29sZS5sb2coJ1JlZ2lzdHJhdGlvbiB0cmFuc2FjdGlvbiBzZW50OicsIHR4Lmhhc2gpO1xuICAgIFxuICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0eC53YWl0KCk7XG4gICAgY29uc29sZS5sb2coJ1JlZ2lzdHJhdGlvbiBzdWNjZXNzZnVsOicsIHJlY2VpcHQuaGFzaCk7XG4gICAgXG4gICAgLy8gVmVyaWZ5IHRoZSB1c2VyIGF1dG9tYXRpY2FsbHlcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ0F0dGVtcHRpbmcgYXV0b21hdGljIHZlcmlmaWNhdGlvbi4uLicpO1xuICAgICAgY29uc3QgdmVyaWZ5VHggPSBhd2FpdCBpZGVudGl0eUNvbnRyYWN0LnZlcmlmeVVzZXIodXNlckFkZHJlc3MpO1xuICAgICAgYXdhaXQgdmVyaWZ5VHgud2FpdCgpO1xuICAgICAgY29uc29sZS5sb2coJ1VzZXIgdmVyaWZpZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgfSBjYXRjaCAodmVyaWZ5RXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybignQXV0b21hdGljIHZlcmlmaWNhdGlvbiBmYWlsZWQ6JywgdmVyaWZ5RXJyb3IpO1xuICAgICAgLy8gQ29udGludWUgZXZlbiBpZiB2ZXJpZmljYXRpb24gZmFpbHNcbiAgICB9XG4gICAgXG4gICAgLy8gSWYgcmVnaXN0ZXJpbmcgYXMgYWRtaW4sIHNldCBhZG1pbiByb2xlXG4gICAgaWYgKHJvbGUudG9Mb3dlckNhc2UoKSA9PT0gJ2FkbWluJykge1xuICAgICAgY29uc29sZS5sb2coJ1NldHRpbmcgYWRtaW4gcHJpdmlsZWdlcy4uLicpO1xuICAgICAgYXdhaXQgc2V0QWRtaW5Sb2xlKCk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB7IHN0YXR1czogJ3N1Y2Nlc3MnLCByb2xlOiByb2xlVmFsdWUsIHRyYW5zYWN0aW9uOiB0eCB9O1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgcmV0dXJuIGhhbmRsZUNvbnRyYWN0RXJyb3IoZXJyb3IpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgdmVyaWZ5VXNlciA9IGFzeW5jIChhZGRyZXNzOiBzdHJpbmcpID0+IHtcbiAgdHJ5IHtcbiAgICBnZXRBZGRyZXNzKGFkZHJlc3MpOyAvLyBVc2luZyBnZXRBZGRyZXNzIGluc3RlYWQgb2YgaXNBZGRyZXNzXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFkZHJlc3MnKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ1ZlcmlmeWluZyB1c2VyOicsIGFkZHJlc3MpO1xuICAgIGNvbnN0IHsgaWRlbnRpdHlDb250cmFjdCB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XG4gICAgY29uc3QgaXNWZXJpZmllZCA9IGF3YWl0IGlkZW50aXR5Q29udHJhY3QuaXNWZXJpZmllZChhZGRyZXNzKTtcbiAgICBjb25zb2xlLmxvZygnVXNlciB2ZXJpZmljYXRpb24gc3RhdHVzOicsIGlzVmVyaWZpZWQpO1xuICAgIHJldHVybiBpc1ZlcmlmaWVkO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gdmVyaWZ5VXNlcjonLCBlcnJvcik7XG4gICAgcmV0dXJuIGhhbmRsZUNvbnRyYWN0RXJyb3IoZXJyb3IpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0VXNlclJvbGUgPSBhc3luYyAoYWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTxSb2xlU3RyaW5nPiA9PiB7XG4gIHRyeSB7XG4gICAgZ2V0QWRkcmVzcyhhZGRyZXNzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYWRkcmVzcycpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygnR2V0dGluZyB1c2VyIHJvbGUgZm9yOicsIGFkZHJlc3MpO1xuICAgIGNvbnN0IHsgaWRlbnRpdHlDb250cmFjdCB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XG4gICAgY29uc3Qgcm9sZSA9IGF3YWl0IGlkZW50aXR5Q29udHJhY3QuZ2V0VXNlclJvbGUoYWRkcmVzcyk7XG4gICAgY29uc29sZS5sb2coJ1VzZXIgcm9sZTonLCByb2xlKTtcbiAgICByZXR1cm4gcm9sZTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGdldFVzZXJSb2xlOicsIGVycm9yKTtcbiAgICByZXR1cm4gaGFuZGxlQ29udHJhY3RFcnJvcihlcnJvcik7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBpc3N1ZUNlcnRpZmljYXRlID0gYXN5bmMgKHN0dWRlbnRBZGRyZXNzOiBzdHJpbmcsIGlwZnNIYXNoOiBzdHJpbmcpID0+IHtcbiAgaWYgKCFzdHVkZW50QWRkcmVzcyB8fCAhaXBmc0hhc2gpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0dWRlbnQgYWRkcmVzcyBhbmQgSVBGUyBoYXNoIGFyZSByZXF1aXJlZCcpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCB7IGNlcnRpZmljYXRlc0NvbnRyYWN0IH0gPSBhd2FpdCBnZXRDb250cmFjdHMoKTtcbiAgICBjb25zdCB0eCA9IGF3YWl0IGNlcnRpZmljYXRlc0NvbnRyYWN0Lmlzc3VlQ2VydGlmaWNhdGUoc3R1ZGVudEFkZHJlc3MsIGlwZnNIYXNoKTtcbiAgICBhd2FpdCB0eC53YWl0KCk7XG4gICAgcmV0dXJuIHR4O1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaXNzdWluZyBjZXJ0aWZpY2F0ZTonLCBlcnJvcik7XG4gICAgcmV0dXJuIGhhbmRsZUNvbnRyYWN0RXJyb3IoZXJyb3IpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgdmVyaWZ5Q2VydGlmaWNhdGUgPSBhc3luYyAoY2VydGlmaWNhdGVJZDogc3RyaW5nKSA9PiB7XG4gIGlmICghY2VydGlmaWNhdGVJZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2VydGlmaWNhdGUgSUQgaXMgcmVxdWlyZWQnKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgeyBjZXJ0aWZpY2F0ZXNDb250cmFjdCB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XG4gICAgY29uc3QgaXNWYWxpZCA9IGF3YWl0IGNlcnRpZmljYXRlc0NvbnRyYWN0LnZlcmlmeUNlcnRpZmljYXRlKGNlcnRpZmljYXRlSWQpO1xuICAgIHJldHVybiBpc1ZhbGlkO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgdmVyaWZ5aW5nIGNlcnRpZmljYXRlOicsIGVycm9yKTtcbiAgICByZXR1cm4gaGFuZGxlQ29udHJhY3RFcnJvcihlcnJvcik7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBnZXRDZXJ0aWZpY2F0ZXMgPSBhc3luYyAoYWRkcmVzczogc3RyaW5nKSA9PiB7XG4gIHRyeSB7XG4gICAgZ2V0QWRkcmVzcyhhZGRyZXNzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYWRkcmVzcycpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygnR2V0dGluZyBjZXJ0aWZpY2F0ZXMgZm9yOicsIGFkZHJlc3MpO1xuICAgIGNvbnN0IHsgY2VydGlmaWNhdGVzQ29udHJhY3QgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xuICAgIGNvbnN0IGNlcnRpZmljYXRlcyA9IGF3YWl0IGNlcnRpZmljYXRlc0NvbnRyYWN0LmdldENlcnRpZmljYXRlcyhhZGRyZXNzKTtcbiAgICBjb25zb2xlLmxvZygnQ2VydGlmaWNhdGVzOicsIGNlcnRpZmljYXRlcyk7XG4gICAgcmV0dXJuIGNlcnRpZmljYXRlcztcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGdldENlcnRpZmljYXRlczonLCBlcnJvcik7XG4gICAgcmV0dXJuIGhhbmRsZUNvbnRyYWN0RXJyb3IoZXJyb3IpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgaXNWZXJpZmllZFVzZXIgPSBhc3luYyAoYWRkcmVzczogc3RyaW5nKSA9PiB7XG4gIHRyeSB7XG4gICAgZ2V0QWRkcmVzcyhhZGRyZXNzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYWRkcmVzcycpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygnQ2hlY2tpbmcgaWYgdXNlciBpcyB2ZXJpZmllZDonLCBhZGRyZXNzKTtcbiAgICBjb25zdCB7IGlkZW50aXR5Q29udHJhY3QgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xuICAgIGNvbnN0IGlzVmVyaWZpZWQgPSBhd2FpdCBpZGVudGl0eUNvbnRyYWN0LmlzVmVyaWZpZWQoYWRkcmVzcyk7XG4gICAgY29uc29sZS5sb2coJ1VzZXIgdmVyaWZpY2F0aW9uIHN0YXR1czonLCBpc1ZlcmlmaWVkKTtcbiAgICByZXR1cm4gaXNWZXJpZmllZDtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGlzVmVyaWZpZWRVc2VyOicsIGVycm9yKTtcbiAgICByZXR1cm4gaGFuZGxlQ29udHJhY3RFcnJvcihlcnJvcik7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBpc093bmVyID0gYXN5bmMgKGFkZHJlc3M6IHN0cmluZykgPT4ge1xuICB0cnkge1xuICAgIGdldEFkZHJlc3MoYWRkcmVzcyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFkZHJlc3MnKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ0NoZWNraW5nIGlmIHVzZXIgaXMgb3duZXI6JywgYWRkcmVzcyk7XG4gICAgY29uc3QgeyBpZGVudGl0eUNvbnRyYWN0IH0gPSBhd2FpdCBnZXRDb250cmFjdHMoKTtcbiAgICBjb25zdCBvd25lckFkZHJlc3MgPSBhd2FpdCBpZGVudGl0eUNvbnRyYWN0Lm93bmVyKCk7XG4gICAgY29uc3QgaXNPd25lclJvbGUgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IG93bmVyQWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnNvbGUubG9nKCdVc2VyIG93bmVyIHN0YXR1czonLCBpc093bmVyUm9sZSk7XG4gICAgcmV0dXJuIGlzT3duZXJSb2xlO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gaXNPd25lcjonLCBlcnJvcik7XG4gICAgcmV0dXJuIGhhbmRsZUNvbnRyYWN0RXJyb3IoZXJyb3IpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgdmVyaWZ5SW5zdGl0dXRpb24gPSBhc3luYyAoaW5zdGl0dXRpb25BZGRyZXNzOiBzdHJpbmcpID0+IHtcbiAgdHJ5IHtcbiAgICBnZXRBZGRyZXNzKGluc3RpdHV0aW9uQWRkcmVzcyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGluc3RpdHV0aW9uIGFkZHJlc3MnKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ1ZlcmlmeWluZyBpbnN0aXR1dGlvbjonLCBpbnN0aXR1dGlvbkFkZHJlc3MpO1xuICAgIGNvbnN0IHsgaWRlbnRpdHlDb250cmFjdCB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XG4gICAgY29uc3QgdHggPSBhd2FpdCBpZGVudGl0eUNvbnRyYWN0LnZlcmlmeVVzZXIoaW5zdGl0dXRpb25BZGRyZXNzKTtcbiAgICBhd2FpdCB0eC53YWl0KCk7XG4gICAgY29uc29sZS5sb2coJ0luc3RpdHV0aW9uIHZlcmlmaWVkIHN1Y2Nlc3NmdWxseScpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gdmVyaWZ5SW5zdGl0dXRpb246JywgZXJyb3IpO1xuICAgIHJldHVybiBoYW5kbGVDb250cmFjdEVycm9yKGVycm9yKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGdldE93bmVyQWRkcmVzcyA9IGFzeW5jICgpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGlkZW50aXR5Q29udHJhY3QgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xuICAgIGNvbnN0IG93bmVyID0gYXdhaXQgaWRlbnRpdHlDb250cmFjdC5vd25lcigpO1xuICAgIHJldHVybiBvd25lcjtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgb3duZXIgYWRkcmVzczonLCBlcnJvcik7XG4gICAgcmV0dXJuIGhhbmRsZUNvbnRyYWN0RXJyb3IoZXJyb3IpO1xuICB9XG59O1xuXG4vLyBBZGQgZXhhbSBtYW5hZ2VtZW50IGZ1bmN0aW9uc1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUV4YW0gPSBhc3luYyAoXG4gIGlkOiBzdHJpbmcsXG4gIHRpdGxlOiBzdHJpbmcsXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmcsXG4gIGRhdGU6IG51bWJlcixcbiAgZHVyYXRpb246IG51bWJlcixcbiAgaXBmc0hhc2g6IHN0cmluZ1xuKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBleGFtTWFuYWdlbWVudENvbnRyYWN0IH0gPSBhd2FpdCBnZXRDb250cmFjdHMoKTtcbiAgICBjb25zdCB0eCA9IGF3YWl0IGV4YW1NYW5hZ2VtZW50Q29udHJhY3QuY3JlYXRlRXhhbShpZCwgdGl0bGUsIGRlc2NyaXB0aW9uLCBkYXRlLCBkdXJhdGlvbiwgaXBmc0hhc2gpO1xuICAgIGF3YWl0IHR4LndhaXQoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIGV4YW06JywgZXJyb3IpO1xuICAgIHJldHVybiBoYW5kbGVDb250cmFjdEVycm9yKGVycm9yKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHN1Ym1pdEV4YW1SZXN1bHQgPSBhc3luYyAoXG4gIGV4YW1JZDogc3RyaW5nLFxuICBzdHVkZW50OiBzdHJpbmcsXG4gIHNjb3JlOiBudW1iZXIsXG4gIGdyYWRlOiBzdHJpbmcsXG4gIGlwZnNIYXNoOiBzdHJpbmdcbikgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgZXhhbU1hbmFnZW1lbnRDb250cmFjdCB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XG4gICAgY29uc3QgdHggPSBhd2FpdCBleGFtTWFuYWdlbWVudENvbnRyYWN0LnN1Ym1pdEV4YW1SZXN1bHQoZXhhbUlkLCBzdHVkZW50LCBzY29yZSwgZ3JhZGUsIGlwZnNIYXNoKTtcbiAgICBhd2FpdCB0eC53YWl0KCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzdWJtaXR0aW5nIGV4YW0gcmVzdWx0OicsIGVycm9yKTtcbiAgICByZXR1cm4gaGFuZGxlQ29udHJhY3RFcnJvcihlcnJvcik7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCB1cGRhdGVFeGFtU3RhdHVzID0gYXN5bmMgKGV4YW1JZDogc3RyaW5nLCBzdGF0dXM6IHN0cmluZykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgZXhhbU1hbmFnZW1lbnRDb250cmFjdCB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XG4gICAgY29uc3QgdHggPSBhd2FpdCBleGFtTWFuYWdlbWVudENvbnRyYWN0LnVwZGF0ZUV4YW1TdGF0dXMoZXhhbUlkLCBzdGF0dXMpO1xuICAgIGF3YWl0IHR4LndhaXQoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIGV4YW0gc3RhdHVzOicsIGVycm9yKTtcbiAgICByZXR1cm4gaGFuZGxlQ29udHJhY3RFcnJvcihlcnJvcik7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBnZXRFeGFtID0gYXN5bmMgKGV4YW1JZDogc3RyaW5nKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBleGFtTWFuYWdlbWVudENvbnRyYWN0IH0gPSBhd2FpdCBnZXRDb250cmFjdHMoKTtcbiAgICBjb25zdCBleGFtID0gYXdhaXQgZXhhbU1hbmFnZW1lbnRDb250cmFjdC5nZXRFeGFtKGV4YW1JZCk7XG4gICAgcmV0dXJuIGV4YW07XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIGV4YW06JywgZXJyb3IpO1xuICAgIHJldHVybiBoYW5kbGVDb250cmFjdEVycm9yKGVycm9yKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGdldEV4YW1SZXN1bHQgPSBhc3luYyAoZXhhbUlkOiBzdHJpbmcsIHN0dWRlbnQ6IHN0cmluZykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgZXhhbU1hbmFnZW1lbnRDb250cmFjdCB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXhhbU1hbmFnZW1lbnRDb250cmFjdC5nZXRFeGFtUmVzdWx0KGV4YW1JZCwgc3R1ZGVudCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgZXhhbSByZXN1bHQ6JywgZXJyb3IpO1xuICAgIHJldHVybiBoYW5kbGVDb250cmFjdEVycm9yKGVycm9yKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGdldEluc3RpdHV0aW9uRXhhbXMgPSBhc3luYyAoaW5zdGl0dXRpb246IHN0cmluZykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgZXhhbU1hbmFnZW1lbnRDb250cmFjdCB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XG4gICAgY29uc3QgZXhhbXMgPSBhd2FpdCBleGFtTWFuYWdlbWVudENvbnRyYWN0LmdldEluc3RpdHV0aW9uRXhhbXMoaW5zdGl0dXRpb24pO1xuICAgIHJldHVybiBleGFtcztcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgaW5zdGl0dXRpb24gZXhhbXM6JywgZXJyb3IpO1xuICAgIHJldHVybiBoYW5kbGVDb250cmFjdEVycm9yKGVycm9yKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGdldFN0dWRlbnRFeGFtcyA9IGFzeW5jIChzdHVkZW50OiBzdHJpbmcpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGV4YW1NYW5hZ2VtZW50Q29udHJhY3QgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xuICAgIGNvbnN0IGV4YW1zID0gYXdhaXQgZXhhbU1hbmFnZW1lbnRDb250cmFjdC5nZXRTdHVkZW50RXhhbXMoc3R1ZGVudCk7XG4gICAgcmV0dXJuIGV4YW1zO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBzdHVkZW50IGV4YW1zOicsIGVycm9yKTtcbiAgICByZXR1cm4gaGFuZGxlQ29udHJhY3RFcnJvcihlcnJvcik7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBlbnJvbGxTdHVkZW50ID0gYXN5bmMgKGV4YW1JZDogc3RyaW5nLCBzdHVkZW50QWRkcmVzczogc3RyaW5nKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBleGFtTWFuYWdlbWVudENvbnRyYWN0IH0gPSBhd2FpdCBnZXRDb250cmFjdHMoKTtcbiAgICBjb25zdCB0eCA9IGF3YWl0IGV4YW1NYW5hZ2VtZW50Q29udHJhY3QuZW5yb2xsU3R1ZGVudChleGFtSWQsIHN0dWRlbnRBZGRyZXNzKTtcbiAgICBhd2FpdCB0eC53YWl0KCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBlbnJvbGxpbmcgc3R1ZGVudDonLCBlcnJvcik7XG4gICAgcmV0dXJuIGhhbmRsZUNvbnRyYWN0RXJyb3IoZXJyb3IpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0Q29udHJhY3QgPSBhc3luYyAoKSA9PiB7XG4gIGNvbnN0IHsgZXhhbU1hbmFnZW1lbnRDb250cmFjdCB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XG4gIHJldHVybiBleGFtTWFuYWdlbWVudENvbnRyYWN0O1xufTtcblxuZXhwb3J0IGNvbnN0IHNldEFkbWluUm9sZSA9IGFzeW5jICgpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGlkZW50aXR5Q29udHJhY3QsIHNpZ25lciB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XG4gICAgY29uc3QgdXNlckFkZHJlc3MgPSBhd2FpdCBzaWduZXIuZ2V0QWRkcmVzcygpO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKCdTZXR0aW5nIGFkbWluIHJvbGUgZm9yIGFkZHJlc3M6JywgdXNlckFkZHJlc3MpO1xuICAgIGNvbnNvbGUubG9nKCdFeHBlY3RlZCBhZG1pbiBhZGRyZXNzOicsIEFETUlOX0FERFJFU1MpO1xuICAgIFxuICAgIC8vIEZpcnN0IGNoZWNrIGlmIHRoZSBhZGRyZXNzIGlzIGFscmVhZHkgYW4gYWRtaW5cbiAgICBjb25zdCBpc0FkbWluID0gYXdhaXQgaWRlbnRpdHlDb250cmFjdC5pc0FkbWluKHVzZXJBZGRyZXNzKTtcbiAgICBjb25zb2xlLmxvZygnSXMgYWxyZWFkeSBhZG1pbj8nLCBpc0FkbWluKTtcbiAgICBcbiAgICBpZiAoaXNBZG1pbikge1xuICAgICAgY29uc29sZS5sb2coJ1VzZXIgaXMgYWxyZWFkeSBhbiBhZG1pbicpO1xuICAgICAgcmV0dXJuIHsgc3RhdHVzOiAnZXhpc3RpbmcnLCBpc0FkbWluOiB0cnVlIH07XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgdGhlIGNvbmZpZ3VyZWQgYWRtaW4gYWRkcmVzc1xuICAgIGlmIChBRE1JTl9BRERSRVNTICYmIHVzZXJBZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IEFETUlOX0FERFJFU1MudG9Mb3dlckNhc2UoKSkge1xuICAgICAgY29uc29sZS5sb2coJ0FkZHJlc3MgbWF0Y2hlcyBjb25maWd1cmVkIGFkbWluLCBhZGRpbmcgYXMgYWRtaW4uLi4nKTtcbiAgICAgIFxuICAgICAgLy8gRmlyc3QgdHJ5IHRvIHJlZ2lzdGVyIGFzIGFkbWluIGlmIG5vdCBhbHJlYWR5IHJlZ2lzdGVyZWRcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJvbGUgPSBhd2FpdCBpZGVudGl0eUNvbnRyYWN0LmdldFVzZXJSb2xlKHVzZXJBZGRyZXNzKTtcbiAgICAgICAgaWYgKHJvbGUgPT09IDApIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnUmVnaXN0ZXJpbmcgYWRtaW4gdXNlciBmaXJzdC4uLicpO1xuICAgICAgICAgIGNvbnN0IHJlZ1R4ID0gYXdhaXQgaWRlbnRpdHlDb250cmFjdC5yZWdpc3RlclVzZXIoVVNFUl9ST0xFUy5BRE1JTiwgXCJcIik7XG4gICAgICAgICAgYXdhaXQgcmVnVHgud2FpdCgpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgIGlmICghZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnVXNlciBkb2VzIG5vdCBleGlzdCcpKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdXNlciBkb2Vzbid0IGV4aXN0LCByZWdpc3RlciB0aGVtIGFzIGFkbWluXG4gICAgICAgIGNvbnNvbGUubG9nKCdSZWdpc3RlcmluZyBuZXcgYWRtaW4gdXNlci4uLicpO1xuICAgICAgICBjb25zdCByZWdUeCA9IGF3YWl0IGlkZW50aXR5Q29udHJhY3QucmVnaXN0ZXJVc2VyKFVTRVJfUk9MRVMuQURNSU4sIFwiXCIpO1xuICAgICAgICBhd2FpdCByZWdUeC53YWl0KCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFZlcmlmeSB0aGUgdXNlclxuICAgICAgY29uc29sZS5sb2coJ1ZlcmlmeWluZyBhZG1pbiB1c2VyLi4uJyk7XG4gICAgICBjb25zdCB2ZXJpZnlUeCA9IGF3YWl0IGlkZW50aXR5Q29udHJhY3QudmVyaWZ5VXNlcih1c2VyQWRkcmVzcyk7XG4gICAgICBhd2FpdCB2ZXJpZnlUeC53YWl0KCk7XG4gICAgICBcbiAgICAgIC8vIEFkZCBhZG1pbiByb2xlXG4gICAgICBjb25zb2xlLmxvZygnQWRkaW5nIGFkbWluIHJvbGUuLi4nKTtcbiAgICAgIGNvbnN0IHR4ID0gYXdhaXQgaWRlbnRpdHlDb250cmFjdC5hZGRBZG1pbih1c2VyQWRkcmVzcyk7XG4gICAgICBhd2FpdCB0eC53YWl0KCk7XG4gICAgICBjb25zb2xlLmxvZygnU3VjY2Vzc2Z1bGx5IGFkZGVkIGFzIGFkbWluJyk7XG4gICAgICBcbiAgICAgIHJldHVybiB7IHN0YXR1czogJ3N1Y2Nlc3MnLCBpc0FkbWluOiB0cnVlIH07XG4gICAgfVxuICAgIFxuICAgIHRocm93IG5ldyBFcnJvcignT25seSBjb25maWd1cmVkIGFkbWluIGFkZHJlc3NlcyBjYW4gYmUgc2V0IGFzIGFkbWluJyk7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzZXR0aW5nIGFkbWluIHJvbGU6JywgZXJyb3IpO1xuICAgIHJldHVybiBoYW5kbGVDb250cmFjdEVycm9yKGVycm9yKTtcbiAgfVxufTsgIl0sIm5hbWVzIjpbIkNvbnRyYWN0IiwiZm9ybWF0VW5pdHMiLCJnZXRBZGRyZXNzIiwiRVhBTV9NQU5BR0VNRU5UX0FCSSIsImdldFByb3ZpZGVyIiwiZ2V0U2lnbmVyIiwiRVhQRUNURURfTkVUV09SSyIsInZhbGlkYXRlTmV0d29yayIsImhhbmRsZUNvbnRyYWN0RXJyb3IiLCJnZXRDb25maWciLCJ2YWxpZGF0ZUNvbmZpZyIsIklkZW50aXR5QUJJIiwiQ2VydGlmaWNhdGVzQUJJIiwiSURFTlRJVFlfQ09OVFJBQ1RfQUREUkVTUyIsIkNFUlRJRklDQVRFU19DT05UUkFDVF9BRERSRVNTIiwiQURNSU5fQUREUkVTUyIsIkVYQU1fTUFOQUdFTUVOVF9BRERSRVNTIiwidmFsaWRhdGVFbnYiLCJFcnJvciIsImNvbnNvbGUiLCJsb2ciLCJDSEFJTl9JRCIsIk5FVFdPUktfVVJMIiwiZXJyb3IiLCJjaGFpbklkIiwicnBjVXJsIiwiVVNFUl9ST0xFUyIsIk5PTkUiLCJTVFVERU5UIiwiSU5TVElUVVRJT04iLCJFTVBMT1lFUiIsIkFETUlOIiwicm9sZU1hcCIsImdldENvbnRyYWN0cyIsIklkZW50aXR5IiwiQ2VydGlmaWNhdGVzIiwiQWRtaW4iLCJwcm92aWRlciIsInNpZ25lciIsInVzZXJBZGRyZXNzIiwidXNlckJhbGFuY2UiLCJnZXRCYWxhbmNlIiwiaWRlbnRpdHlDb250cmFjdCIsImNvZGUiLCJnZXRDb2RlIiwibGVuZ3RoIiwiY2VydGlmaWNhdGVzQ29udHJhY3QiLCJleGFtTWFuYWdlbWVudENvbnRyYWN0IiwibWVzc2FnZSIsInJlYXNvbiIsInJlZ2lzdGVyVXNlciIsInJvbGUiLCJ0b0xvd2VyQ2FzZSIsInNldEFkbWluUm9sZSIsInJvbGVWYWx1ZSIsInVuZGVmaW5lZCIsImV4aXN0aW5nUm9sZSIsImdldFVzZXJSb2xlIiwiaXNWZXJpZmllZCIsInZlcmlmeVR4IiwidmVyaWZ5VXNlciIsIndhaXQiLCJzdGF0dXMiLCJpbmNsdWRlcyIsInR4IiwiaGFzaCIsInJlY2VpcHQiLCJ2ZXJpZnlFcnJvciIsIndhcm4iLCJ0cmFuc2FjdGlvbiIsImFkZHJlc3MiLCJpc3N1ZUNlcnRpZmljYXRlIiwic3R1ZGVudEFkZHJlc3MiLCJpcGZzSGFzaCIsInZlcmlmeUNlcnRpZmljYXRlIiwiY2VydGlmaWNhdGVJZCIsImlzVmFsaWQiLCJnZXRDZXJ0aWZpY2F0ZXMiLCJjZXJ0aWZpY2F0ZXMiLCJpc1ZlcmlmaWVkVXNlciIsImlzT3duZXIiLCJvd25lckFkZHJlc3MiLCJvd25lciIsImlzT3duZXJSb2xlIiwidmVyaWZ5SW5zdGl0dXRpb24iLCJpbnN0aXR1dGlvbkFkZHJlc3MiLCJnZXRPd25lckFkZHJlc3MiLCJjcmVhdGVFeGFtIiwiaWQiLCJ0aXRsZSIsImRlc2NyaXB0aW9uIiwiZGF0ZSIsImR1cmF0aW9uIiwic3VibWl0RXhhbVJlc3VsdCIsImV4YW1JZCIsInN0dWRlbnQiLCJzY29yZSIsImdyYWRlIiwidXBkYXRlRXhhbVN0YXR1cyIsImdldEV4YW0iLCJleGFtIiwiZ2V0RXhhbVJlc3VsdCIsInJlc3VsdCIsImdldEluc3RpdHV0aW9uRXhhbXMiLCJpbnN0aXR1dGlvbiIsImV4YW1zIiwiZ2V0U3R1ZGVudEV4YW1zIiwiZW5yb2xsU3R1ZGVudCIsImdldENvbnRyYWN0IiwiaXNBZG1pbiIsInJlZ1R4IiwiYWRkQWRtaW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./utils/contracts.ts\n"));

/***/ })

});