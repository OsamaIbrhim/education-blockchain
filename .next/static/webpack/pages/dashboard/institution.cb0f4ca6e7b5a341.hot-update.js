"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/dashboard/institution",{

/***/ "./utilsFront/contracts.ts":
/*!*********************************!*\
  !*** ./utilsFront/contracts.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createExam: function() { return /* binding */ createExam; },\n/* harmony export */   enrollStudent: function() { return /* binding */ enrollStudent; },\n/* harmony export */   getCertificates: function() { return /* binding */ getCertificates; },\n/* harmony export */   getContract: function() { return /* binding */ getContract; },\n/* harmony export */   getContracts: function() { return /* binding */ getContracts; },\n/* harmony export */   getExam: function() { return /* binding */ getExam; },\n/* harmony export */   getExamResult: function() { return /* binding */ getExamResult; },\n/* harmony export */   getInstitutionExams: function() { return /* binding */ getInstitutionExams; },\n/* harmony export */   getOwnerAddress: function() { return /* binding */ getOwnerAddress; },\n/* harmony export */   getStudentExams: function() { return /* binding */ getStudentExams; },\n/* harmony export */   getUserRole: function() { return /* binding */ getUserRole; },\n/* harmony export */   isOwner: function() { return /* binding */ isOwner; },\n/* harmony export */   isVerifiedUser: function() { return /* binding */ isVerifiedUser; },\n/* harmony export */   issueCertificate: function() { return /* binding */ issueCertificate; },\n/* harmony export */   registerUser: function() { return /* binding */ registerUser; },\n/* harmony export */   setAdminRole: function() { return /* binding */ setAdminRole; },\n/* harmony export */   submitExamResult: function() { return /* binding */ submitExamResult; },\n/* harmony export */   updateExamStatus: function() { return /* binding */ updateExamStatus; },\n/* harmony export */   validateEnv: function() { return /* binding */ validateEnv; },\n/* harmony export */   verifyCertificate: function() { return /* binding */ verifyCertificate; },\n/* harmony export */   verifyInstitution: function() { return /* binding */ verifyInstitution; },\n/* harmony export */   verifyUser: function() { return /* binding */ verifyUser; }\n/* harmony export */ });\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"./node_modules/.pnpm/ethers@6.13.5_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/ethers/lib.esm/index.js\");\n/* harmony import */ var _constants_abis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/abis */ \"./constants/abis.ts\");\n/* harmony import */ var _ethersConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ethersConfig */ \"./utilsFront/ethersConfig.ts\");\n/* harmony import */ var _utils_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/config */ \"./utils/config.ts\");\n\n\n\n\n// Contract ABIs\nconst IdentityABI = [\n    \"function registerUser(uint8 _role, string memory _ipfsHash) external\",\n    \"function verifyUser(address _userAddress) external\",\n    \"function getUserRole(address _userAddress) external view returns (uint8)\",\n    \"function isVerifiedUser(address _userAddress) external view returns (bool)\",\n    \"function updateUserIPFS(string memory _newIpfsHash) external\",\n    \"function owner() external view returns (address)\",\n    \"function isAdmin(address _address) external view returns (bool)\",\n    \"function addAdmin(address _newAdmin) external\",\n    \"function removeAdmin(address _admin) external\"\n];\nconst CertificatesABI = [\n    \"function issueCertificate(address _studentAddress, string memory _ipfsHash) external returns (bytes32)\",\n    \"function getStudentCertificates(address _student) external view returns (bytes32[])\",\n    \"function verifyCertificate(bytes32 _certificateId) external view returns (address student, address institution, string ipfsHash, uint256 issuedAt, bool isValid)\"\n];\n// Contract addresses from config\nconst IDENTITY_CONTRACT_ADDRESS = (0,_utils_config__WEBPACK_IMPORTED_MODULE_2__.getConfig)(\"IDENTITY_CONTRACT_ADDRESS\");\nconst CERTIFICATES_CONTRACT_ADDRESS = (0,_utils_config__WEBPACK_IMPORTED_MODULE_2__.getConfig)(\"CERTIFICATES_CONTRACT_ADDRESS\");\nconst ADMIN_ADDRESS = (0,_utils_config__WEBPACK_IMPORTED_MODULE_2__.getConfig)(\"ADMIN_ADDRESS\");\nconst EXAM_MANAGEMENT_ADDRESS = (0,_utils_config__WEBPACK_IMPORTED_MODULE_2__.getConfig)(\"EXAM_MANAGEMENT_CONTRACT_ADDRESS\");\n// Validate environment variables\nconst validateEnv = ()=>{\n    try {\n        // التحقق من صحة التكوين\n        (0,_utils_config__WEBPACK_IMPORTED_MODULE_2__.validateConfig)();\n        // التحقق من صحة العناوين\n        if (!(0,ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress)(IDENTITY_CONTRACT_ADDRESS)) {\n            throw new Error(\"Invalid Identity contract address: \".concat(IDENTITY_CONTRACT_ADDRESS));\n        }\n        if (!(0,ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress)(CERTIFICATES_CONTRACT_ADDRESS)) {\n            throw new Error(\"Invalid Certificates contract address: \".concat(CERTIFICATES_CONTRACT_ADDRESS));\n        }\n        if (!(0,ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress)(ADMIN_ADDRESS)) {\n            throw new Error(\"Invalid Admin address: \".concat(ADMIN_ADDRESS));\n        }\n        if (!(0,ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress)(EXAM_MANAGEMENT_ADDRESS)) {\n            throw new Error(\"Invalid Exam Management contract address: \".concat(EXAM_MANAGEMENT_ADDRESS));\n        }\n        console.log(\"Configuration validated successfully:\", {\n            IDENTITY_CONTRACT_ADDRESS,\n            CERTIFICATES_CONTRACT_ADDRESS,\n            ADMIN_ADDRESS,\n            EXAM_MANAGEMENT_ADDRESS,\n            CHAIN_ID: (0,_utils_config__WEBPACK_IMPORTED_MODULE_2__.getConfig)(\"CHAIN_ID\"),\n            NETWORK_URL: (0,_utils_config__WEBPACK_IMPORTED_MODULE_2__.getConfig)(\"NETWORK_URL\")\n        });\n        return true;\n    } catch (error) {\n        console.error(\"Configuration validation failed:\", error);\n        throw error;\n    }\n};\n// Debug environment variables\nconsole.log(\"Environment variables check:\", {\n    IDENTITY_CONTRACT_ADDRESS,\n    CERTIFICATES_CONTRACT_ADDRESS,\n    ADMIN_ADDRESS,\n    EXAM_MANAGEMENT_ADDRESS,\n    CHAIN_ID: _ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.chainId,\n    NETWORK_URL: _ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl\n});\n// Role mapping with proper types\nconst USER_ROLES = {\n    NONE: 0,\n    STUDENT: 1,\n    INSTITUTION: 2,\n    EMPLOYER: 3,\n    ADMIN: 4\n};\nconst roleMap = {\n    [USER_ROLES.NONE]: \"none\",\n    [USER_ROLES.STUDENT]: \"student\",\n    [USER_ROLES.INSTITUTION]: \"institution\",\n    [USER_ROLES.EMPLOYER]: \"employer\",\n    [USER_ROLES.ADMIN]: \"admin\"\n};\nconst getContracts = async ()=>{\n    try {\n        console.log(\"Contract Addresses:\", {\n            Identity: IDENTITY_CONTRACT_ADDRESS,\n            Certificates: CERTIFICATES_CONTRACT_ADDRESS,\n            Admin: ADMIN_ADDRESS\n        });\n        const provider = await (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getProvider)();\n        await (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.validateNetwork)(provider);\n        console.log(\"Network validation passed\");\n        const signer = await (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getSigner)();\n        const userAddress = await signer.getAddress();\n        console.log(\"Connected with address:\", userAddress);\n        const userBalance = await provider.getBalance(userAddress);\n        console.log(\"User balance:\", (0,ethers__WEBPACK_IMPORTED_MODULE_3__.formatUnits)(userBalance, \"ether\"), \"ETH\");\n        const identityContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.Contract(IDENTITY_CONTRACT_ADDRESS, IdentityABI, signer);\n        console.log(\"Verifying contract exists at address:\", IDENTITY_CONTRACT_ADDRESS);\n        const code = await provider.getCode(IDENTITY_CONTRACT_ADDRESS);\n        console.log(\"Contract code length:\", code.length);\n        console.log(\"Contract exists:\", code !== \"0x\");\n        if (code === \"0x\") {\n            throw new Error(\"Identity contract not found at address: \".concat(IDENTITY_CONTRACT_ADDRESS));\n        }\n        const certificatesContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.Contract(CERTIFICATES_CONTRACT_ADDRESS, CertificatesABI, signer);\n        const examManagementContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.Contract(EXAM_MANAGEMENT_ADDRESS, _constants_abis__WEBPACK_IMPORTED_MODULE_0__.ExamManagementABI, signer);\n        return {\n            identityContract,\n            certificatesContract,\n            examManagementContract,\n            provider,\n            signer\n        };\n    } catch (error) {\n        console.error(\"Error initializing contracts:\", error);\n        console.error(\"Error details:\", {\n            message: error.message,\n            code: error.code,\n            reason: error.reason\n        });\n        throw new Error(\"Failed to initialize contracts: \".concat(error.message));\n    }\n};\nconst registerUser = async (role)=>{\n    if (!role) {\n        throw new Error(\"Role is required\");\n    }\n    try {\n        const { identityContract, signer } = await getContracts();\n        // Get network details and user address\n        const userAddress = await signer.getAddress();\n        console.log(\"Registering address:\", userAddress);\n        console.log(\"With role:\", role);\n        // Special handling for admin address\n        if (ADMIN_ADDRESS && userAddress.toLowerCase() === ADMIN_ADDRESS.toLowerCase()) {\n            console.log(\"This is the admin address, setting admin role...\");\n            return await setAdminRole();\n        }\n        // Convert role string to enum value\n        const roleMap = {\n            \"student\": USER_ROLES.STUDENT,\n            \"institution\": USER_ROLES.INSTITUTION,\n            \"employer\": USER_ROLES.EMPLOYER,\n            \"admin\": USER_ROLES.ADMIN\n        };\n        const roleValue = roleMap[role.toLowerCase()];\n        if (roleValue === undefined) {\n            throw new Error(\"Invalid role: \".concat(role, \". Must be one of: student, institution, employer, admin\"));\n        }\n        console.log(\"Role value from mapping:\", roleValue);\n        // Check if user is already registered\n        try {\n            console.log(\"Checking if user already exists...\");\n            const existingRole = await identityContract.getUserRole(userAddress);\n            console.log(\"Existing role:\", existingRole);\n            if (existingRole > 0) {\n                console.log(\"User already registered with role:\", existingRole);\n                // If user exists but needs verification\n                const isVerified = await identityContract.isVerified(userAddress);\n                if (!isVerified) {\n                    console.log(\"User exists but not verified, attempting verification...\");\n                    const verifyTx = await identityContract.verifyUser(userAddress);\n                    await verifyTx.wait();\n                    console.log(\"User verified successfully\");\n                }\n                return {\n                    status: \"existing\",\n                    role: existingRole\n                };\n            }\n        } catch (error) {\n            if (!error.message.includes(\"User does not exist\")) {\n                throw error;\n            }\n            console.log(\"User does not exist, proceeding with registration\");\n        }\n        // Register user\n        console.log(\"Registering new user with role:\", roleValue);\n        const tx = await identityContract.registerUser(roleValue, \"\");\n        console.log(\"Registration transaction sent:\", tx.hash);\n        const receipt = await tx.wait();\n        console.log(\"Registration successful:\", receipt.hash);\n        // Verify the user automatically\n        try {\n            console.log(\"Attempting automatic verification...\");\n            const verifyTx = await identityContract.verifyUser(userAddress);\n            await verifyTx.wait();\n            console.log(\"User verified successfully\");\n        } catch (verifyError) {\n            console.warn(\"Automatic verification failed:\", verifyError);\n        // Continue even if verification fails\n        }\n        // If registering as admin, set admin role\n        if (role.toLowerCase() === \"admin\") {\n            console.log(\"Setting admin privileges...\");\n            await setAdminRole();\n        }\n        return {\n            status: \"success\",\n            role: roleValue,\n            transaction: tx\n        };\n    } catch (error) {\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst verifyUser = async (address)=>{\n    try {\n        (0,ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress)(address); // Using getAddress instead of isAddress\n    } catch (error) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        console.log(\"Verifying user:\", address);\n        const { identityContract } = await getContracts();\n        const isVerified = await identityContract.isVerified(address);\n        console.log(\"User verification status:\", isVerified);\n        return isVerified;\n    } catch (error) {\n        console.error(\"Error in verifyUser:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst getUserRole = async (address)=>{\n    try {\n        (0,ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress)(address);\n    } catch (error) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        console.log(\"Getting user role for:\", address);\n        const { identityContract } = await getContracts();\n        const role = await identityContract.getUserRole(address);\n        console.log(\"User role:\", role);\n        return role;\n    } catch (error) {\n        console.error(\"Error in getUserRole:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst issueCertificate = async (studentAddress, ipfsHash)=>{\n    if (!studentAddress || !ipfsHash) {\n        throw new Error(\"Student address and IPFS hash are required\");\n    }\n    try {\n        const { certificatesContract } = await getContracts();\n        const tx = await certificatesContract.issueCertificate(studentAddress, ipfsHash);\n        await tx.wait();\n        return tx;\n    } catch (error) {\n        console.error(\"Error issuing certificate:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst verifyCertificate = async (certificateId)=>{\n    if (!certificateId) {\n        throw new Error(\"Certificate ID is required\");\n    }\n    try {\n        const { certificatesContract } = await getContracts();\n        const isValid = await certificatesContract.verifyCertificate(certificateId);\n        return isValid;\n    } catch (error) {\n        console.error(\"Error verifying certificate:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst getCertificates = async (address)=>{\n    try {\n        (0,ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress)(address);\n    } catch (error) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        console.log(\"Getting certificates for:\", address);\n        const { certificatesContract } = await getContracts();\n        const certificates = await certificatesContract.getCertificates(address);\n        console.log(\"Certificates:\", certificates);\n        return certificates;\n    } catch (error) {\n        console.error(\"Error in getCertificates:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst isVerifiedUser = async (address)=>{\n    try {\n        (0,ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress)(address);\n    } catch (error) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        console.log(\"Checking if user is verified:\", address);\n        const { identityContract } = await getContracts();\n        const isVerified = await identityContract.isVerified(address);\n        console.log(\"User verification status:\", isVerified);\n        return isVerified;\n    } catch (error) {\n        console.error(\"Error in isVerifiedUser:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst isOwner = async (address)=>{\n    try {\n        (0,ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress)(address);\n    } catch (error) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        console.log(\"Checking if user is owner:\", address);\n        const { identityContract } = await getContracts();\n        const ownerAddress = await identityContract.owner();\n        const isOwnerRole = address.toLowerCase() === ownerAddress.toLowerCase();\n        console.log(\"User owner status:\", isOwnerRole);\n        return isOwnerRole;\n    } catch (error) {\n        console.error(\"Error in isOwner:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst verifyInstitution = async (institutionAddress)=>{\n    try {\n        (0,ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress)(institutionAddress);\n    } catch (error) {\n        throw new Error(\"Invalid institution address\");\n    }\n    try {\n        console.log(\"Verifying institution:\", institutionAddress);\n        const { identityContract } = await getContracts();\n        const tx = await identityContract.verifyUser(institutionAddress);\n        await tx.wait();\n        console.log(\"Institution verified successfully\");\n        return true;\n    } catch (error) {\n        console.error(\"Error in verifyInstitution:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst getOwnerAddress = async ()=>{\n    try {\n        const { identityContract } = await getContracts();\n        const owner = await identityContract.owner();\n        return owner;\n    } catch (error) {\n        console.error(\"Error getting owner address:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\n// Add exam management functions\nconst createExam = async (id, title, description, date, duration, ipfsHash)=>{\n    try {\n        const { examManagementContract } = await getContracts();\n        const tx = await examManagementContract.createExam(id, title, description, date, duration, ipfsHash);\n        await tx.wait();\n        return true;\n    } catch (error) {\n        console.error(\"Error creating exam:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst submitExamResult = async (examId, student, score, grade, ipfsHash)=>{\n    try {\n        const { examManagementContract } = await getContracts();\n        const tx = await examManagementContract.submitExamResult(examId, student, score, grade, ipfsHash);\n        await tx.wait();\n        return true;\n    } catch (error) {\n        console.error(\"Error submitting exam result:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst updateExamStatus = async (examId, status)=>{\n    try {\n        const { examManagementContract } = await getContracts();\n        const tx = await examManagementContract.updateExamStatus(examId, status);\n        await tx.wait();\n        return true;\n    } catch (error) {\n        console.error(\"Error updating exam status:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst getExam = async (examId)=>{\n    try {\n        const { examManagementContract } = await getContracts();\n        const exam = await examManagementContract.getExam(examId);\n        return exam;\n    } catch (error) {\n        console.error(\"Error getting exam:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst getExamResult = async (examId, student)=>{\n    try {\n        const { examManagementContract } = await getContracts();\n        const result = await examManagementContract.getExamResult(examId, student);\n        return result;\n    } catch (error) {\n        console.error(\"Error getting exam result:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst getInstitutionExams = async (institution)=>{\n    try {\n        const { examManagementContract } = await getContracts();\n        const exams = await examManagementContract.getInstitutionExams(institution);\n        return exams;\n    } catch (error) {\n        console.error(\"Error getting institution exams:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst getStudentExams = async (student)=>{\n    try {\n        const { examManagementContract } = await getContracts();\n        const exams = await examManagementContract.getStudentExams(student);\n        return exams;\n    } catch (error) {\n        console.error(\"Error getting student exams:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst enrollStudent = async (examId, studentAddress)=>{\n    try {\n        const { examManagementContract } = await getContracts();\n        const tx = await examManagementContract.enrollStudent(examId, studentAddress);\n        await tx.wait();\n        return true;\n    } catch (error) {\n        console.error(\"Error enrolling student:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst getContract = async ()=>{\n    const { examManagementContract } = await getContracts();\n    return examManagementContract;\n};\nconst setAdminRole = async ()=>{\n    try {\n        const { identityContract, signer } = await getContracts();\n        const userAddress = await signer.getAddress();\n        console.log(\"Setting admin role for address:\", userAddress);\n        console.log(\"Expected admin address:\", ADMIN_ADDRESS);\n        // First check if the address is already an admin\n        const isAdmin = await identityContract.isAdmin(userAddress);\n        console.log(\"Is already admin?\", isAdmin);\n        if (isAdmin) {\n            console.log(\"User is already an admin\");\n            return {\n                status: \"existing\",\n                isAdmin: true\n            };\n        }\n        // Check if this is the configured admin address\n        if (ADMIN_ADDRESS && userAddress.toLowerCase() === ADMIN_ADDRESS.toLowerCase()) {\n            console.log(\"Address matches configured admin, adding as admin...\");\n            // First try to register as admin if not already registered\n            try {\n                const role = await identityContract.getUserRole(userAddress);\n                if (role === 0) {\n                    console.log(\"Registering admin user first...\");\n                    const regTx = await identityContract.registerUser(USER_ROLES.ADMIN, \"\");\n                    await regTx.wait();\n                }\n            } catch (error) {\n                if (!error.message.includes(\"User does not exist\")) {\n                    throw error;\n                }\n                // If user doesn't exist, register them as admin\n                console.log(\"Registering new admin user...\");\n                const regTx = await identityContract.registerUser(USER_ROLES.ADMIN, \"\");\n                await regTx.wait();\n            }\n            // Verify the user\n            console.log(\"Verifying admin user...\");\n            const verifyTx = await identityContract.verifyUser(userAddress);\n            await verifyTx.wait();\n            // Add admin role\n            console.log(\"Adding admin role...\");\n            const tx = await identityContract.addAdmin(userAddress);\n            await tx.wait();\n            console.log(\"Successfully added as admin\");\n            return {\n                status: \"success\",\n                isAdmin: true\n            };\n        }\n        throw new Error(\"Only configured admin addresses can be set as admin\");\n    } catch (error) {\n        console.error(\"Error setting admin role:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0lBQzdCO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi91dGlsc0Zyb250L2NvbnRyYWN0cy50cz9hY2E2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFxuICBDb250cmFjdCxcbiAgZm9ybWF0VW5pdHMsXG4gIGdldEFkZHJlc3Ncbn0gZnJvbSAnZXRoZXJzJztcbmltcG9ydCB7IEV4YW1NYW5hZ2VtZW50QUJJIH0gZnJvbSAnLi4vY29uc3RhbnRzL2FiaXMnO1xuaW1wb3J0IHsgXG4gIGdldFByb3ZpZGVyLCBcbiAgZ2V0U2lnbmVyLCBcbiAgRVhQRUNURURfTkVUV09SSywgXG4gIHZhbGlkYXRlTmV0d29yayxcbiAgZm9ybWF0RXRoZXIsXG4gIGhhbmRsZUNvbnRyYWN0RXJyb3Jcbn0gZnJvbSAnLi9ldGhlcnNDb25maWcnO1xuaW1wb3J0IHR5cGUgeyBFdGhlcmV1bVByb3ZpZGVyIH0gZnJvbSAnLi9ldGhlcnNDb25maWcnO1xuaW1wb3J0IHsgZ2V0Q29uZmlnLCB2YWxpZGF0ZUNvbmZpZyB9IGZyb20gJy4uL3V0aWxzL2NvbmZpZyc7XG5cbi8vIENvbnRyYWN0IEFCSXNcbmNvbnN0IElkZW50aXR5QUJJID0gW1xuICBcImZ1bmN0aW9uIHJlZ2lzdGVyVXNlcih1aW50OCBfcm9sZSwgc3RyaW5nIG1lbW9yeSBfaXBmc0hhc2gpIGV4dGVybmFsXCIsXG4gIFwiZnVuY3Rpb24gdmVyaWZ5VXNlcihhZGRyZXNzIF91c2VyQWRkcmVzcykgZXh0ZXJuYWxcIixcbiAgXCJmdW5jdGlvbiBnZXRVc2VyUm9sZShhZGRyZXNzIF91c2VyQWRkcmVzcykgZXh0ZXJuYWwgdmlldyByZXR1cm5zICh1aW50OClcIixcbiAgXCJmdW5jdGlvbiBpc1ZlcmlmaWVkVXNlcihhZGRyZXNzIF91c2VyQWRkcmVzcykgZXh0ZXJuYWwgdmlldyByZXR1cm5zIChib29sKVwiLFxuICBcImZ1bmN0aW9uIHVwZGF0ZVVzZXJJUEZTKHN0cmluZyBtZW1vcnkgX25ld0lwZnNIYXNoKSBleHRlcm5hbFwiLFxuICBcImZ1bmN0aW9uIG93bmVyKCkgZXh0ZXJuYWwgdmlldyByZXR1cm5zIChhZGRyZXNzKVwiLFxuICBcImZ1bmN0aW9uIGlzQWRtaW4oYWRkcmVzcyBfYWRkcmVzcykgZXh0ZXJuYWwgdmlldyByZXR1cm5zIChib29sKVwiLFxuICBcImZ1bmN0aW9uIGFkZEFkbWluKGFkZHJlc3MgX25ld0FkbWluKSBleHRlcm5hbFwiLFxuICBcImZ1bmN0aW9uIHJlbW92ZUFkbWluKGFkZHJlc3MgX2FkbWluKSBleHRlcm5hbFwiXG5dO1xuXG5jb25zdCBDZXJ0aWZpY2F0ZXNBQkkgPSBbXG4gIFwiZnVuY3Rpb24gaXNzdWVDZXJ0aWZpY2F0ZShhZGRyZXNzIF9zdHVkZW50QWRkcmVzcywgc3RyaW5nIG1lbW9yeSBfaXBmc0hhc2gpIGV4dGVybmFsIHJldHVybnMgKGJ5dGVzMzIpXCIsXG4gIFwiZnVuY3Rpb24gZ2V0U3R1ZGVudENlcnRpZmljYXRlcyhhZGRyZXNzIF9zdHVkZW50KSBleHRlcm5hbCB2aWV3IHJldHVybnMgKGJ5dGVzMzJbXSlcIixcbiAgXCJmdW5jdGlvbiB2ZXJpZnlDZXJ0aWZpY2F0ZShieXRlczMyIF9jZXJ0aWZpY2F0ZUlkKSBleHRlcm5hbCB2aWV3IHJldHVybnMgKGFkZHJlc3Mgc3R1ZGVudCwgYWRkcmVzcyBpbnN0aXR1dGlvbiwgc3RyaW5nIGlwZnNIYXNoLCB1aW50MjU2IGlzc3VlZEF0LCBib29sIGlzVmFsaWQpXCJcbl07XG5cbi8vIENvbnRyYWN0IGFkZHJlc3NlcyBmcm9tIGNvbmZpZ1xuY29uc3QgSURFTlRJVFlfQ09OVFJBQ1RfQUREUkVTUyA9IGdldENvbmZpZygnSURFTlRJVFlfQ09OVFJBQ1RfQUREUkVTUycpO1xuY29uc3QgQ0VSVElGSUNBVEVTX0NPTlRSQUNUX0FERFJFU1MgPSBnZXRDb25maWcoJ0NFUlRJRklDQVRFU19DT05UUkFDVF9BRERSRVNTJyk7XG5jb25zdCBBRE1JTl9BRERSRVNTID0gZ2V0Q29uZmlnKCdBRE1JTl9BRERSRVNTJyk7XG5jb25zdCBFWEFNX01BTkFHRU1FTlRfQUREUkVTUyA9IGdldENvbmZpZygnRVhBTV9NQU5BR0VNRU5UX0NPTlRSQUNUX0FERFJFU1MnKTtcblxuLy8gVmFsaWRhdGUgZW52aXJvbm1lbnQgdmFyaWFibGVzXG5leHBvcnQgY29uc3QgdmFsaWRhdGVFbnYgPSAoKSA9PiB7XG4gIHRyeSB7XG4gICAgLy8g2KfZhNiq2K3ZgtmCINmF2YYg2LXYrdipINin2YTYqtmD2YjZitmGXG4gICAgdmFsaWRhdGVDb25maWcoKTtcblxuICAgIC8vINin2YTYqtit2YLZgiDZhdmGINi12K3YqSDYp9mE2LnZhtin2YjZitmGXG4gICAgaWYgKCFnZXRBZGRyZXNzKElERU5USVRZX0NPTlRSQUNUX0FERFJFU1MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgSWRlbnRpdHkgY29udHJhY3QgYWRkcmVzczogJHtJREVOVElUWV9DT05UUkFDVF9BRERSRVNTfWApO1xuICAgIH1cblxuICAgIGlmICghZ2V0QWRkcmVzcyhDRVJUSUZJQ0FURVNfQ09OVFJBQ1RfQUREUkVTUykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBDZXJ0aWZpY2F0ZXMgY29udHJhY3QgYWRkcmVzczogJHtDRVJUSUZJQ0FURVNfQ09OVFJBQ1RfQUREUkVTU31gKTtcbiAgICB9XG5cbiAgICBpZiAoIWdldEFkZHJlc3MoQURNSU5fQUREUkVTUykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBBZG1pbiBhZGRyZXNzOiAke0FETUlOX0FERFJFU1N9YCk7XG4gICAgfVxuXG4gICAgaWYgKCFnZXRBZGRyZXNzKEVYQU1fTUFOQUdFTUVOVF9BRERSRVNTKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEV4YW0gTWFuYWdlbWVudCBjb250cmFjdCBhZGRyZXNzOiAke0VYQU1fTUFOQUdFTUVOVF9BRERSRVNTfWApO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCdDb25maWd1cmF0aW9uIHZhbGlkYXRlZCBzdWNjZXNzZnVsbHk6Jywge1xuICAgICAgSURFTlRJVFlfQ09OVFJBQ1RfQUREUkVTUyxcbiAgICAgIENFUlRJRklDQVRFU19DT05UUkFDVF9BRERSRVNTLFxuICAgICAgQURNSU5fQUREUkVTUyxcbiAgICAgIEVYQU1fTUFOQUdFTUVOVF9BRERSRVNTLFxuICAgICAgQ0hBSU5fSUQ6IGdldENvbmZpZygnQ0hBSU5fSUQnKSxcbiAgICAgIE5FVFdPUktfVVJMOiBnZXRDb25maWcoJ05FVFdPUktfVVJMJylcbiAgICB9KTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0NvbmZpZ3VyYXRpb24gdmFsaWRhdGlvbiBmYWlsZWQ6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG4vLyBEZWJ1ZyBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbmNvbnNvbGUubG9nKCdFbnZpcm9ubWVudCB2YXJpYWJsZXMgY2hlY2s6Jywge1xuICBJREVOVElUWV9DT05UUkFDVF9BRERSRVNTLFxuICBDRVJUSUZJQ0FURVNfQ09OVFJBQ1RfQUREUkVTUyxcbiAgQURNSU5fQUREUkVTUyxcbiAgRVhBTV9NQU5BR0VNRU5UX0FERFJFU1MsXG4gIENIQUlOX0lEOiBFWFBFQ1RFRF9ORVRXT1JLLmNoYWluSWQsXG4gIE5FVFdPUktfVVJMOiBFWFBFQ1RFRF9ORVRXT1JLLnJwY1VybFxufSk7XG5cbi8vIFJvbGUgbWFwcGluZyB3aXRoIHByb3BlciB0eXBlc1xuY29uc3QgVVNFUl9ST0xFUyA9IHtcbiAgTk9ORTogMCxcbiAgU1RVREVOVDogMSxcbiAgSU5TVElUVVRJT046IDIsXG4gIEVNUExPWUVSOiAzLFxuICBBRE1JTjogNFxufSBhcyBjb25zdDtcblxudHlwZSBSb2xlVmFsdWUgPSB0eXBlb2YgVVNFUl9ST0xFU1trZXlvZiB0eXBlb2YgVVNFUl9ST0xFU107XG50eXBlIFJvbGVTdHJpbmcgPSAnbm9uZScgfCAnc3R1ZGVudCcgfCAnaW5zdGl0dXRpb24nIHwgJ2VtcGxveWVyJyB8ICdhZG1pbic7XG5cbmNvbnN0IHJvbGVNYXA6IFJlY29yZDxSb2xlVmFsdWUsIFJvbGVTdHJpbmc+ID0ge1xuICBbVVNFUl9ST0xFUy5OT05FXTogJ25vbmUnLFxuICBbVVNFUl9ST0xFUy5TVFVERU5UXTogJ3N0dWRlbnQnLFxuICBbVVNFUl9ST0xFUy5JTlNUSVRVVElPTl06ICdpbnN0aXR1dGlvbicsXG4gIFtVU0VSX1JPTEVTLkVNUExPWUVSXTogJ2VtcGxveWVyJyxcbiAgW1VTRVJfUk9MRVMuQURNSU5dOiAnYWRtaW4nXG59O1xuXG5leHBvcnQgY29uc3QgZ2V0Q29udHJhY3RzID0gYXN5bmMgKCkgPT4ge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCdDb250cmFjdCBBZGRyZXNzZXM6Jywge1xuICAgICAgSWRlbnRpdHk6IElERU5USVRZX0NPTlRSQUNUX0FERFJFU1MsXG4gICAgICBDZXJ0aWZpY2F0ZXM6IENFUlRJRklDQVRFU19DT05UUkFDVF9BRERSRVNTLFxuICAgICAgQWRtaW46IEFETUlOX0FERFJFU1NcbiAgICB9KTtcblxuICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgZ2V0UHJvdmlkZXIoKTtcbiAgICBhd2FpdCB2YWxpZGF0ZU5ldHdvcmsocHJvdmlkZXIpO1xuICAgIGNvbnNvbGUubG9nKCdOZXR3b3JrIHZhbGlkYXRpb24gcGFzc2VkJyk7XG4gICAgXG4gICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgZ2V0U2lnbmVyKCk7XG4gICAgY29uc3QgdXNlckFkZHJlc3MgPSBhd2FpdCBzaWduZXIuZ2V0QWRkcmVzcygpO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKCdDb25uZWN0ZWQgd2l0aCBhZGRyZXNzOicsIHVzZXJBZGRyZXNzKTtcbiAgICBcbiAgICBjb25zdCB1c2VyQmFsYW5jZSA9IGF3YWl0IHByb3ZpZGVyLmdldEJhbGFuY2UodXNlckFkZHJlc3MpO1xuICAgIGNvbnNvbGUubG9nKCdVc2VyIGJhbGFuY2U6JywgZm9ybWF0VW5pdHModXNlckJhbGFuY2UsICdldGhlcicpLCAnRVRIJyk7XG4gICAgXG4gICAgY29uc3QgaWRlbnRpdHlDb250cmFjdCA9IG5ldyBDb250cmFjdChcbiAgICAgIElERU5USVRZX0NPTlRSQUNUX0FERFJFU1MhLFxuICAgICAgSWRlbnRpdHlBQkksXG4gICAgICBzaWduZXJcbiAgICApO1xuXG4gICAgY29uc29sZS5sb2coJ1ZlcmlmeWluZyBjb250cmFjdCBleGlzdHMgYXQgYWRkcmVzczonLCBJREVOVElUWV9DT05UUkFDVF9BRERSRVNTKTtcbiAgICBjb25zdCBjb2RlID0gYXdhaXQgcHJvdmlkZXIuZ2V0Q29kZShJREVOVElUWV9DT05UUkFDVF9BRERSRVNTISk7XG4gICAgY29uc29sZS5sb2coJ0NvbnRyYWN0IGNvZGUgbGVuZ3RoOicsIGNvZGUubGVuZ3RoKTtcbiAgICBjb25zb2xlLmxvZygnQ29udHJhY3QgZXhpc3RzOicsIGNvZGUgIT09ICcweCcpO1xuICAgIFxuICAgIGlmIChjb2RlID09PSAnMHgnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYElkZW50aXR5IGNvbnRyYWN0IG5vdCBmb3VuZCBhdCBhZGRyZXNzOiAke0lERU5USVRZX0NPTlRSQUNUX0FERFJFU1N9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgY2VydGlmaWNhdGVzQ29udHJhY3QgPSBuZXcgQ29udHJhY3QoXG4gICAgICBDRVJUSUZJQ0FURVNfQ09OVFJBQ1RfQUREUkVTUyEsXG4gICAgICBDZXJ0aWZpY2F0ZXNBQkksXG4gICAgICBzaWduZXJcbiAgICApO1xuXG4gICAgY29uc3QgZXhhbU1hbmFnZW1lbnRDb250cmFjdCA9IG5ldyBDb250cmFjdChcbiAgICAgIEVYQU1fTUFOQUdFTUVOVF9BRERSRVNTISxcbiAgICAgIEV4YW1NYW5hZ2VtZW50QUJJLFxuICAgICAgc2lnbmVyXG4gICAgKTtcblxuICAgIHJldHVybiB7IGlkZW50aXR5Q29udHJhY3QsIGNlcnRpZmljYXRlc0NvbnRyYWN0LCBleGFtTWFuYWdlbWVudENvbnRyYWN0LCBwcm92aWRlciwgc2lnbmVyIH07XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbml0aWFsaXppbmcgY29udHJhY3RzOicsIGVycm9yKTtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZXRhaWxzOicsIHtcbiAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICBjb2RlOiBlcnJvci5jb2RlLFxuICAgICAgcmVhc29uOiBlcnJvci5yZWFzb25cbiAgICB9KTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBpbml0aWFsaXplIGNvbnRyYWN0czogJHtlcnJvci5tZXNzYWdlfWApO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgcmVnaXN0ZXJVc2VyID0gYXN5bmMgKHJvbGU6IHN0cmluZykgPT4ge1xuICBpZiAoIXJvbGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JvbGUgaXMgcmVxdWlyZWQnKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgeyBpZGVudGl0eUNvbnRyYWN0LCBzaWduZXIgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xuICAgIFxuICAgIC8vIEdldCBuZXR3b3JrIGRldGFpbHMgYW5kIHVzZXIgYWRkcmVzc1xuICAgIGNvbnN0IHVzZXJBZGRyZXNzID0gYXdhaXQgc2lnbmVyLmdldEFkZHJlc3MoKTtcbiAgICBjb25zb2xlLmxvZygnUmVnaXN0ZXJpbmcgYWRkcmVzczonLCB1c2VyQWRkcmVzcyk7XG4gICAgY29uc29sZS5sb2coJ1dpdGggcm9sZTonLCByb2xlKTtcbiAgICBcbiAgICAvLyBTcGVjaWFsIGhhbmRsaW5nIGZvciBhZG1pbiBhZGRyZXNzXG4gICAgaWYgKEFETUlOX0FERFJFU1MgJiYgdXNlckFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gQURNSU5fQUREUkVTUy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICBjb25zb2xlLmxvZygnVGhpcyBpcyB0aGUgYWRtaW4gYWRkcmVzcywgc2V0dGluZyBhZG1pbiByb2xlLi4uJyk7XG4gICAgICByZXR1cm4gYXdhaXQgc2V0QWRtaW5Sb2xlKCk7XG4gICAgfVxuICAgIFxuICAgIC8vIENvbnZlcnQgcm9sZSBzdHJpbmcgdG8gZW51bSB2YWx1ZVxuICAgIGNvbnN0IHJvbGVNYXA6IHsgW2tleTogc3RyaW5nXTogbnVtYmVyIH0gPSB7XG4gICAgICAnc3R1ZGVudCc6IFVTRVJfUk9MRVMuU1RVREVOVCxcbiAgICAgICdpbnN0aXR1dGlvbic6IFVTRVJfUk9MRVMuSU5TVElUVVRJT04sXG4gICAgICAnZW1wbG95ZXInOiBVU0VSX1JPTEVTLkVNUExPWUVSLFxuICAgICAgJ2FkbWluJzogVVNFUl9ST0xFUy5BRE1JTlxuICAgIH07XG4gICAgXG4gICAgY29uc3Qgcm9sZVZhbHVlID0gcm9sZU1hcFtyb2xlLnRvTG93ZXJDYXNlKCldO1xuICAgIGlmIChyb2xlVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHJvbGU6ICR7cm9sZX0uIE11c3QgYmUgb25lIG9mOiBzdHVkZW50LCBpbnN0aXR1dGlvbiwgZW1wbG95ZXIsIGFkbWluYCk7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ1JvbGUgdmFsdWUgZnJvbSBtYXBwaW5nOicsIHJvbGVWYWx1ZSk7XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgdXNlciBpcyBhbHJlYWR5IHJlZ2lzdGVyZWRcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ0NoZWNraW5nIGlmIHVzZXIgYWxyZWFkeSBleGlzdHMuLi4nKTtcbiAgICAgIGNvbnN0IGV4aXN0aW5nUm9sZSA9IGF3YWl0IGlkZW50aXR5Q29udHJhY3QuZ2V0VXNlclJvbGUodXNlckFkZHJlc3MpO1xuICAgICAgY29uc29sZS5sb2coJ0V4aXN0aW5nIHJvbGU6JywgZXhpc3RpbmdSb2xlKTtcbiAgICAgIFxuICAgICAgaWYgKGV4aXN0aW5nUm9sZSA+IDApIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1VzZXIgYWxyZWFkeSByZWdpc3RlcmVkIHdpdGggcm9sZTonLCBleGlzdGluZ1JvbGUpO1xuICAgICAgICBcbiAgICAgICAgLy8gSWYgdXNlciBleGlzdHMgYnV0IG5lZWRzIHZlcmlmaWNhdGlvblxuICAgICAgICBjb25zdCBpc1ZlcmlmaWVkID0gYXdhaXQgaWRlbnRpdHlDb250cmFjdC5pc1ZlcmlmaWVkKHVzZXJBZGRyZXNzKTtcbiAgICAgICAgaWYgKCFpc1ZlcmlmaWVkKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1VzZXIgZXhpc3RzIGJ1dCBub3QgdmVyaWZpZWQsIGF0dGVtcHRpbmcgdmVyaWZpY2F0aW9uLi4uJyk7XG4gICAgICAgICAgY29uc3QgdmVyaWZ5VHggPSBhd2FpdCBpZGVudGl0eUNvbnRyYWN0LnZlcmlmeVVzZXIodXNlckFkZHJlc3MpO1xuICAgICAgICAgIGF3YWl0IHZlcmlmeVR4LndhaXQoKTtcbiAgICAgICAgICBjb25zb2xlLmxvZygnVXNlciB2ZXJpZmllZCBzdWNjZXNzZnVsbHknKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiAnZXhpc3RpbmcnLCByb2xlOiBleGlzdGluZ1JvbGUgfTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBpZiAoIWVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ1VzZXIgZG9lcyBub3QgZXhpc3QnKSkge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUubG9nKCdVc2VyIGRvZXMgbm90IGV4aXN0LCBwcm9jZWVkaW5nIHdpdGggcmVnaXN0cmF0aW9uJyk7XG4gICAgfVxuICAgIFxuICAgIC8vIFJlZ2lzdGVyIHVzZXJcbiAgICBjb25zb2xlLmxvZygnUmVnaXN0ZXJpbmcgbmV3IHVzZXIgd2l0aCByb2xlOicsIHJvbGVWYWx1ZSk7XG4gICAgY29uc3QgdHggPSBhd2FpdCBpZGVudGl0eUNvbnRyYWN0LnJlZ2lzdGVyVXNlcihyb2xlVmFsdWUsIFwiXCIpO1xuICAgIGNvbnNvbGUubG9nKCdSZWdpc3RyYXRpb24gdHJhbnNhY3Rpb24gc2VudDonLCB0eC5oYXNoKTtcbiAgICBcbiAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdHgud2FpdCgpO1xuICAgIGNvbnNvbGUubG9nKCdSZWdpc3RyYXRpb24gc3VjY2Vzc2Z1bDonLCByZWNlaXB0Lmhhc2gpO1xuICAgIFxuICAgIC8vIFZlcmlmeSB0aGUgdXNlciBhdXRvbWF0aWNhbGx5XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCdBdHRlbXB0aW5nIGF1dG9tYXRpYyB2ZXJpZmljYXRpb24uLi4nKTtcbiAgICAgIGNvbnN0IHZlcmlmeVR4ID0gYXdhaXQgaWRlbnRpdHlDb250cmFjdC52ZXJpZnlVc2VyKHVzZXJBZGRyZXNzKTtcbiAgICAgIGF3YWl0IHZlcmlmeVR4LndhaXQoKTtcbiAgICAgIGNvbnNvbGUubG9nKCdVc2VyIHZlcmlmaWVkIHN1Y2Nlc3NmdWxseScpO1xuICAgIH0gY2F0Y2ggKHZlcmlmeUVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0F1dG9tYXRpYyB2ZXJpZmljYXRpb24gZmFpbGVkOicsIHZlcmlmeUVycm9yKTtcbiAgICAgIC8vIENvbnRpbnVlIGV2ZW4gaWYgdmVyaWZpY2F0aW9uIGZhaWxzXG4gICAgfVxuICAgIFxuICAgIC8vIElmIHJlZ2lzdGVyaW5nIGFzIGFkbWluLCBzZXQgYWRtaW4gcm9sZVxuICAgIGlmIChyb2xlLnRvTG93ZXJDYXNlKCkgPT09ICdhZG1pbicpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdTZXR0aW5nIGFkbWluIHByaXZpbGVnZXMuLi4nKTtcbiAgICAgIGF3YWl0IHNldEFkbWluUm9sZSgpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4geyBzdGF0dXM6ICdzdWNjZXNzJywgcm9sZTogcm9sZVZhbHVlLCB0cmFuc2FjdGlvbjogdHggfTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIHJldHVybiBoYW5kbGVDb250cmFjdEVycm9yKGVycm9yKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHZlcmlmeVVzZXIgPSBhc3luYyAoYWRkcmVzczogc3RyaW5nKSA9PiB7XG4gIHRyeSB7XG4gICAgZ2V0QWRkcmVzcyhhZGRyZXNzKTsgLy8gVXNpbmcgZ2V0QWRkcmVzcyBpbnN0ZWFkIG9mIGlzQWRkcmVzc1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhZGRyZXNzJyk7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCdWZXJpZnlpbmcgdXNlcjonLCBhZGRyZXNzKTtcbiAgICBjb25zdCB7IGlkZW50aXR5Q29udHJhY3QgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xuICAgIGNvbnN0IGlzVmVyaWZpZWQgPSBhd2FpdCBpZGVudGl0eUNvbnRyYWN0LmlzVmVyaWZpZWQoYWRkcmVzcyk7XG4gICAgY29uc29sZS5sb2coJ1VzZXIgdmVyaWZpY2F0aW9uIHN0YXR1czonLCBpc1ZlcmlmaWVkKTtcbiAgICByZXR1cm4gaXNWZXJpZmllZDtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIHZlcmlmeVVzZXI6JywgZXJyb3IpO1xuICAgIHJldHVybiBoYW5kbGVDb250cmFjdEVycm9yKGVycm9yKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGdldFVzZXJSb2xlID0gYXN5bmMgKGFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8Um9sZVN0cmluZz4gPT4ge1xuICB0cnkge1xuICAgIGdldEFkZHJlc3MoYWRkcmVzcyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFkZHJlc3MnKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ0dldHRpbmcgdXNlciByb2xlIGZvcjonLCBhZGRyZXNzKTtcbiAgICBjb25zdCB7IGlkZW50aXR5Q29udHJhY3QgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xuICAgIGNvbnN0IHJvbGUgPSBhd2FpdCBpZGVudGl0eUNvbnRyYWN0LmdldFVzZXJSb2xlKGFkZHJlc3MpO1xuICAgIGNvbnNvbGUubG9nKCdVc2VyIHJvbGU6Jywgcm9sZSk7XG4gICAgcmV0dXJuIHJvbGU7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBnZXRVc2VyUm9sZTonLCBlcnJvcik7XG4gICAgcmV0dXJuIGhhbmRsZUNvbnRyYWN0RXJyb3IoZXJyb3IpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgaXNzdWVDZXJ0aWZpY2F0ZSA9IGFzeW5jIChzdHVkZW50QWRkcmVzczogc3RyaW5nLCBpcGZzSGFzaDogc3RyaW5nKSA9PiB7XG4gIGlmICghc3R1ZGVudEFkZHJlc3MgfHwgIWlwZnNIYXNoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTdHVkZW50IGFkZHJlc3MgYW5kIElQRlMgaGFzaCBhcmUgcmVxdWlyZWQnKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgeyBjZXJ0aWZpY2F0ZXNDb250cmFjdCB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XG4gICAgY29uc3QgdHggPSBhd2FpdCBjZXJ0aWZpY2F0ZXNDb250cmFjdC5pc3N1ZUNlcnRpZmljYXRlKHN0dWRlbnRBZGRyZXNzLCBpcGZzSGFzaCk7XG4gICAgYXdhaXQgdHgud2FpdCgpO1xuICAgIHJldHVybiB0eDtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGlzc3VpbmcgY2VydGlmaWNhdGU6JywgZXJyb3IpO1xuICAgIHJldHVybiBoYW5kbGVDb250cmFjdEVycm9yKGVycm9yKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHZlcmlmeUNlcnRpZmljYXRlID0gYXN5bmMgKGNlcnRpZmljYXRlSWQ6IHN0cmluZykgPT4ge1xuICBpZiAoIWNlcnRpZmljYXRlSWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NlcnRpZmljYXRlIElEIGlzIHJlcXVpcmVkJyk7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IHsgY2VydGlmaWNhdGVzQ29udHJhY3QgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xuICAgIGNvbnN0IGlzVmFsaWQgPSBhd2FpdCBjZXJ0aWZpY2F0ZXNDb250cmFjdC52ZXJpZnlDZXJ0aWZpY2F0ZShjZXJ0aWZpY2F0ZUlkKTtcbiAgICByZXR1cm4gaXNWYWxpZDtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHZlcmlmeWluZyBjZXJ0aWZpY2F0ZTonLCBlcnJvcik7XG4gICAgcmV0dXJuIGhhbmRsZUNvbnRyYWN0RXJyb3IoZXJyb3IpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0Q2VydGlmaWNhdGVzID0gYXN5bmMgKGFkZHJlc3M6IHN0cmluZykgPT4ge1xuICB0cnkge1xuICAgIGdldEFkZHJlc3MoYWRkcmVzcyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFkZHJlc3MnKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ0dldHRpbmcgY2VydGlmaWNhdGVzIGZvcjonLCBhZGRyZXNzKTtcbiAgICBjb25zdCB7IGNlcnRpZmljYXRlc0NvbnRyYWN0IH0gPSBhd2FpdCBnZXRDb250cmFjdHMoKTtcbiAgICBjb25zdCBjZXJ0aWZpY2F0ZXMgPSBhd2FpdCBjZXJ0aWZpY2F0ZXNDb250cmFjdC5nZXRDZXJ0aWZpY2F0ZXMoYWRkcmVzcyk7XG4gICAgY29uc29sZS5sb2coJ0NlcnRpZmljYXRlczonLCBjZXJ0aWZpY2F0ZXMpO1xuICAgIHJldHVybiBjZXJ0aWZpY2F0ZXM7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBnZXRDZXJ0aWZpY2F0ZXM6JywgZXJyb3IpO1xuICAgIHJldHVybiBoYW5kbGVDb250cmFjdEVycm9yKGVycm9yKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGlzVmVyaWZpZWRVc2VyID0gYXN5bmMgKGFkZHJlc3M6IHN0cmluZykgPT4ge1xuICB0cnkge1xuICAgIGdldEFkZHJlc3MoYWRkcmVzcyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFkZHJlc3MnKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ0NoZWNraW5nIGlmIHVzZXIgaXMgdmVyaWZpZWQ6JywgYWRkcmVzcyk7XG4gICAgY29uc3QgeyBpZGVudGl0eUNvbnRyYWN0IH0gPSBhd2FpdCBnZXRDb250cmFjdHMoKTtcbiAgICBjb25zdCBpc1ZlcmlmaWVkID0gYXdhaXQgaWRlbnRpdHlDb250cmFjdC5pc1ZlcmlmaWVkKGFkZHJlc3MpO1xuICAgIGNvbnNvbGUubG9nKCdVc2VyIHZlcmlmaWNhdGlvbiBzdGF0dXM6JywgaXNWZXJpZmllZCk7XG4gICAgcmV0dXJuIGlzVmVyaWZpZWQ7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBpc1ZlcmlmaWVkVXNlcjonLCBlcnJvcik7XG4gICAgcmV0dXJuIGhhbmRsZUNvbnRyYWN0RXJyb3IoZXJyb3IpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgaXNPd25lciA9IGFzeW5jIChhZGRyZXNzOiBzdHJpbmcpID0+IHtcbiAgdHJ5IHtcbiAgICBnZXRBZGRyZXNzKGFkZHJlc3MpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhZGRyZXNzJyk7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCdDaGVja2luZyBpZiB1c2VyIGlzIG93bmVyOicsIGFkZHJlc3MpO1xuICAgIGNvbnN0IHsgaWRlbnRpdHlDb250cmFjdCB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XG4gICAgY29uc3Qgb3duZXJBZGRyZXNzID0gYXdhaXQgaWRlbnRpdHlDb250cmFjdC5vd25lcigpO1xuICAgIGNvbnN0IGlzT3duZXJSb2xlID0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSBvd25lckFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zb2xlLmxvZygnVXNlciBvd25lciBzdGF0dXM6JywgaXNPd25lclJvbGUpO1xuICAgIHJldHVybiBpc093bmVyUm9sZTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGlzT3duZXI6JywgZXJyb3IpO1xuICAgIHJldHVybiBoYW5kbGVDb250cmFjdEVycm9yKGVycm9yKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHZlcmlmeUluc3RpdHV0aW9uID0gYXN5bmMgKGluc3RpdHV0aW9uQWRkcmVzczogc3RyaW5nKSA9PiB7XG4gIHRyeSB7XG4gICAgZ2V0QWRkcmVzcyhpbnN0aXR1dGlvbkFkZHJlc3MpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnN0aXR1dGlvbiBhZGRyZXNzJyk7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCdWZXJpZnlpbmcgaW5zdGl0dXRpb246JywgaW5zdGl0dXRpb25BZGRyZXNzKTtcbiAgICBjb25zdCB7IGlkZW50aXR5Q29udHJhY3QgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xuICAgIGNvbnN0IHR4ID0gYXdhaXQgaWRlbnRpdHlDb250cmFjdC52ZXJpZnlVc2VyKGluc3RpdHV0aW9uQWRkcmVzcyk7XG4gICAgYXdhaXQgdHgud2FpdCgpO1xuICAgIGNvbnNvbGUubG9nKCdJbnN0aXR1dGlvbiB2ZXJpZmllZCBzdWNjZXNzZnVsbHknKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIHZlcmlmeUluc3RpdHV0aW9uOicsIGVycm9yKTtcbiAgICByZXR1cm4gaGFuZGxlQ29udHJhY3RFcnJvcihlcnJvcik7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBnZXRPd25lckFkZHJlc3MgPSBhc3luYyAoKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBpZGVudGl0eUNvbnRyYWN0IH0gPSBhd2FpdCBnZXRDb250cmFjdHMoKTtcbiAgICBjb25zdCBvd25lciA9IGF3YWl0IGlkZW50aXR5Q29udHJhY3Qub3duZXIoKTtcbiAgICByZXR1cm4gb3duZXI7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIG93bmVyIGFkZHJlc3M6JywgZXJyb3IpO1xuICAgIHJldHVybiBoYW5kbGVDb250cmFjdEVycm9yKGVycm9yKTtcbiAgfVxufTtcblxuLy8gQWRkIGV4YW0gbWFuYWdlbWVudCBmdW5jdGlvbnNcbmV4cG9ydCBjb25zdCBjcmVhdGVFeGFtID0gYXN5bmMgKFxuICBpZDogc3RyaW5nLFxuICB0aXRsZTogc3RyaW5nLFxuICBkZXNjcmlwdGlvbjogc3RyaW5nLFxuICBkYXRlOiBudW1iZXIsXG4gIGR1cmF0aW9uOiBudW1iZXIsXG4gIGlwZnNIYXNoOiBzdHJpbmdcbikgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgZXhhbU1hbmFnZW1lbnRDb250cmFjdCB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XG4gICAgY29uc3QgdHggPSBhd2FpdCBleGFtTWFuYWdlbWVudENvbnRyYWN0LmNyZWF0ZUV4YW0oaWQsIHRpdGxlLCBkZXNjcmlwdGlvbiwgZGF0ZSwgZHVyYXRpb24sIGlwZnNIYXNoKTtcbiAgICBhd2FpdCB0eC53YWl0KCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBleGFtOicsIGVycm9yKTtcbiAgICByZXR1cm4gaGFuZGxlQ29udHJhY3RFcnJvcihlcnJvcik7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBzdWJtaXRFeGFtUmVzdWx0ID0gYXN5bmMgKFxuICBleGFtSWQ6IHN0cmluZyxcbiAgc3R1ZGVudDogc3RyaW5nLFxuICBzY29yZTogbnVtYmVyLFxuICBncmFkZTogc3RyaW5nLFxuICBpcGZzSGFzaDogc3RyaW5nXG4pID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGV4YW1NYW5hZ2VtZW50Q29udHJhY3QgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xuICAgIGNvbnN0IHR4ID0gYXdhaXQgZXhhbU1hbmFnZW1lbnRDb250cmFjdC5zdWJtaXRFeGFtUmVzdWx0KGV4YW1JZCwgc3R1ZGVudCwgc2NvcmUsIGdyYWRlLCBpcGZzSGFzaCk7XG4gICAgYXdhaXQgdHgud2FpdCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3Igc3VibWl0dGluZyBleGFtIHJlc3VsdDonLCBlcnJvcik7XG4gICAgcmV0dXJuIGhhbmRsZUNvbnRyYWN0RXJyb3IoZXJyb3IpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgdXBkYXRlRXhhbVN0YXR1cyA9IGFzeW5jIChleGFtSWQ6IHN0cmluZywgc3RhdHVzOiBzdHJpbmcpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGV4YW1NYW5hZ2VtZW50Q29udHJhY3QgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xuICAgIGNvbnN0IHR4ID0gYXdhaXQgZXhhbU1hbmFnZW1lbnRDb250cmFjdC51cGRhdGVFeGFtU3RhdHVzKGV4YW1JZCwgc3RhdHVzKTtcbiAgICBhd2FpdCB0eC53YWl0KCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBleGFtIHN0YXR1czonLCBlcnJvcik7XG4gICAgcmV0dXJuIGhhbmRsZUNvbnRyYWN0RXJyb3IoZXJyb3IpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0RXhhbSA9IGFzeW5jIChleGFtSWQ6IHN0cmluZykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgZXhhbU1hbmFnZW1lbnRDb250cmFjdCB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XG4gICAgY29uc3QgZXhhbSA9IGF3YWl0IGV4YW1NYW5hZ2VtZW50Q29udHJhY3QuZ2V0RXhhbShleGFtSWQpO1xuICAgIHJldHVybiBleGFtO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBleGFtOicsIGVycm9yKTtcbiAgICByZXR1cm4gaGFuZGxlQ29udHJhY3RFcnJvcihlcnJvcik7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBnZXRFeGFtUmVzdWx0ID0gYXN5bmMgKGV4YW1JZDogc3RyaW5nLCBzdHVkZW50OiBzdHJpbmcpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGV4YW1NYW5hZ2VtZW50Q29udHJhY3QgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV4YW1NYW5hZ2VtZW50Q29udHJhY3QuZ2V0RXhhbVJlc3VsdChleGFtSWQsIHN0dWRlbnQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIGV4YW0gcmVzdWx0OicsIGVycm9yKTtcbiAgICByZXR1cm4gaGFuZGxlQ29udHJhY3RFcnJvcihlcnJvcik7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBnZXRJbnN0aXR1dGlvbkV4YW1zID0gYXN5bmMgKGluc3RpdHV0aW9uOiBzdHJpbmcpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGV4YW1NYW5hZ2VtZW50Q29udHJhY3QgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xuICAgIGNvbnN0IGV4YW1zID0gYXdhaXQgZXhhbU1hbmFnZW1lbnRDb250cmFjdC5nZXRJbnN0aXR1dGlvbkV4YW1zKGluc3RpdHV0aW9uKTtcbiAgICByZXR1cm4gZXhhbXM7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIGluc3RpdHV0aW9uIGV4YW1zOicsIGVycm9yKTtcbiAgICByZXR1cm4gaGFuZGxlQ29udHJhY3RFcnJvcihlcnJvcik7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBnZXRTdHVkZW50RXhhbXMgPSBhc3luYyAoc3R1ZGVudDogc3RyaW5nKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBleGFtTWFuYWdlbWVudENvbnRyYWN0IH0gPSBhd2FpdCBnZXRDb250cmFjdHMoKTtcbiAgICBjb25zdCBleGFtcyA9IGF3YWl0IGV4YW1NYW5hZ2VtZW50Q29udHJhY3QuZ2V0U3R1ZGVudEV4YW1zKHN0dWRlbnQpO1xuICAgIHJldHVybiBleGFtcztcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgc3R1ZGVudCBleGFtczonLCBlcnJvcik7XG4gICAgcmV0dXJuIGhhbmRsZUNvbnRyYWN0RXJyb3IoZXJyb3IpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgZW5yb2xsU3R1ZGVudCA9IGFzeW5jIChleGFtSWQ6IHN0cmluZywgc3R1ZGVudEFkZHJlc3M6IHN0cmluZykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgZXhhbU1hbmFnZW1lbnRDb250cmFjdCB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XG4gICAgY29uc3QgdHggPSBhd2FpdCBleGFtTWFuYWdlbWVudENvbnRyYWN0LmVucm9sbFN0dWRlbnQoZXhhbUlkLCBzdHVkZW50QWRkcmVzcyk7XG4gICAgYXdhaXQgdHgud2FpdCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZW5yb2xsaW5nIHN0dWRlbnQ6JywgZXJyb3IpO1xuICAgIHJldHVybiBoYW5kbGVDb250cmFjdEVycm9yKGVycm9yKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGdldENvbnRyYWN0ID0gYXN5bmMgKCkgPT4ge1xuICBjb25zdCB7IGV4YW1NYW5hZ2VtZW50Q29udHJhY3QgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xuICByZXR1cm4gZXhhbU1hbmFnZW1lbnRDb250cmFjdDtcbn07XG5cbmV4cG9ydCBjb25zdCBzZXRBZG1pblJvbGUgPSBhc3luYyAoKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBpZGVudGl0eUNvbnRyYWN0LCBzaWduZXIgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xuICAgIGNvbnN0IHVzZXJBZGRyZXNzID0gYXdhaXQgc2lnbmVyLmdldEFkZHJlc3MoKTtcbiAgICBcbiAgICBjb25zb2xlLmxvZygnU2V0dGluZyBhZG1pbiByb2xlIGZvciBhZGRyZXNzOicsIHVzZXJBZGRyZXNzKTtcbiAgICBjb25zb2xlLmxvZygnRXhwZWN0ZWQgYWRtaW4gYWRkcmVzczonLCBBRE1JTl9BRERSRVNTKTtcbiAgICBcbiAgICAvLyBGaXJzdCBjaGVjayBpZiB0aGUgYWRkcmVzcyBpcyBhbHJlYWR5IGFuIGFkbWluXG4gICAgY29uc3QgaXNBZG1pbiA9IGF3YWl0IGlkZW50aXR5Q29udHJhY3QuaXNBZG1pbih1c2VyQWRkcmVzcyk7XG4gICAgY29uc29sZS5sb2coJ0lzIGFscmVhZHkgYWRtaW4/JywgaXNBZG1pbik7XG4gICAgXG4gICAgaWYgKGlzQWRtaW4pIHtcbiAgICAgIGNvbnNvbGUubG9nKCdVc2VyIGlzIGFscmVhZHkgYW4gYWRtaW4nKTtcbiAgICAgIHJldHVybiB7IHN0YXR1czogJ2V4aXN0aW5nJywgaXNBZG1pbjogdHJ1ZSB9O1xuICAgIH1cbiAgICBcbiAgICAvLyBDaGVjayBpZiB0aGlzIGlzIHRoZSBjb25maWd1cmVkIGFkbWluIGFkZHJlc3NcbiAgICBpZiAoQURNSU5fQUREUkVTUyAmJiB1c2VyQWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSBBRE1JTl9BRERSRVNTLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdBZGRyZXNzIG1hdGNoZXMgY29uZmlndXJlZCBhZG1pbiwgYWRkaW5nIGFzIGFkbWluLi4uJyk7XG4gICAgICBcbiAgICAgIC8vIEZpcnN0IHRyeSB0byByZWdpc3RlciBhcyBhZG1pbiBpZiBub3QgYWxyZWFkeSByZWdpc3RlcmVkXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByb2xlID0gYXdhaXQgaWRlbnRpdHlDb250cmFjdC5nZXRVc2VyUm9sZSh1c2VyQWRkcmVzcyk7XG4gICAgICAgIGlmIChyb2xlID09PSAwKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1JlZ2lzdGVyaW5nIGFkbWluIHVzZXIgZmlyc3QuLi4nKTtcbiAgICAgICAgICBjb25zdCByZWdUeCA9IGF3YWl0IGlkZW50aXR5Q29udHJhY3QucmVnaXN0ZXJVc2VyKFVTRVJfUk9MRVMuQURNSU4sIFwiXCIpO1xuICAgICAgICAgIGF3YWl0IHJlZ1R4LndhaXQoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICBpZiAoIWVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ1VzZXIgZG9lcyBub3QgZXhpc3QnKSkge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHVzZXIgZG9lc24ndCBleGlzdCwgcmVnaXN0ZXIgdGhlbSBhcyBhZG1pblxuICAgICAgICBjb25zb2xlLmxvZygnUmVnaXN0ZXJpbmcgbmV3IGFkbWluIHVzZXIuLi4nKTtcbiAgICAgICAgY29uc3QgcmVnVHggPSBhd2FpdCBpZGVudGl0eUNvbnRyYWN0LnJlZ2lzdGVyVXNlcihVU0VSX1JPTEVTLkFETUlOLCBcIlwiKTtcbiAgICAgICAgYXdhaXQgcmVnVHgud2FpdCgpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBWZXJpZnkgdGhlIHVzZXJcbiAgICAgIGNvbnNvbGUubG9nKCdWZXJpZnlpbmcgYWRtaW4gdXNlci4uLicpO1xuICAgICAgY29uc3QgdmVyaWZ5VHggPSBhd2FpdCBpZGVudGl0eUNvbnRyYWN0LnZlcmlmeVVzZXIodXNlckFkZHJlc3MpO1xuICAgICAgYXdhaXQgdmVyaWZ5VHgud2FpdCgpO1xuICAgICAgXG4gICAgICAvLyBBZGQgYWRtaW4gcm9sZVxuICAgICAgY29uc29sZS5sb2coJ0FkZGluZyBhZG1pbiByb2xlLi4uJyk7XG4gICAgICBjb25zdCB0eCA9IGF3YWl0IGlkZW50aXR5Q29udHJhY3QuYWRkQWRtaW4odXNlckFkZHJlc3MpO1xuICAgICAgYXdhaXQgdHgud2FpdCgpO1xuICAgICAgY29uc29sZS5sb2coJ1N1Y2Nlc3NmdWxseSBhZGRlZCBhcyBhZG1pbicpO1xuICAgICAgXG4gICAgICByZXR1cm4geyBzdGF0dXM6ICdzdWNjZXNzJywgaXNBZG1pbjogdHJ1ZSB9O1xuICAgIH1cbiAgICBcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgY29uZmlndXJlZCBhZG1pbiBhZGRyZXNzZXMgY2FuIGJlIHNldCBhcyBhZG1pbicpO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3Igc2V0dGluZyBhZG1pbiByb2xlOicsIGVycm9yKTtcbiAgICByZXR1cm4gaGFuZGxlQ29udHJhY3RFcnJvcihlcnJvcik7XG4gIH1cbn07ICJdLCJuYW1lcyI6WyJDb250cmFjdCIsImZvcm1hdFVuaXRzIiwiZ2V0QWRkcmVzcyIsIkV4YW1NYW5hZ2VtZW50QUJJIiwiZ2V0UHJvdmlkZXIiLCJnZXRTaWduZXIiLCJFWFBFQ1RFRF9ORVRXT1JLIiwidmFsaWRhdGVOZXR3b3JrIiwiaGFuZGxlQ29udHJhY3RFcnJvciIsImdldENvbmZpZyIsInZhbGlkYXRlQ29uZmlnIiwiSWRlbnRpdHlBQkkiLCJDZXJ0aWZpY2F0ZXNBQkkiLCJJREVOVElUWV9DT05UUkFDVF9BRERSRVNTIiwiQ0VSVElGSUNBVEVTX0NPTlRSQUNUX0FERFJFU1MiLCJBRE1JTl9BRERSRVNTIiwiRVhBTV9NQU5BR0VNRU5UX0FERFJFU1MiLCJ2YWxpZGF0ZUVudiIsIkVycm9yIiwiY29uc29sZSIsImxvZyIsIkNIQUlOX0lEIiwiTkVUV09SS19VUkwiLCJlcnJvciIsImNoYWluSWQiLCJycGNVcmwiLCJVU0VSX1JPTEVTIiwiTk9ORSIsIlNUVURFTlQiLCJJTlNUSVRVVElPTiIsIkVNUExPWUVSIiwiQURNSU4iLCJyb2xlTWFwIiwiZ2V0Q29udHJhY3RzIiwiSWRlbnRpdHkiLCJDZXJ0aWZpY2F0ZXMiLCJBZG1pbiIsInByb3ZpZGVyIiwic2lnbmVyIiwidXNlckFkZHJlc3MiLCJ1c2VyQmFsYW5jZSIsImdldEJhbGFuY2UiLCJpZGVudGl0eUNvbnRyYWN0IiwiY29kZSIsImdldENvZGUiLCJsZW5ndGgiLCJjZXJ0aWZpY2F0ZXNDb250cmFjdCIsImV4YW1NYW5hZ2VtZW50Q29udHJhY3QiLCJtZXNzYWdlIiwicmVhc29uIiwicmVnaXN0ZXJVc2VyIiwicm9sZSIsInRvTG93ZXJDYXNlIiwic2V0QWRtaW5Sb2xlIiwicm9sZVZhbHVlIiwidW5kZWZpbmVkIiwiZXhpc3RpbmdSb2xlIiwiZ2V0VXNlclJvbGUiLCJpc1ZlcmlmaWVkIiwidmVyaWZ5VHgiLCJ2ZXJpZnlVc2VyIiwid2FpdCIsInN0YXR1cyIsImluY2x1ZGVzIiwidHgiLCJoYXNoIiwicmVjZWlwdCIsInZlcmlmeUVycm9yIiwid2FybiIsInRyYW5zYWN0aW9uIiwiYWRkcmVzcyIsImlzc3VlQ2VydGlmaWNhdGUiLCJzdHVkZW50QWRkcmVzcyIsImlwZnNIYXNoIiwidmVyaWZ5Q2VydGlmaWNhdGUiLCJjZXJ0aWZpY2F0ZUlkIiwiaXNWYWxpZCIsImdldENlcnRpZmljYXRlcyIsImNlcnRpZmljYXRlcyIsImlzVmVyaWZpZWRVc2VyIiwiaXNPd25lciIsIm93bmVyQWRkcmVzcyIsIm93bmVyIiwiaXNPd25lclJvbGUiLCJ2ZXJpZnlJbnN0aXR1dGlvbiIsImluc3RpdHV0aW9uQWRkcmVzcyIsImdldE93bmVyQWRkcmVzcyIsImNyZWF0ZUV4YW0iLCJpZCIsInRpdGxlIiwiZGVzY3JpcHRpb24iLCJkYXRlIiwiZHVyYXRpb24iLCJzdWJtaXRFeGFtUmVzdWx0IiwiZXhhbUlkIiwic3R1ZGVudCIsInNjb3JlIiwiZ3JhZGUiLCJ1cGRhdGVFeGFtU3RhdHVzIiwiZ2V0RXhhbSIsImV4YW0iLCJnZXRFeGFtUmVzdWx0IiwicmVzdWx0IiwiZ2V0SW5zdGl0dXRpb25FeGFtcyIsImluc3RpdHV0aW9uIiwiZXhhbXMiLCJnZXRTdHVkZW50RXhhbXMiLCJlbnJvbGxTdHVkZW50IiwiZ2V0Q29udHJhY3QiLCJpc0FkbWluIiwicmVnVHgiLCJhZGRBZG1pbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./utilsFront/contracts.ts\n"));

/***/ }),

/***/ "./utils/config.ts":
/*!*************************!*\
  !*** ./utils/config.ts ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CONFIG: function() { return /* binding */ CONFIG; },\n/* harmony export */   getConfig: function() { return /* binding */ getConfig; },\n/* harmony export */   validateConfig: function() { return /* binding */ validateConfig; }\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/process/browser.js\");\n// تكوين ثابت للنظام\nconst CONFIG = {\n    ADMIN_ADDRESS: \"0x2C84aE14df11a456a8aE48793a3C5989Bf9D5ab4\",\n    NETWORK_URL: \"http://127.0.0.1:7545\",\n    CHAIN_ID: \"1337\",\n    SECURITY_UTILS_CONTRACT_ADDRESS: \"0xCaACAB1FA696347532070E8c82B4CBa4dc4Dc21b\",\n    IDENTITY_CONTRACT_ADDRESS: \"0xbEBcD3099b6766b4224f0624887616E099E4dCb4\",\n    CERTIFICATES_CONTRACT_ADDRESS: \"0x82Ba41429a7ff6e503707c4E62b8073A39d6C98d\",\n    EXAMINATIONS_CONTRACT_ADDRESS: \"0x1E3cc1831e2910A1C25b49AA47977Ba3aac629Ec\",\n    EXAM_MANAGEMENT_CONTRACT_ADDRESS: \"0xA82719824037C6e51eED8616d96F874E4fa19B91\"\n};\n// وظيفة للحصول على قيمة التكوين\nconst getConfig = (key)=>{\n    // محاولة الحصول على القيمة من متغيرات البيئة أولاً\n    const envValue = process.env[\"NEXT_PUBLIC_\".concat(key)] || process.env[key];\n    // إذا لم يتم العثور على القيمة في متغيرات البيئة، استخدم القيمة الثابتة\n    return envValue || CONFIG[key];\n};\n// وظيفة للتحقق من صحة التكوين\nconst validateConfig = ()=>{\n    const missingKeys = [];\n    Object.keys(CONFIG).forEach((key)=>{\n        const value = getConfig(key);\n        if (!value) {\n            missingKeys.push(key);\n        }\n    });\n    if (missingKeys.length > 0) {\n        throw new Error(\"Missing configuration values for: \".concat(missingKeys.join(\", \")));\n    }\n    return true;\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi91dGlscy9jb25maWcudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLG9CQUFvQjtBQUNiLE1BQU1BLFNBQVM7SUFDcEJDLGVBQWU7SUFDZkMsYUFBYTtJQUNiQyxVQUFVO0lBQ1ZDLGlDQUFpQztJQUNqQ0MsMkJBQTJCO0lBQzNCQywrQkFBK0I7SUFDL0JDLCtCQUErQjtJQUMvQkMsa0NBQWtDO0FBQ3BDLEVBQUU7QUFFRixnQ0FBZ0M7QUFDekIsTUFBTUMsWUFBWSxDQUFDQztJQUN4QixtREFBbUQ7SUFDbkQsTUFBTUMsV0FBV0MsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDLGVBQW1CLE9BQUpILEtBQU0sSUFBSUUsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDSCxJQUFJO0lBRXRFLHdFQUF3RTtJQUN4RSxPQUFPQyxZQUFZWCxNQUFNLENBQUNVLElBQUk7QUFDaEMsRUFBRTtBQUVGLDhCQUE4QjtBQUN2QixNQUFNSSxpQkFBaUI7SUFDNUIsTUFBTUMsY0FBd0IsRUFBRTtJQUVoQ0MsT0FBT0MsSUFBSSxDQUFDakIsUUFBUWtCLE9BQU8sQ0FBQyxDQUFDUjtRQUMzQixNQUFNUyxRQUFRVixVQUFVQztRQUN4QixJQUFJLENBQUNTLE9BQU87WUFDVkosWUFBWUssSUFBSSxDQUFDVjtRQUNuQjtJQUNGO0lBRUEsSUFBSUssWUFBWU0sTUFBTSxHQUFHLEdBQUc7UUFDMUIsTUFBTSxJQUFJQyxNQUFNLHFDQUE0RCxPQUF2QlAsWUFBWVEsSUFBSSxDQUFDO0lBQ3hFO0lBRUEsT0FBTztBQUNULEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vdXRpbHMvY29uZmlnLnRzPzBiMWMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8g2KrZg9mI2YrZhiDYq9in2KjYqiDZhNmE2YbYuNin2YVcbmV4cG9ydCBjb25zdCBDT05GSUcgPSB7XG4gIEFETUlOX0FERFJFU1M6ICcweDJDODRhRTE0ZGYxMWE0NTZhOGFFNDg3OTNhM0M1OTg5QmY5RDVhYjQnLFxuICBORVRXT1JLX1VSTDogJ2h0dHA6Ly8xMjcuMC4wLjE6NzU0NScsXG4gIENIQUlOX0lEOiAnMTMzNycsXG4gIFNFQ1VSSVRZX1VUSUxTX0NPTlRSQUNUX0FERFJFU1M6ICcweENhQUNBQjFGQTY5NjM0NzUzMjA3MEU4YzgyQjRDQmE0ZGM0RGMyMWInLFxuICBJREVOVElUWV9DT05UUkFDVF9BRERSRVNTOiAnMHhiRUJjRDMwOTliNjc2NmI0MjI0ZjA2MjQ4ODc2MTZFMDk5RTRkQ2I0JyxcbiAgQ0VSVElGSUNBVEVTX0NPTlRSQUNUX0FERFJFU1M6ICcweDgyQmE0MTQyOWE3ZmY2ZTUwMzcwN2M0RTYyYjgwNzNBMzlkNkM5OGQnLFxuICBFWEFNSU5BVElPTlNfQ09OVFJBQ1RfQUREUkVTUzogJzB4MUUzY2MxODMxZTI5MTBBMUMyNWI0OUFBNDc5NzdCYTNhYWM2MjlFYycsXG4gIEVYQU1fTUFOQUdFTUVOVF9DT05UUkFDVF9BRERSRVNTOiAnMHhBODI3MTk4MjQwMzdDNmU1MWVFRDg2MTZkOTZGODc0RTRmYTE5QjkxJ1xufTtcblxuLy8g2YjYuNmK2YHYqSDZhNmE2K3YtdmI2YQg2LnZhNmJINmC2YrZhdipINin2YTYqtmD2YjZitmGXG5leHBvcnQgY29uc3QgZ2V0Q29uZmlnID0gKGtleToga2V5b2YgdHlwZW9mIENPTkZJRyk6IHN0cmluZyA9PiB7XG4gIC8vINmF2K3Yp9mI2YTYqSDYp9mE2K3YtdmI2YQg2LnZhNmJINin2YTZgtmK2YXYqSDZhdmGINmF2KrYutmK2LHYp9iqINin2YTYqNmK2KbYqSDYo9mI2YTYp9mLXG4gIGNvbnN0IGVudlZhbHVlID0gcHJvY2Vzcy5lbnZbYE5FWFRfUFVCTElDXyR7a2V5fWBdIHx8IHByb2Nlc3MuZW52W2tleV07XG4gIFxuICAvLyDYpdiw2Kcg2YTZhSDZitiq2YUg2KfZhNi52KvZiNixINi52YTZiSDYp9mE2YLZitmF2Kkg2YHZiiDZhdiq2LrZitix2KfYqiDYp9mE2KjZitim2KnYjCDYp9iz2KrYrtiv2YUg2KfZhNmC2YrZhdipINin2YTYq9in2KjYqtipXG4gIHJldHVybiBlbnZWYWx1ZSB8fCBDT05GSUdba2V5XTtcbn07XG5cbi8vINmI2LjZitmB2Kkg2YTZhNiq2K3ZgtmCINmF2YYg2LXYrdipINin2YTYqtmD2YjZitmGXG5leHBvcnQgY29uc3QgdmFsaWRhdGVDb25maWcgPSAoKSA9PiB7XG4gIGNvbnN0IG1pc3NpbmdLZXlzOiBzdHJpbmdbXSA9IFtdO1xuICBcbiAgT2JqZWN0LmtleXMoQ09ORklHKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IGdldENvbmZpZyhrZXkgYXMga2V5b2YgdHlwZW9mIENPTkZJRyk7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgbWlzc2luZ0tleXMucHVzaChrZXkpO1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKG1pc3NpbmdLZXlzLmxlbmd0aCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgY29uZmlndXJhdGlvbiB2YWx1ZXMgZm9yOiAke21pc3NpbmdLZXlzLmpvaW4oJywgJyl9YCk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07ICJdLCJuYW1lcyI6WyJDT05GSUciLCJBRE1JTl9BRERSRVNTIiwiTkVUV09SS19VUkwiLCJDSEFJTl9JRCIsIlNFQ1VSSVRZX1VUSUxTX0NPTlRSQUNUX0FERFJFU1MiLCJJREVOVElUWV9DT05UUkFDVF9BRERSRVNTIiwiQ0VSVElGSUNBVEVTX0NPTlRSQUNUX0FERFJFU1MiLCJFWEFNSU5BVElPTlNfQ09OVFJBQ1RfQUREUkVTUyIsIkVYQU1fTUFOQUdFTUVOVF9DT05UUkFDVF9BRERSRVNTIiwiZ2V0Q29uZmlnIiwia2V5IiwiZW52VmFsdWUiLCJwcm9jZXNzIiwiZW52IiwidmFsaWRhdGVDb25maWciLCJtaXNzaW5nS2V5cyIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwidmFsdWUiLCJwdXNoIiwibGVuZ3RoIiwiRXJyb3IiLCJqb2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./utils/config.ts\n"));

/***/ })

});