"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/dashboard/institution",{

/***/ "./hooks/useInstitution.ts":
/*!*********************************!*\
  !*** ./hooks/useInstitution.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useInstitution: function() { return /* binding */ useInstitution; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/.pnpm/react@18.3.1/node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _chakra_ui_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @chakra-ui/react */ \"./node_modules/.pnpm/@chakra-ui+react@2.10.7_@emotion+react@11.14.0_@types+react@18.3.20_react@18.3.1__@emotion+st_tgigla7qwzpx5vn3b6i2n35rga/node_modules/@chakra-ui/react/dist/esm/index.mjs\");\n/* harmony import */ var _utilsFront_contracts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utilsFront/contracts */ \"./utilsFront/contracts.ts\");\n/* harmony import */ var wagmi__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! wagmi */ \"./node_modules/.pnpm/wagmi@2.14.16_@tanstack+query-core@5.72.1_@tanstack+react-query@5.72.1_react@18.3.1__@types+r_hsye2nxu5nhyzf2bv6ii4shl2e/node_modules/wagmi/dist/esm/exports/index.js\");\n/* harmony import */ var _useContract__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./useContract */ \"./hooks/useContract.ts\");\n\n\n\n\n\n// Add type for local storage\nconst INSTITUTION_STORAGE_KEY = \"institution_data\";\nconst EXAMS_STORAGE_KEY = \"institution_exams\";\nconst CERTIFICATES_STORAGE_KEY = \"institution_certificates\";\nconst useInstitution = ()=>{\n    const { examManagementContract, certificatesContract, isInitialized: contractsInitialized, isLoading: contractsLoading } = (0,_useContract__WEBPACK_IMPORTED_MODULE_2__.useContract)();\n    const { address = undefined, isConnected = false } = (0,wagmi__WEBPACK_IMPORTED_MODULE_3__.useAccount)() || {};\n    const toast = (0,_chakra_ui_react__WEBPACK_IMPORTED_MODULE_4__.useToast)();\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [isInitialized, setIsInitialized] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [initializationAttempts, setInitializationAttempts] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [institution, setInstitution] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [exams, setExams] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [certificates, setCertificates] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [hasAccess, setHasAccess] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [selectedExamResults, setSelectedExamResults] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [examStatistics, setExamStatistics] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const checkAccess = async (userAddress)=>{\n        console.log(\"[CheckAccess] Starting access check for:\", userAddress);\n        if (!examManagementContract) {\n            console.error(\"[CheckAccess] Contract not initialized\");\n            toast({\n                title: \"Error\",\n                description: \"Contract not initialized. Please try again.\",\n                status: \"error\"\n            });\n            return false;\n        }\n        try {\n            console.log(\"[CheckAccess] Checking if address is institution...\");\n            const isInstitutionResult = await examManagementContract.isInstitution(userAddress);\n            console.log(\"[CheckAccess] isInstitution result:\", isInstitutionResult);\n            if (!isInstitutionResult) {\n                console.log(\"[CheckAccess] Address is not registered as institution\");\n                toast({\n                    title: \"Error\",\n                    description: \"Address is not registered as an institution\",\n                    status: \"error\"\n                });\n                return false;\n            }\n            console.log(\"[CheckAccess] Getting institution data...\");\n            const institutionData = await examManagementContract.getInstitution(userAddress);\n            console.log(\"[CheckAccess] Institution data:\", institutionData);\n            if (!institutionData || institutionData.length < 10) {\n                console.error(\"[CheckAccess] Invalid institution data received\");\n                toast({\n                    title: \"Error\",\n                    description: \"Invalid institution data\",\n                    status: \"error\"\n                });\n                return false;\n            }\n            const isVerified = Boolean(institutionData[9]);\n            console.log(\"[CheckAccess] Institution verification status:\", isVerified);\n            if (!isVerified) {\n                toast({\n                    title: \"Error\",\n                    description: \"Institution is not verified\",\n                    status: \"error\"\n                });\n                return false;\n            }\n            console.log(\"[CheckAccess] Access granted\");\n            return true;\n        } catch (error) {\n            console.error(\"[CheckAccess] Error checking access:\", error);\n            toast({\n                title: \"Error\",\n                description: \"Error checking institution access\",\n                status: \"error\"\n            });\n            return false;\n        }\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let isMounted = true;\n        let initTimeout;\n        const initializeData = async ()=>{\n            try {\n                const initState = {\n                    isConnected,\n                    hasAddress: !!address,\n                    hasExamContract: !!examManagementContract,\n                    hasCertificatesContract: !!certificatesContract,\n                    contractsInitialized,\n                    contractsLoading,\n                    attempts: initializationAttempts\n                };\n                console.log(\"Institution initialization state:\", initState);\n                if (!isConnected || !address) {\n                    console.log(\"Not connected or no address available\");\n                    if (isMounted) {\n                        setIsLoading(false);\n                        setHasAccess(false);\n                        setIsInitialized(false);\n                    }\n                    return;\n                }\n                // Wait for contracts to finish loading\n                if (contractsLoading) {\n                    console.log(\"Contracts are still loading...\");\n                    return;\n                }\n                // Check contract initialization\n                if (!examManagementContract || !certificatesContract || !contractsInitialized) {\n                    console.error(\"Contract initialization check failed:\", {\n                        hasExamContract: !!examManagementContract,\n                        hasCertificatesContract: !!certificatesContract,\n                        isInitialized: contractsInitialized\n                    });\n                    if (isMounted) {\n                        setIsLoading(false);\n                        setHasAccess(false);\n                        setIsInitialized(false);\n                        // Retry initialization if under max attempts\n                        if (initializationAttempts < 3) {\n                            console.log(\"Scheduling retry attempt \".concat(initializationAttempts + 1, \"/3...\"));\n                            initTimeout = setTimeout(()=>{\n                                setInitializationAttempts((prev)=>prev + 1);\n                            }, 2000 * (initializationAttempts + 1)); // Exponential backoff\n                        } else {\n                            console.error(\"Max initialization attempts reached\");\n                            toast({\n                                title: \"خطأ في تهيئة العقود | Contract Initialization Error\",\n                                description: \"فشل في تهيئة العقود بعد عدة محاولات. يرجى التأكد من اتصال المحفظة والشبكة الصحيحة | Failed to initialize contracts after several attempts. Please check your wallet connection and network.\",\n                                status: \"error\",\n                                duration: 5000,\n                                isClosable: true\n                            });\n                        }\n                    }\n                    return;\n                }\n                // Reset attempts on successful initialization\n                if (initializationAttempts > 0) {\n                    setInitializationAttempts(0);\n                }\n                if (isMounted) {\n                    setIsLoading(true);\n                }\n                // Check access first\n                const accessGranted = await checkAccess(address);\n                console.log(\"Access check result:\", accessGranted);\n                if (!isMounted) return;\n                setHasAccess(accessGranted);\n                if (!accessGranted) {\n                    setIsLoading(false);\n                    setIsInitialized(false);\n                    return;\n                }\n                // Load data only if access is granted\n                const [institutionData, examsData, certificatesData] = await Promise.all([\n                    loadInstitutionFromContract(address),\n                    loadExamsFromContract(address),\n                    loadCertificatesFromContract(address)\n                ]);\n                if (!isMounted) return;\n                if (institutionData) {\n                    setInstitution(institutionData);\n                    setIsInitialized(true);\n                } else {\n                    console.error(\"Failed to load institution data\");\n                    setIsInitialized(false);\n                }\n                if (examsData) {\n                    setExams(examsData);\n                }\n                if (certificatesData) {\n                    setCertificates(certificatesData);\n                }\n            } catch (error) {\n                console.error(\"Critical initialization error:\", {\n                    error: error instanceof Error ? {\n                        name: error.name,\n                        message: error.message,\n                        stack: error.stack\n                    } : \"Unknown error\",\n                    state: {\n                        address,\n                        contractStatus: {\n                            hasExamContract: !!examManagementContract,\n                            hasCertificatesContract: !!certificatesContract,\n                            isInitialized: contractsInitialized,\n                            isLoading: contractsLoading\n                        }\n                    }\n                });\n                if (isMounted) {\n                    setIsInitialized(false);\n                    setHasAccess(false);\n                    toast({\n                        title: \"خطأ في تهيئة البيانات | Data Initialization Error\",\n                        description: error instanceof Error ? \"\".concat(error.message, \" | يرجى المحاولة مرة أخرى\") : \"حدث خطأ غير معروف | An unknown error occurred\",\n                        status: \"error\",\n                        duration: 5000,\n                        isClosable: true\n                    });\n                }\n            } finally{\n                if (isMounted) {\n                    setIsLoading(false);\n                }\n            }\n        };\n        initializeData();\n        return ()=>{\n            isMounted = false;\n            if (initTimeout) {\n                clearTimeout(initTimeout);\n            }\n        };\n    }, [\n        isConnected,\n        address,\n        examManagementContract,\n        certificatesContract,\n        contractsInitialized,\n        contractsLoading,\n        initializationAttempts,\n        toast\n    ]);\n    // Helper functions with proper type checking\n    const loadInstitutionFromContract = async (userAddress)=>{\n        if (!examManagementContract || !userAddress) return null;\n        try {\n            const data = await examManagementContract.getInstitution(userAddress);\n            return {\n                name: data.name,\n                ministry: data.ministry,\n                university: data.university,\n                college: data.college,\n                description: data.description,\n                imageUrl: data.imageUrl,\n                website: data.website,\n                email: data.email,\n                phone: data.phone\n            };\n        } catch (error) {\n            console.error(\"Error loading institution:\", error);\n            return null;\n        }\n    };\n    const loadExamsFromContract = async (userAddress)=>{\n        if (!examManagementContract || !userAddress) {\n            return [];\n        }\n        try {\n            return await examManagementContract.getInstitutionExams(userAddress);\n        } catch (error) {\n            console.error(\"Error loading exams:\", error);\n            return [];\n        }\n    };\n    const loadCertificatesFromContract = async (userAddress)=>{\n        if (!certificatesContract || !userAddress) {\n            return [];\n        }\n        try {\n            return await certificatesContract.getInstitutionCertificates(userAddress);\n        } catch (error) {\n            console.error(\"Error loading certificates:\", error);\n            return [];\n        }\n    };\n    const createExam = async (exam)=>{\n        if (!address) {\n            toast({\n                title: \"خطأ في العنوان | Address Error\",\n                description: \"لم يتم العثور على عنوان المحفظة | Wallet address not found\",\n                status: \"error\",\n                duration: 3000\n            });\n            return false;\n        }\n        try {\n            setIsLoading(true);\n            const contract = await (0,_utilsFront_contracts__WEBPACK_IMPORTED_MODULE_1__.getContract)();\n            const tx = await contract.createExam(exam.title, exam.description, exam.date);\n            await tx.wait();\n            await loadExamsFromContract(address);\n            return true;\n        } catch (err) {\n            console.error(\"Error creating exam:\", err);\n            toast({\n                title: \"Error creating exam\",\n                description: err instanceof Error ? err.message : \"An unknown error occurred\",\n                status: \"error\",\n                duration: 3000\n            });\n            return false;\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    const updateExamStatus = async (examId, status)=>{\n        if (!address) {\n            toast({\n                title: \"خطأ في العنوان | Address Error\",\n                description: \"لم يتم العثور على عنوان المحفظة | Wallet address not found\",\n                status: \"error\",\n                duration: 3000\n            });\n            return false;\n        }\n        try {\n            setIsLoading(true);\n            const contract = await (0,_utilsFront_contracts__WEBPACK_IMPORTED_MODULE_1__.getContract)();\n            const tx = await contract.updateExamStatus(examId, status);\n            await tx.wait();\n            await loadExamsFromContract(address);\n            return true;\n        } catch (err) {\n            console.error(\"Error updating exam status:\", err);\n            toast({\n                title: \"Error updating exam status\",\n                description: err instanceof Error ? err.message : \"An unknown error occurred\",\n                status: \"error\",\n                duration: 3000\n            });\n            return false;\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    const registerStudents = async (examId, students)=>{\n        try {\n            setIsLoading(true);\n            const contract = await (0,_utilsFront_contracts__WEBPACK_IMPORTED_MODULE_1__.getContract)();\n            const tx = await contract.registerStudents(examId, students);\n            await tx.wait();\n            return true;\n        } catch (err) {\n            console.error(\"Error registering students:\", err);\n            toast({\n                title: \"Error registering students\",\n                description: err instanceof Error ? err.message : \"An unknown error occurred\",\n                status: \"error\",\n                duration: 3000\n            });\n            return false;\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    const handleSubmitResults = async (examId, results)=>{\n        try {\n            setIsLoading(true);\n            const contract = await (0,_utilsFront_contracts__WEBPACK_IMPORTED_MODULE_1__.getContract)();\n            const tx = await contract.submitResults(examId, results);\n            await tx.wait();\n            await loadExamResults(examId);\n            toast({\n                title: \"تم إضافة النتائج بنجاح | Results submitted successfully\",\n                status: \"success\",\n                duration: 3000\n            });\n            return true;\n        } catch (err) {\n            console.error(\"Error submitting results:\", err);\n            toast({\n                title: \"حدث خطأ | Error occurred\",\n                description: err instanceof Error ? err.message : \"An unknown error occurred\",\n                status: \"error\",\n                duration: 3000\n            });\n            return false;\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    const loadExamResults = async (examId)=>{\n        try {\n            const currentExam = exams.find((exam)=>exam.id === examId);\n            if (!currentExam) {\n                throw new Error(\"Exam not found\");\n            }\n            const examResultsList = await Promise.all(currentExam.students.map(async (studentId)=>{\n                try {\n                    const result = await (0,_utilsFront_contracts__WEBPACK_IMPORTED_MODULE_1__.getExamResult)(examId, studentId);\n                    return result;\n                } catch (e) {\n                    return null;\n                }\n            }));\n            const validResults = examResultsList.filter((result)=>result !== null);\n            setSelectedExamResults(validResults);\n            if (validResults.length === 0) {\n                setExamStatistics(null);\n                return;\n            }\n            // Calculate statistics\n            const totalStudents = validResults.length;\n            const passingStudents = validResults.filter((result)=>result.score >= 60).length;\n            const totalScore = validResults.reduce((sum, result)=>sum + result.score, 0);\n            const gradeCount = {\n                A: validResults.filter((result)=>result.grade === \"A\").length,\n                B: validResults.filter((result)=>result.grade === \"B\").length,\n                C: validResults.filter((result)=>result.grade === \"C\").length,\n                D: validResults.filter((result)=>result.grade === \"D\").length,\n                F: validResults.filter((result)=>result.grade === \"F\").length\n            };\n            const mostCommonGrade = Object.entries(gradeCount).reduce((a, b)=>a[1] > b[1] ? a : b)[0];\n            setExamStatistics({\n                totalStudents,\n                passingCount: passingStudents,\n                aCount: gradeCount.A,\n                bCount: gradeCount.B,\n                cCount: gradeCount.C,\n                dCount: gradeCount.D,\n                fCount: gradeCount.F,\n                averageScore: totalScore / totalStudents,\n                passRate: passingStudents * 100 / totalStudents,\n                mostCommonGrade\n            });\n        } catch (err) {\n            console.error(\"Error loading exam results:\", err);\n            toast({\n                title: \"Error loading results\",\n                description: err instanceof Error ? err.message : \"An unknown error occurred\",\n                status: \"error\",\n                duration: 3000\n            });\n        }\n    };\n    const handleEnrollStudent = async (examId, studentAddress)=>{\n        if (!address) {\n            toast({\n                title: \"خطأ في العنوان | Address Error\",\n                description: \"لم يتم العثور على عنوان المحفظة | Wallet address not found\",\n                status: \"error\",\n                duration: 3000\n            });\n            return false;\n        }\n        try {\n            setIsLoading(true);\n            await (0,_utilsFront_contracts__WEBPACK_IMPORTED_MODULE_1__.enrollStudent)(examId, studentAddress);\n            toast({\n                title: \"Student enrolled successfully\",\n                status: \"success\",\n                duration: 3000\n            });\n            await loadExamsFromContract(address);\n            return true;\n        } catch (err) {\n            console.error(\"Error enrolling student:\", err);\n            toast({\n                title: \"Error enrolling student\",\n                description: err instanceof Error ? err.message : \"An unknown error occurred\",\n                status: \"error\",\n                duration: 3000\n            });\n            return false;\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    const issueCertificate = async (studentAddress, certificate)=>{\n        if (!address) {\n            toast({\n                title: \"خطأ في العنوان | Address Error\",\n                description: \"لم يتم العثور على عنوان المحفظة | Wallet address not found\",\n                status: \"error\",\n                duration: 3000\n            });\n            return false;\n        }\n        try {\n            setIsLoading(true);\n            const contract = await (0,_utilsFront_contracts__WEBPACK_IMPORTED_MODULE_1__.getContract)();\n            const tx = await contract.issueCertificate(studentAddress, certificate.title, certificate.description);\n            await tx.wait();\n            await loadCertificatesFromContract(address);\n            toast({\n                title: \"Certificate issued successfully\",\n                status: \"success\",\n                duration: 3000\n            });\n            return true;\n        } catch (err) {\n            console.error(\"Error issuing certificate:\", err);\n            toast({\n                title: \"Error issuing certificate\",\n                description: err instanceof Error ? err.message : \"An unknown error occurred\",\n                status: \"error\",\n                duration: 3000\n            });\n            return false;\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    const saveInstitutionProfile = async (data)=>{\n        if (!examManagementContract || !address) {\n            throw new Error(\"Contract or address not available\");\n        }\n        // Validate required fields\n        if (!data.name || !data.ministry || !data.university || !data.college || !data.description || !data.imageUrl || !data.website || !data.email || !data.phone) {\n            throw new Error(\"جميع الحقول مطلوبة | All fields are required\");\n        }\n        try {\n            setIsLoading(true);\n            const tx = await examManagementContract.write.updateInstitutionProfile({\n                args: [\n                    data.name,\n                    data.ministry,\n                    data.university,\n                    data.college,\n                    data.description,\n                    data.imageUrl || \"\",\n                    data.website || \"\",\n                    data.email || \"\",\n                    data.phone || \"\"\n                ]\n            });\n            await tx.wait();\n            setInstitution(data);\n            toast({\n                title: \"تم الحفظ بنجاح | Saved Successfully\",\n                status: \"success\",\n                duration: 3000,\n                isClosable: true\n            });\n        } catch (error) {\n            console.error(\"Error saving institution profile:\", error);\n            toast({\n                title: \"خطأ في الحفظ | Error Saving\",\n                description: error instanceof Error ? error.message : \"An unknown error occurred\",\n                status: \"error\",\n                duration: 5000,\n                isClosable: true\n            });\n            throw error;\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    return {\n        institution,\n        exams,\n        certificates,\n        isLoading,\n        isInitialized,\n        hasAccess,\n        selectedExamResults,\n        examStatistics,\n        saveInstitutionProfile,\n        createExam,\n        updateExamStatus,\n        registerStudents,\n        handleSubmitResults,\n        handleEnrollStudent,\n        loadExamResults,\n        issueCertificate\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0FBQ0Msd0JBQXdCLENBQUM7Z0JBQ3JFQyxNQUFNO29CQUNKbkUsS0FBS04sSUFBSTtvQkFDVE0sS0FBS0MsUUFBUTtvQkFDYkQsS0FBS0UsVUFBVTtvQkFDZkYsS0FBS0csT0FBTztvQkFDWkgsS0FBS3BDLFdBQVc7b0JBQ2hCb0MsS0FBS0ksUUFBUSxJQUFJO29CQUNqQkosS0FBS0ssT0FBTyxJQUFJO29CQUNoQkwsS0FBS00sS0FBSyxJQUFJO29CQUNkTixLQUFLTyxLQUFLLElBQUk7aUJBQ2Y7WUFDSDtZQUNBLE1BQU1NLEdBQUdFLElBQUk7WUFDYnBFLGVBQWVxRDtZQUNmM0QsTUFBTTtnQkFDSnNCLE9BQU87Z0JBQ1BFLFFBQVE7Z0JBQ1JrQixVQUFVO2dCQUNWQyxZQUFZO1lBQ2Q7UUFDRixFQUFFLE9BQU90QixPQUFPO1lBQ2RGLFFBQVFFLEtBQUssQ0FBQyxxQ0FBcUNBO1lBQ25EckIsTUFBTTtnQkFDSnNCLE9BQU87Z0JBQ1BDLGFBQWFGLGlCQUFpQitCLFFBQVEvQixNQUFNaUMsT0FBTyxHQUFHO2dCQUN0RDlCLFFBQVE7Z0JBQ1JrQixVQUFVO2dCQUNWQyxZQUFZO1lBQ2Q7WUFDQSxNQUFNdEI7UUFDUixTQUFVO1lBQ1JwQixhQUFhO1FBQ2Y7SUFDRjtJQUVBLE9BQU87UUFDTEk7UUFDQUU7UUFDQUU7UUFDQWQ7UUFDQUY7UUFDQWtCO1FBQ0FFO1FBQ0FFO1FBQ0E0RztRQUNBdEQ7UUFDQU87UUFDQUU7UUFDQUU7UUFDQXVDO1FBQ0FwQztRQUNBc0M7SUFDRjtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vaG9va3MvdXNlSW5zdGl0dXRpb24udHM/ZmE3NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZVRvYXN0IH0gZnJvbSAnQGNoYWtyYS11aS9yZWFjdCc7XG5pbXBvcnQgeyB1c2VSb3V0ZXIgfSBmcm9tICduZXh0L3JvdXRlcic7XG5pbXBvcnQgeyBldGhlcnMgfSBmcm9tICdldGhlcnMnO1xuaW1wb3J0IHtcbiAgZ2V0VXNlclJvbGUsXG4gIGlzVmVyaWZpZWRVc2VyLFxuICBnZXRDZXJ0aWZpY2F0ZXMsXG4gIGdldEluc3RpdHV0aW9uRXhhbXMsXG4gIHVwZGF0ZUV4YW1TdGF0dXMsXG4gIHN1Ym1pdEV4YW1SZXN1bHQsXG4gIGdldEV4YW1SZXN1bHQsXG4gIGVucm9sbFN0dWRlbnQsXG4gIGNyZWF0ZUV4YW0sXG4gIGdldENvbnRyYWN0XG59IGZyb20gJy4uL3V0aWxzRnJvbnQvY29udHJhY3RzJztcbmltcG9ydCB7IHVwbG9hZFRvSVBGUywgZ2V0RnJvbUlQRlMgfSBmcm9tICcuLi91dGlscy9pcGZzJztcbmltcG9ydCB7IENlcnRpZmljYXRlLCBFeGFtLCBFeGFtUmVzdWx0LCBFeGFtU3RhdGlzdGljcywgTmV3RXhhbSB9IGZyb20gJy4uL3R5cGVzL2luc3RpdHV0aW9uJztcbmltcG9ydCB7IHVzZUFjY291bnQgfSBmcm9tICd3YWdtaSc7XG5pbXBvcnQgeyB1c2VDb250cmFjdCB9IGZyb20gJy4vdXNlQ29udHJhY3QnO1xuaW1wb3J0IHsgSW5zdGl0dXRpb25EYXRhIH0gZnJvbSAnLi4vY29tcG9uZW50cy9pbnN0aXR1dGlvbi9JbnN0aXR1dGlvblByb2ZpbGUnO1xuXG4vLyBBZGQgdHlwZSBmb3IgbG9jYWwgc3RvcmFnZVxuY29uc3QgSU5TVElUVVRJT05fU1RPUkFHRV9LRVkgPSAnaW5zdGl0dXRpb25fZGF0YSc7XG5jb25zdCBFWEFNU19TVE9SQUdFX0tFWSA9ICdpbnN0aXR1dGlvbl9leGFtcyc7XG5jb25zdCBDRVJUSUZJQ0FURVNfU1RPUkFHRV9LRVkgPSAnaW5zdGl0dXRpb25fY2VydGlmaWNhdGVzJztcblxuZXhwb3J0IGNvbnN0IHVzZUluc3RpdHV0aW9uID0gKCkgPT4ge1xuICBjb25zdCB7IFxuICAgIGV4YW1NYW5hZ2VtZW50Q29udHJhY3QsIFxuICAgIGNlcnRpZmljYXRlc0NvbnRyYWN0LCBcbiAgICBpc0luaXRpYWxpemVkOiBjb250cmFjdHNJbml0aWFsaXplZCxcbiAgICBpc0xvYWRpbmc6IGNvbnRyYWN0c0xvYWRpbmcgXG4gIH0gPSB1c2VDb250cmFjdCgpO1xuICBjb25zdCB7IGFkZHJlc3MgPSB1bmRlZmluZWQsIGlzQ29ubmVjdGVkID0gZmFsc2UgfSA9IHVzZUFjY291bnQoKSB8fCB7fTtcbiAgY29uc3QgdG9hc3QgPSB1c2VUb2FzdCgpO1xuICBcbiAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IHVzZVN0YXRlKHRydWUpO1xuICBjb25zdCBbaXNJbml0aWFsaXplZCwgc2V0SXNJbml0aWFsaXplZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtpbml0aWFsaXphdGlvbkF0dGVtcHRzLCBzZXRJbml0aWFsaXphdGlvbkF0dGVtcHRzXSA9IHVzZVN0YXRlKDApO1xuICBjb25zdCBbaW5zdGl0dXRpb24sIHNldEluc3RpdHV0aW9uXSA9IHVzZVN0YXRlPEluc3RpdHV0aW9uRGF0YSB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbZXhhbXMsIHNldEV4YW1zXSA9IHVzZVN0YXRlPEV4YW1bXT4oW10pO1xuICBjb25zdCBbY2VydGlmaWNhdGVzLCBzZXRDZXJ0aWZpY2F0ZXNdID0gdXNlU3RhdGU8Q2VydGlmaWNhdGVbXT4oW10pO1xuICBjb25zdCBbaGFzQWNjZXNzLCBzZXRIYXNBY2Nlc3NdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc2VsZWN0ZWRFeGFtUmVzdWx0cywgc2V0U2VsZWN0ZWRFeGFtUmVzdWx0c10gPSB1c2VTdGF0ZTxFeGFtUmVzdWx0W10+KFtdKTtcbiAgY29uc3QgW2V4YW1TdGF0aXN0aWNzLCBzZXRFeGFtU3RhdGlzdGljc10gPSB1c2VTdGF0ZTxFeGFtU3RhdGlzdGljcyB8IG51bGw+KG51bGwpO1xuXG4gIGNvbnN0IGNoZWNrQWNjZXNzID0gYXN5bmMgKHVzZXJBZGRyZXNzOiBzdHJpbmcpID0+IHtcbiAgICBjb25zb2xlLmxvZygnW0NoZWNrQWNjZXNzXSBTdGFydGluZyBhY2Nlc3MgY2hlY2sgZm9yOicsIHVzZXJBZGRyZXNzKTtcblxuICAgIGlmICghZXhhbU1hbmFnZW1lbnRDb250cmFjdCkge1xuICAgICAgY29uc29sZS5lcnJvcignW0NoZWNrQWNjZXNzXSBDb250cmFjdCBub3QgaW5pdGlhbGl6ZWQnKTtcbiAgICAgIHRvYXN0KHsgXG4gICAgICAgIHRpdGxlOiAnRXJyb3InLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ0NvbnRyYWN0IG5vdCBpbml0aWFsaXplZC4gUGxlYXNlIHRyeSBhZ2Fpbi4nLFxuICAgICAgICBzdGF0dXM6ICdlcnJvcidcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygnW0NoZWNrQWNjZXNzXSBDaGVja2luZyBpZiBhZGRyZXNzIGlzIGluc3RpdHV0aW9uLi4uJyk7XG4gICAgICBjb25zdCBpc0luc3RpdHV0aW9uUmVzdWx0ID0gYXdhaXQgZXhhbU1hbmFnZW1lbnRDb250cmFjdC5pc0luc3RpdHV0aW9uKHVzZXJBZGRyZXNzKTtcbiAgICAgIGNvbnNvbGUubG9nKCdbQ2hlY2tBY2Nlc3NdIGlzSW5zdGl0dXRpb24gcmVzdWx0OicsIGlzSW5zdGl0dXRpb25SZXN1bHQpO1xuXG4gICAgICBpZiAoIWlzSW5zdGl0dXRpb25SZXN1bHQpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1tDaGVja0FjY2Vzc10gQWRkcmVzcyBpcyBub3QgcmVnaXN0ZXJlZCBhcyBpbnN0aXR1dGlvbicpO1xuICAgICAgICB0b2FzdCh7IFxuICAgICAgICAgIHRpdGxlOiAnRXJyb3InLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnQWRkcmVzcyBpcyBub3QgcmVnaXN0ZXJlZCBhcyBhbiBpbnN0aXR1dGlvbicsXG4gICAgICAgICAgc3RhdHVzOiAnZXJyb3InXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKCdbQ2hlY2tBY2Nlc3NdIEdldHRpbmcgaW5zdGl0dXRpb24gZGF0YS4uLicpO1xuICAgICAgY29uc3QgaW5zdGl0dXRpb25EYXRhID0gYXdhaXQgZXhhbU1hbmFnZW1lbnRDb250cmFjdC5nZXRJbnN0aXR1dGlvbih1c2VyQWRkcmVzcyk7XG4gICAgICBjb25zb2xlLmxvZygnW0NoZWNrQWNjZXNzXSBJbnN0aXR1dGlvbiBkYXRhOicsIGluc3RpdHV0aW9uRGF0YSk7XG5cbiAgICAgIGlmICghaW5zdGl0dXRpb25EYXRhIHx8IGluc3RpdHV0aW9uRGF0YS5sZW5ndGggPCAxMCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdbQ2hlY2tBY2Nlc3NdIEludmFsaWQgaW5zdGl0dXRpb24gZGF0YSByZWNlaXZlZCcpO1xuICAgICAgICB0b2FzdCh7IFxuICAgICAgICAgIHRpdGxlOiAnRXJyb3InLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnSW52YWxpZCBpbnN0aXR1dGlvbiBkYXRhJyxcbiAgICAgICAgICBzdGF0dXM6ICdlcnJvcidcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaXNWZXJpZmllZCA9IEJvb2xlYW4oaW5zdGl0dXRpb25EYXRhWzldKTtcbiAgICAgIGNvbnNvbGUubG9nKCdbQ2hlY2tBY2Nlc3NdIEluc3RpdHV0aW9uIHZlcmlmaWNhdGlvbiBzdGF0dXM6JywgaXNWZXJpZmllZCk7XG5cbiAgICAgIGlmICghaXNWZXJpZmllZCkge1xuICAgICAgICB0b2FzdCh7IFxuICAgICAgICAgIHRpdGxlOiAnRXJyb3InLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnSW5zdGl0dXRpb24gaXMgbm90IHZlcmlmaWVkJyxcbiAgICAgICAgICBzdGF0dXM6ICdlcnJvcidcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coJ1tDaGVja0FjY2Vzc10gQWNjZXNzIGdyYW50ZWQnKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbQ2hlY2tBY2Nlc3NdIEVycm9yIGNoZWNraW5nIGFjY2VzczonLCBlcnJvcik7XG4gICAgICB0b2FzdCh7IFxuICAgICAgICB0aXRsZTogJ0Vycm9yJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdFcnJvciBjaGVja2luZyBpbnN0aXR1dGlvbiBhY2Nlc3MnLFxuICAgICAgICBzdGF0dXM6ICdlcnJvcidcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCBpc01vdW50ZWQgPSB0cnVlO1xuICAgIGxldCBpbml0VGltZW91dDogTm9kZUpTLlRpbWVvdXQ7XG5cbiAgICBjb25zdCBpbml0aWFsaXplRGF0YSA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGluaXRTdGF0ZSA9IHtcbiAgICAgICAgICBpc0Nvbm5lY3RlZCxcbiAgICAgICAgICBoYXNBZGRyZXNzOiAhIWFkZHJlc3MsXG4gICAgICAgICAgaGFzRXhhbUNvbnRyYWN0OiAhIWV4YW1NYW5hZ2VtZW50Q29udHJhY3QsXG4gICAgICAgICAgaGFzQ2VydGlmaWNhdGVzQ29udHJhY3Q6ICEhY2VydGlmaWNhdGVzQ29udHJhY3QsXG4gICAgICAgICAgY29udHJhY3RzSW5pdGlhbGl6ZWQsXG4gICAgICAgICAgY29udHJhY3RzTG9hZGluZyxcbiAgICAgICAgICBhdHRlbXB0czogaW5pdGlhbGl6YXRpb25BdHRlbXB0c1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnNvbGUubG9nKCdJbnN0aXR1dGlvbiBpbml0aWFsaXphdGlvbiBzdGF0ZTonLCBpbml0U3RhdGUpO1xuXG4gICAgICAgIGlmICghaXNDb25uZWN0ZWQgfHwgIWFkZHJlc3MpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnTm90IGNvbm5lY3RlZCBvciBubyBhZGRyZXNzIGF2YWlsYWJsZScpO1xuICAgICAgICAgIGlmIChpc01vdW50ZWQpIHtcbiAgICAgICAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgICBzZXRIYXNBY2Nlc3MoZmFsc2UpO1xuICAgICAgICAgICAgc2V0SXNJbml0aWFsaXplZChmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdhaXQgZm9yIGNvbnRyYWN0cyB0byBmaW5pc2ggbG9hZGluZ1xuICAgICAgICBpZiAoY29udHJhY3RzTG9hZGluZykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdDb250cmFjdHMgYXJlIHN0aWxsIGxvYWRpbmcuLi4nKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBjb250cmFjdCBpbml0aWFsaXphdGlvblxuICAgICAgICBpZiAoIWV4YW1NYW5hZ2VtZW50Q29udHJhY3QgfHwgIWNlcnRpZmljYXRlc0NvbnRyYWN0IHx8ICFjb250cmFjdHNJbml0aWFsaXplZCkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0NvbnRyYWN0IGluaXRpYWxpemF0aW9uIGNoZWNrIGZhaWxlZDonLCB7XG4gICAgICAgICAgICBoYXNFeGFtQ29udHJhY3Q6ICEhZXhhbU1hbmFnZW1lbnRDb250cmFjdCxcbiAgICAgICAgICAgIGhhc0NlcnRpZmljYXRlc0NvbnRyYWN0OiAhIWNlcnRpZmljYXRlc0NvbnRyYWN0LFxuICAgICAgICAgICAgaXNJbml0aWFsaXplZDogY29udHJhY3RzSW5pdGlhbGl6ZWRcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChpc01vdW50ZWQpIHtcbiAgICAgICAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgICBzZXRIYXNBY2Nlc3MoZmFsc2UpO1xuICAgICAgICAgICAgc2V0SXNJbml0aWFsaXplZChmYWxzZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFJldHJ5IGluaXRpYWxpemF0aW9uIGlmIHVuZGVyIG1heCBhdHRlbXB0c1xuICAgICAgICAgICAgaWYgKGluaXRpYWxpemF0aW9uQXR0ZW1wdHMgPCAzKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBTY2hlZHVsaW5nIHJldHJ5IGF0dGVtcHQgJHtpbml0aWFsaXphdGlvbkF0dGVtcHRzICsgMX0vMy4uLmApO1xuICAgICAgICAgICAgICBpbml0VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNldEluaXRpYWxpemF0aW9uQXR0ZW1wdHMocHJldiA9PiBwcmV2ICsgMSk7XG4gICAgICAgICAgICAgIH0sIDIwMDAgKiAoaW5pdGlhbGl6YXRpb25BdHRlbXB0cyArIDEpKTsgLy8gRXhwb25lbnRpYWwgYmFja29mZlxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignTWF4IGluaXRpYWxpemF0aW9uIGF0dGVtcHRzIHJlYWNoZWQnKTtcbiAgICAgICAgICAgICAgdG9hc3Qoe1xuICAgICAgICAgICAgICAgIHRpdGxlOiAn2K7Yt9ijINmB2Yog2KrZh9mK2KbYqSDYp9mE2LnZgtmI2K8gfCBDb250cmFjdCBJbml0aWFsaXphdGlvbiBFcnJvcicsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246ICfZgdi02YQg2YHZiiDYqtmH2YrYptipINin2YTYudmC2YjYryDYqNi52K8g2LnYr9ipINmF2K3Yp9mI2YTYp9iqLiDZitix2KzZiSDYp9mE2KrYo9mD2K8g2YXZhiDYp9iq2LXYp9mEINin2YTZhdit2YHYuNipINmI2KfZhNi02KjZg9ipINin2YTYtdit2YrYrdipIHwgRmFpbGVkIHRvIGluaXRpYWxpemUgY29udHJhY3RzIGFmdGVyIHNldmVyYWwgYXR0ZW1wdHMuIFBsZWFzZSBjaGVjayB5b3VyIHdhbGxldCBjb25uZWN0aW9uIGFuZCBuZXR3b3JrLicsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiA1MDAwLFxuICAgICAgICAgICAgICAgIGlzQ2xvc2FibGU6IHRydWUsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXNldCBhdHRlbXB0cyBvbiBzdWNjZXNzZnVsIGluaXRpYWxpemF0aW9uXG4gICAgICAgIGlmIChpbml0aWFsaXphdGlvbkF0dGVtcHRzID4gMCkge1xuICAgICAgICAgIHNldEluaXRpYWxpemF0aW9uQXR0ZW1wdHMoMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNNb3VudGVkKSB7XG4gICAgICAgICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgYWNjZXNzIGZpcnN0XG4gICAgICAgIGNvbnN0IGFjY2Vzc0dyYW50ZWQgPSBhd2FpdCBjaGVja0FjY2VzcyhhZGRyZXNzKTtcbiAgICAgICAgY29uc29sZS5sb2coJ0FjY2VzcyBjaGVjayByZXN1bHQ6JywgYWNjZXNzR3JhbnRlZCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoIWlzTW91bnRlZCkgcmV0dXJuO1xuICAgICAgICBcbiAgICAgICAgc2V0SGFzQWNjZXNzKGFjY2Vzc0dyYW50ZWQpO1xuXG4gICAgICAgIGlmICghYWNjZXNzR3JhbnRlZCkge1xuICAgICAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgc2V0SXNJbml0aWFsaXplZChmYWxzZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTG9hZCBkYXRhIG9ubHkgaWYgYWNjZXNzIGlzIGdyYW50ZWRcbiAgICAgICAgY29uc3QgW2luc3RpdHV0aW9uRGF0YSwgZXhhbXNEYXRhLCBjZXJ0aWZpY2F0ZXNEYXRhXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICBsb2FkSW5zdGl0dXRpb25Gcm9tQ29udHJhY3QoYWRkcmVzcyksXG4gICAgICAgICAgbG9hZEV4YW1zRnJvbUNvbnRyYWN0KGFkZHJlc3MpLFxuICAgICAgICAgIGxvYWRDZXJ0aWZpY2F0ZXNGcm9tQ29udHJhY3QoYWRkcmVzcylcbiAgICAgICAgXSk7XG5cbiAgICAgICAgaWYgKCFpc01vdW50ZWQpIHJldHVybjtcblxuICAgICAgICBpZiAoaW5zdGl0dXRpb25EYXRhKSB7XG4gICAgICAgICAgc2V0SW5zdGl0dXRpb24oaW5zdGl0dXRpb25EYXRhKTtcbiAgICAgICAgICBzZXRJc0luaXRpYWxpemVkKHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBsb2FkIGluc3RpdHV0aW9uIGRhdGEnKTtcbiAgICAgICAgICBzZXRJc0luaXRpYWxpemVkKGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleGFtc0RhdGEpIHtcbiAgICAgICAgICBzZXRFeGFtcyhleGFtc0RhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNlcnRpZmljYXRlc0RhdGEpIHtcbiAgICAgICAgICBzZXRDZXJ0aWZpY2F0ZXMoY2VydGlmaWNhdGVzRGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignQ3JpdGljYWwgaW5pdGlhbGl6YXRpb24gZXJyb3I6Jywge1xuICAgICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8ge1xuICAgICAgICAgICAgbmFtZTogZXJyb3IubmFtZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICBzdGFjazogZXJyb3Iuc3RhY2tcbiAgICAgICAgICB9IDogJ1Vua25vd24gZXJyb3InLFxuICAgICAgICAgIHN0YXRlOiB7XG4gICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgY29udHJhY3RTdGF0dXM6IHtcbiAgICAgICAgICAgICAgaGFzRXhhbUNvbnRyYWN0OiAhIWV4YW1NYW5hZ2VtZW50Q29udHJhY3QsXG4gICAgICAgICAgICAgIGhhc0NlcnRpZmljYXRlc0NvbnRyYWN0OiAhIWNlcnRpZmljYXRlc0NvbnRyYWN0LFxuICAgICAgICAgICAgICBpc0luaXRpYWxpemVkOiBjb250cmFjdHNJbml0aWFsaXplZCxcbiAgICAgICAgICAgICAgaXNMb2FkaW5nOiBjb250cmFjdHNMb2FkaW5nXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGlmIChpc01vdW50ZWQpIHtcbiAgICAgICAgICBzZXRJc0luaXRpYWxpemVkKGZhbHNlKTtcbiAgICAgICAgICBzZXRIYXNBY2Nlc3MoZmFsc2UpO1xuICAgICAgICAgIHRvYXN0KHtcbiAgICAgICAgICAgIHRpdGxlOiAn2K7Yt9ijINmB2Yog2KrZh9mK2KbYqSDYp9mE2KjZitin2YbYp9iqIHwgRGF0YSBJbml0aWFsaXphdGlvbiBFcnJvcicsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciBcbiAgICAgICAgICAgICAgPyBgJHtlcnJvci5tZXNzYWdlfSB8INmK2LHYrNmJINin2YTZhdit2KfZiNmE2Kkg2YXYsdipINij2K7YsdmJYCBcbiAgICAgICAgICAgICAgOiAn2K3Yr9irINiu2LfYoyDYutmK2LEg2YXYudix2YjZgSB8IEFuIHVua25vd24gZXJyb3Igb2NjdXJyZWQnLFxuICAgICAgICAgICAgc3RhdHVzOiAnZXJyb3InLFxuICAgICAgICAgICAgZHVyYXRpb246IDUwMDAsXG4gICAgICAgICAgICBpc0Nsb3NhYmxlOiB0cnVlLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoaXNNb3VudGVkKSB7XG4gICAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpbml0aWFsaXplRGF0YSgpO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlzTW91bnRlZCA9IGZhbHNlO1xuICAgICAgaWYgKGluaXRUaW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dChpbml0VGltZW91dCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW1xuICAgIGlzQ29ubmVjdGVkLCBcbiAgICBhZGRyZXNzLCBcbiAgICBleGFtTWFuYWdlbWVudENvbnRyYWN0LCBcbiAgICBjZXJ0aWZpY2F0ZXNDb250cmFjdCwgXG4gICAgY29udHJhY3RzSW5pdGlhbGl6ZWQsXG4gICAgY29udHJhY3RzTG9hZGluZyxcbiAgICBpbml0aWFsaXphdGlvbkF0dGVtcHRzLFxuICAgIHRvYXN0XG4gIF0pO1xuXG4gIC8vIEhlbHBlciBmdW5jdGlvbnMgd2l0aCBwcm9wZXIgdHlwZSBjaGVja2luZ1xuICBjb25zdCBsb2FkSW5zdGl0dXRpb25Gcm9tQ29udHJhY3QgPSBhc3luYyAodXNlckFkZHJlc3M6IGAweCR7c3RyaW5nfWApOiBQcm9taXNlPEluc3RpdHV0aW9uRGF0YSB8IG51bGw+ID0+IHtcbiAgICBpZiAoIWV4YW1NYW5hZ2VtZW50Q29udHJhY3QgfHwgIXVzZXJBZGRyZXNzKSByZXR1cm4gbnVsbDtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgZXhhbU1hbmFnZW1lbnRDb250cmFjdC5nZXRJbnN0aXR1dGlvbih1c2VyQWRkcmVzcyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBkYXRhLm5hbWUsXG4gICAgICAgIG1pbmlzdHJ5OiBkYXRhLm1pbmlzdHJ5LFxuICAgICAgICB1bml2ZXJzaXR5OiBkYXRhLnVuaXZlcnNpdHksXG4gICAgICAgIGNvbGxlZ2U6IGRhdGEuY29sbGVnZSxcbiAgICAgICAgZGVzY3JpcHRpb246IGRhdGEuZGVzY3JpcHRpb24sXG4gICAgICAgIGltYWdlVXJsOiBkYXRhLmltYWdlVXJsLFxuICAgICAgICB3ZWJzaXRlOiBkYXRhLndlYnNpdGUsXG4gICAgICAgIGVtYWlsOiBkYXRhLmVtYWlsLFxuICAgICAgICBwaG9uZTogZGF0YS5waG9uZSxcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgaW5zdGl0dXRpb246JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGxvYWRFeGFtc0Zyb21Db250cmFjdCA9IGFzeW5jICh1c2VyQWRkcmVzczogYDB4JHtzdHJpbmd9YCk6IFByb21pc2U8RXhhbVtdPiA9PiB7XG4gICAgaWYgKCFleGFtTWFuYWdlbWVudENvbnRyYWN0IHx8ICF1c2VyQWRkcmVzcykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgZXhhbU1hbmFnZW1lbnRDb250cmFjdC5nZXRJbnN0aXR1dGlvbkV4YW1zKHVzZXJBZGRyZXNzKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBleGFtczonLCBlcnJvcik7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGxvYWRDZXJ0aWZpY2F0ZXNGcm9tQ29udHJhY3QgPSBhc3luYyAodXNlckFkZHJlc3M6IGAweCR7c3RyaW5nfWApOiBQcm9taXNlPENlcnRpZmljYXRlW10+ID0+IHtcbiAgICBpZiAoIWNlcnRpZmljYXRlc0NvbnRyYWN0IHx8ICF1c2VyQWRkcmVzcykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgY2VydGlmaWNhdGVzQ29udHJhY3QuZ2V0SW5zdGl0dXRpb25DZXJ0aWZpY2F0ZXModXNlckFkZHJlc3MpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIGNlcnRpZmljYXRlczonLCBlcnJvcik7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGNyZWF0ZUV4YW0gPSBhc3luYyAoZXhhbTogTmV3RXhhbSk6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xuICAgIGlmICghYWRkcmVzcykge1xuICAgICAgdG9hc3Qoe1xuICAgICAgICB0aXRsZTogJ9iu2LfYoyDZgdmKINin2YTYudmG2YjYp9mGIHwgQWRkcmVzcyBFcnJvcicsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAn2YTZhSDZitiq2YUg2KfZhNi52KvZiNixINi52YTZiSDYudmG2YjYp9mGINin2YTZhdit2YHYuNipIHwgV2FsbGV0IGFkZHJlc3Mgbm90IGZvdW5kJyxcbiAgICAgICAgc3RhdHVzOiAnZXJyb3InLFxuICAgICAgICBkdXJhdGlvbjogMzAwMCxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgICBjb25zdCBjb250cmFjdCA9IGF3YWl0IGdldENvbnRyYWN0KCk7XG4gICAgICBjb25zdCB0eCA9IGF3YWl0IGNvbnRyYWN0LmNyZWF0ZUV4YW0oZXhhbS50aXRsZSwgZXhhbS5kZXNjcmlwdGlvbiwgZXhhbS5kYXRlKTtcbiAgICAgIGF3YWl0IHR4LndhaXQoKTtcbiAgICAgIGF3YWl0IGxvYWRFeGFtc0Zyb21Db250cmFjdChhZGRyZXNzKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBleGFtOicsIGVycik7XG4gICAgICB0b2FzdCh7XG4gICAgICAgIHRpdGxlOiAnRXJyb3IgY3JlYXRpbmcgZXhhbScsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogJ0FuIHVua25vd24gZXJyb3Igb2NjdXJyZWQnLFxuICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgIGR1cmF0aW9uOiAzMDAwLFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHVwZGF0ZUV4YW1TdGF0dXMgPSBhc3luYyAoZXhhbUlkOiBzdHJpbmcsIHN0YXR1czogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiA9PiB7XG4gICAgaWYgKCFhZGRyZXNzKSB7XG4gICAgICB0b2FzdCh7XG4gICAgICAgIHRpdGxlOiAn2K7Yt9ijINmB2Yog2KfZhNi52YbZiNin2YYgfCBBZGRyZXNzIEVycm9yJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICfZhNmFINmK2KrZhSDYp9mE2LnYq9mI2LEg2LnZhNmJINi52YbZiNin2YYg2KfZhNmF2K3Zgdi42KkgfCBXYWxsZXQgYWRkcmVzcyBub3QgZm91bmQnLFxuICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgIGR1cmF0aW9uOiAzMDAwLFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICAgIGNvbnN0IGNvbnRyYWN0ID0gYXdhaXQgZ2V0Q29udHJhY3QoKTtcbiAgICAgIGNvbnN0IHR4ID0gYXdhaXQgY29udHJhY3QudXBkYXRlRXhhbVN0YXR1cyhleGFtSWQsIHN0YXR1cyk7XG4gICAgICBhd2FpdCB0eC53YWl0KCk7XG4gICAgICBhd2FpdCBsb2FkRXhhbXNGcm9tQ29udHJhY3QoYWRkcmVzcyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgZXhhbSBzdGF0dXM6JywgZXJyKTtcbiAgICAgIHRvYXN0KHtcbiAgICAgICAgdGl0bGU6ICdFcnJvciB1cGRhdGluZyBleGFtIHN0YXR1cycsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogJ0FuIHVua25vd24gZXJyb3Igb2NjdXJyZWQnLFxuICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgIGR1cmF0aW9uOiAzMDAwLFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHJlZ2lzdGVyU3R1ZGVudHMgPSBhc3luYyAoZXhhbUlkOiBzdHJpbmcsIHN0dWRlbnRzOiBzdHJpbmdbXSk6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xuICAgIHRyeSB7XG4gICAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgICBjb25zdCBjb250cmFjdCA9IGF3YWl0IGdldENvbnRyYWN0KCk7XG4gICAgICBjb25zdCB0eCA9IGF3YWl0IGNvbnRyYWN0LnJlZ2lzdGVyU3R1ZGVudHMoZXhhbUlkLCBzdHVkZW50cyk7XG4gICAgICBhd2FpdCB0eC53YWl0KCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVnaXN0ZXJpbmcgc3R1ZGVudHM6JywgZXJyKTtcbiAgICAgIHRvYXN0KHtcbiAgICAgICAgdGl0bGU6ICdFcnJvciByZWdpc3RlcmluZyBzdHVkZW50cycsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogJ0FuIHVua25vd24gZXJyb3Igb2NjdXJyZWQnLFxuICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgIGR1cmF0aW9uOiAzMDAwLFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGhhbmRsZVN1Ym1pdFJlc3VsdHMgPSBhc3luYyAoZXhhbUlkOiBzdHJpbmcsIHJlc3VsdHM6IEV4YW1SZXN1bHRbXSk6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xuICAgIHRyeSB7XG4gICAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgICBjb25zdCBjb250cmFjdCA9IGF3YWl0IGdldENvbnRyYWN0KCk7XG4gICAgICBjb25zdCB0eCA9IGF3YWl0IGNvbnRyYWN0LnN1Ym1pdFJlc3VsdHMoZXhhbUlkLCByZXN1bHRzKTtcbiAgICAgIGF3YWl0IHR4LndhaXQoKTtcbiAgICAgIGF3YWl0IGxvYWRFeGFtUmVzdWx0cyhleGFtSWQpO1xuICAgICAgdG9hc3Qoe1xuICAgICAgICB0aXRsZTogJ9iq2YUg2KXYttin2YHYqSDYp9mE2YbYqtin2KbYrCDYqNmG2KzYp9itIHwgUmVzdWx0cyBzdWJtaXR0ZWQgc3VjY2Vzc2Z1bGx5JyxcbiAgICAgICAgc3RhdHVzOiAnc3VjY2VzcycsXG4gICAgICAgIGR1cmF0aW9uOiAzMDAwLFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnI6IHVua25vd24pIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHN1Ym1pdHRpbmcgcmVzdWx0czonLCBlcnIpO1xuICAgICAgdG9hc3Qoe1xuICAgICAgICB0aXRsZTogJ9it2K/YqyDYrti32KMgfCBFcnJvciBvY2N1cnJlZCcsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogJ0FuIHVua25vd24gZXJyb3Igb2NjdXJyZWQnLFxuICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgIGR1cmF0aW9uOiAzMDAwLFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGxvYWRFeGFtUmVzdWx0cyA9IGFzeW5jIChleGFtSWQ6IHN0cmluZykgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjdXJyZW50RXhhbSA9IGV4YW1zLmZpbmQoZXhhbSA9PiBleGFtLmlkID09PSBleGFtSWQpO1xuICAgICAgaWYgKCFjdXJyZW50RXhhbSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4YW0gbm90IGZvdW5kJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGV4YW1SZXN1bHRzTGlzdCA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICBjdXJyZW50RXhhbS5zdHVkZW50cy5tYXAoYXN5bmMgKHN0dWRlbnRJZDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldEV4YW1SZXN1bHQoZXhhbUlkLCBzdHVkZW50SWQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHZhbGlkUmVzdWx0cyA9IGV4YW1SZXN1bHRzTGlzdC5maWx0ZXIoKHJlc3VsdCk6IHJlc3VsdCBpcyBFeGFtUmVzdWx0ID0+IHJlc3VsdCAhPT0gbnVsbCk7XG4gICAgICBzZXRTZWxlY3RlZEV4YW1SZXN1bHRzKHZhbGlkUmVzdWx0cyk7XG5cbiAgICAgIGlmICh2YWxpZFJlc3VsdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHNldEV4YW1TdGF0aXN0aWNzKG51bGwpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBzdGF0aXN0aWNzXG4gICAgICBjb25zdCB0b3RhbFN0dWRlbnRzID0gdmFsaWRSZXN1bHRzLmxlbmd0aDtcbiAgICAgIGNvbnN0IHBhc3NpbmdTdHVkZW50cyA9IHZhbGlkUmVzdWx0cy5maWx0ZXIocmVzdWx0ID0+IHJlc3VsdC5zY29yZSA+PSA2MCkubGVuZ3RoO1xuICAgICAgY29uc3QgdG90YWxTY29yZSA9IHZhbGlkUmVzdWx0cy5yZWR1Y2UoKHN1bSwgcmVzdWx0KSA9PiBzdW0gKyByZXN1bHQuc2NvcmUsIDApO1xuICAgICAgXG4gICAgICBjb25zdCBncmFkZUNvdW50ID0ge1xuICAgICAgICBBOiB2YWxpZFJlc3VsdHMuZmlsdGVyKHJlc3VsdCA9PiByZXN1bHQuZ3JhZGUgPT09ICdBJykubGVuZ3RoLFxuICAgICAgICBCOiB2YWxpZFJlc3VsdHMuZmlsdGVyKHJlc3VsdCA9PiByZXN1bHQuZ3JhZGUgPT09ICdCJykubGVuZ3RoLFxuICAgICAgICBDOiB2YWxpZFJlc3VsdHMuZmlsdGVyKHJlc3VsdCA9PiByZXN1bHQuZ3JhZGUgPT09ICdDJykubGVuZ3RoLFxuICAgICAgICBEOiB2YWxpZFJlc3VsdHMuZmlsdGVyKHJlc3VsdCA9PiByZXN1bHQuZ3JhZGUgPT09ICdEJykubGVuZ3RoLFxuICAgICAgICBGOiB2YWxpZFJlc3VsdHMuZmlsdGVyKHJlc3VsdCA9PiByZXN1bHQuZ3JhZGUgPT09ICdGJykubGVuZ3RoXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBtb3N0Q29tbW9uR3JhZGUgPSBPYmplY3QuZW50cmllcyhncmFkZUNvdW50KVxuICAgICAgICAucmVkdWNlKChhLCBiKSA9PiBhWzFdID4gYlsxXSA/IGEgOiBiKVswXTtcblxuICAgICAgc2V0RXhhbVN0YXRpc3RpY3Moe1xuICAgICAgICB0b3RhbFN0dWRlbnRzLFxuICAgICAgICBwYXNzaW5nQ291bnQ6IHBhc3NpbmdTdHVkZW50cyxcbiAgICAgICAgYUNvdW50OiBncmFkZUNvdW50LkEsXG4gICAgICAgIGJDb3VudDogZ3JhZGVDb3VudC5CLFxuICAgICAgICBjQ291bnQ6IGdyYWRlQ291bnQuQyxcbiAgICAgICAgZENvdW50OiBncmFkZUNvdW50LkQsXG4gICAgICAgIGZDb3VudDogZ3JhZGVDb3VudC5GLFxuICAgICAgICBhdmVyYWdlU2NvcmU6IHRvdGFsU2NvcmUgLyB0b3RhbFN0dWRlbnRzLFxuICAgICAgICBwYXNzUmF0ZTogKHBhc3NpbmdTdHVkZW50cyAqIDEwMCkgLyB0b3RhbFN0dWRlbnRzLFxuICAgICAgICBtb3N0Q29tbW9uR3JhZGVcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycjogdW5rbm93bikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBleGFtIHJlc3VsdHM6JywgZXJyKTtcbiAgICAgIHRvYXN0KHtcbiAgICAgICAgdGl0bGU6ICdFcnJvciBsb2FkaW5nIHJlc3VsdHMnLFxuICAgICAgICBkZXNjcmlwdGlvbjogZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6ICdBbiB1bmtub3duIGVycm9yIG9jY3VycmVkJyxcbiAgICAgICAgc3RhdHVzOiAnZXJyb3InLFxuICAgICAgICBkdXJhdGlvbjogMzAwMFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGhhbmRsZUVucm9sbFN0dWRlbnQgPSBhc3luYyAoZXhhbUlkOiBzdHJpbmcsIHN0dWRlbnRBZGRyZXNzOiBzdHJpbmcpID0+IHtcbiAgICBpZiAoIWFkZHJlc3MpIHtcbiAgICAgIHRvYXN0KHtcbiAgICAgICAgdGl0bGU6ICfYrti32KMg2YHZiiDYp9mE2LnZhtmI2KfZhiB8IEFkZHJlc3MgRXJyb3InLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ9mE2YUg2YrYqtmFINin2YTYudir2YjYsSDYudmE2Ykg2LnZhtmI2KfZhiDYp9mE2YXYrdmB2LjYqSB8IFdhbGxldCBhZGRyZXNzIG5vdCBmb3VuZCcsXG4gICAgICAgIHN0YXR1czogJ2Vycm9yJyxcbiAgICAgICAgZHVyYXRpb246IDMwMDAsXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgICAgYXdhaXQgZW5yb2xsU3R1ZGVudChleGFtSWQsIHN0dWRlbnRBZGRyZXNzKTtcbiAgICAgIHRvYXN0KHtcbiAgICAgICAgdGl0bGU6ICdTdHVkZW50IGVucm9sbGVkIHN1Y2Nlc3NmdWxseScsXG4gICAgICAgIHN0YXR1czogJ3N1Y2Nlc3MnLFxuICAgICAgICBkdXJhdGlvbjogMzAwMCxcbiAgICAgIH0pO1xuICAgICAgYXdhaXQgbG9hZEV4YW1zRnJvbUNvbnRyYWN0KGFkZHJlc3MpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyOiB1bmtub3duKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBlbnJvbGxpbmcgc3R1ZGVudDonLCBlcnIpO1xuICAgICAgdG9hc3Qoe1xuICAgICAgICB0aXRsZTogJ0Vycm9yIGVucm9sbGluZyBzdHVkZW50JyxcbiAgICAgICAgZGVzY3JpcHRpb246IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiAnQW4gdW5rbm93biBlcnJvciBvY2N1cnJlZCcsXG4gICAgICAgIHN0YXR1czogJ2Vycm9yJyxcbiAgICAgICAgZHVyYXRpb246IDMwMDAsXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgaXNzdWVDZXJ0aWZpY2F0ZSA9IGFzeW5jIChzdHVkZW50QWRkcmVzczogc3RyaW5nLCBjZXJ0aWZpY2F0ZTogeyB0aXRsZTogc3RyaW5nOyBkZXNjcmlwdGlvbjogc3RyaW5nIH0pOiBQcm9taXNlPGJvb2xlYW4+ID0+IHtcbiAgICBpZiAoIWFkZHJlc3MpIHtcbiAgICAgIHRvYXN0KHtcbiAgICAgICAgdGl0bGU6ICfYrti32KMg2YHZiiDYp9mE2LnZhtmI2KfZhiB8IEFkZHJlc3MgRXJyb3InLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ9mE2YUg2YrYqtmFINin2YTYudir2YjYsSDYudmE2Ykg2LnZhtmI2KfZhiDYp9mE2YXYrdmB2LjYqSB8IFdhbGxldCBhZGRyZXNzIG5vdCBmb3VuZCcsXG4gICAgICAgIHN0YXR1czogJ2Vycm9yJyxcbiAgICAgICAgZHVyYXRpb246IDMwMDAsXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgICAgY29uc3QgY29udHJhY3QgPSBhd2FpdCBnZXRDb250cmFjdCgpO1xuICAgICAgY29uc3QgdHggPSBhd2FpdCBjb250cmFjdC5pc3N1ZUNlcnRpZmljYXRlKHN0dWRlbnRBZGRyZXNzLCBjZXJ0aWZpY2F0ZS50aXRsZSwgY2VydGlmaWNhdGUuZGVzY3JpcHRpb24pO1xuICAgICAgYXdhaXQgdHgud2FpdCgpO1xuICAgICAgYXdhaXQgbG9hZENlcnRpZmljYXRlc0Zyb21Db250cmFjdChhZGRyZXNzKTtcbiAgICAgIHRvYXN0KHtcbiAgICAgICAgdGl0bGU6ICdDZXJ0aWZpY2F0ZSBpc3N1ZWQgc3VjY2Vzc2Z1bGx5JyxcbiAgICAgICAgc3RhdHVzOiAnc3VjY2VzcycsXG4gICAgICAgIGR1cmF0aW9uOiAzMDAwLFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnI6IHVua25vd24pIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGlzc3VpbmcgY2VydGlmaWNhdGU6JywgZXJyKTtcbiAgICAgIHRvYXN0KHtcbiAgICAgICAgdGl0bGU6ICdFcnJvciBpc3N1aW5nIGNlcnRpZmljYXRlJyxcbiAgICAgICAgZGVzY3JpcHRpb246IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiAnQW4gdW5rbm93biBlcnJvciBvY2N1cnJlZCcsXG4gICAgICAgIHN0YXR1czogJ2Vycm9yJyxcbiAgICAgICAgZHVyYXRpb246IDMwMDAsXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3Qgc2F2ZUluc3RpdHV0aW9uUHJvZmlsZSA9IGFzeW5jIChkYXRhOiBJbnN0aXR1dGlvbkRhdGEpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICBpZiAoIWV4YW1NYW5hZ2VtZW50Q29udHJhY3QgfHwgIWFkZHJlc3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ29udHJhY3Qgb3IgYWRkcmVzcyBub3QgYXZhaWxhYmxlJyk7XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGUgcmVxdWlyZWQgZmllbGRzXG4gICAgaWYgKCFkYXRhLm5hbWUgfHwgIWRhdGEubWluaXN0cnkgfHwgIWRhdGEudW5pdmVyc2l0eSB8fCAhZGF0YS5jb2xsZWdlIHx8IFxuICAgICAgICAhZGF0YS5kZXNjcmlwdGlvbiB8fCAhZGF0YS5pbWFnZVVybCB8fCAhZGF0YS53ZWJzaXRlIHx8ICFkYXRhLmVtYWlsIHx8ICFkYXRhLnBob25lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ9is2YXZiti5INin2YTYrdmC2YjZhCDZhdi32YTZiNio2KkgfCBBbGwgZmllbGRzIGFyZSByZXF1aXJlZCcpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgICBjb25zdCB0eCA9IGF3YWl0IGV4YW1NYW5hZ2VtZW50Q29udHJhY3Qud3JpdGUudXBkYXRlSW5zdGl0dXRpb25Qcm9maWxlKHtcbiAgICAgICAgYXJnczogW1xuICAgICAgICAgIGRhdGEubmFtZSxcbiAgICAgICAgICBkYXRhLm1pbmlzdHJ5LFxuICAgICAgICAgIGRhdGEudW5pdmVyc2l0eSxcbiAgICAgICAgICBkYXRhLmNvbGxlZ2UsXG4gICAgICAgICAgZGF0YS5kZXNjcmlwdGlvbixcbiAgICAgICAgICBkYXRhLmltYWdlVXJsIHx8ICcnLFxuICAgICAgICAgIGRhdGEud2Vic2l0ZSB8fCAnJyxcbiAgICAgICAgICBkYXRhLmVtYWlsIHx8ICcnLFxuICAgICAgICAgIGRhdGEucGhvbmUgfHwgJydcbiAgICAgICAgXVxuICAgICAgfSk7XG4gICAgICBhd2FpdCB0eC53YWl0KCk7XG4gICAgICBzZXRJbnN0aXR1dGlvbihkYXRhKTtcbiAgICAgIHRvYXN0KHtcbiAgICAgICAgdGl0bGU6ICfYqtmFINin2YTYrdmB2Lgg2KjZhtis2KfYrSB8IFNhdmVkIFN1Y2Nlc3NmdWxseScsXG4gICAgICAgIHN0YXR1czogJ3N1Y2Nlc3MnLFxuICAgICAgICBkdXJhdGlvbjogMzAwMCxcbiAgICAgICAgaXNDbG9zYWJsZTogdHJ1ZSxcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzYXZpbmcgaW5zdGl0dXRpb24gcHJvZmlsZTonLCBlcnJvcik7XG4gICAgICB0b2FzdCh7XG4gICAgICAgIHRpdGxlOiAn2K7Yt9ijINmB2Yog2KfZhNit2YHYuCB8IEVycm9yIFNhdmluZycsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdBbiB1bmtub3duIGVycm9yIG9jY3VycmVkJyxcbiAgICAgICAgc3RhdHVzOiAnZXJyb3InLFxuICAgICAgICBkdXJhdGlvbjogNTAwMCxcbiAgICAgICAgaXNDbG9zYWJsZTogdHJ1ZSxcbiAgICAgIH0pO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB7XG4gICAgaW5zdGl0dXRpb24sXG4gICAgZXhhbXMsXG4gICAgY2VydGlmaWNhdGVzLFxuICAgIGlzTG9hZGluZyxcbiAgICBpc0luaXRpYWxpemVkLFxuICAgIGhhc0FjY2VzcyxcbiAgICBzZWxlY3RlZEV4YW1SZXN1bHRzLFxuICAgIGV4YW1TdGF0aXN0aWNzLFxuICAgIHNhdmVJbnN0aXR1dGlvblByb2ZpbGUsXG4gICAgY3JlYXRlRXhhbSxcbiAgICB1cGRhdGVFeGFtU3RhdHVzLFxuICAgIHJlZ2lzdGVyU3R1ZGVudHMsXG4gICAgaGFuZGxlU3VibWl0UmVzdWx0cyxcbiAgICBoYW5kbGVFbnJvbGxTdHVkZW50LFxuICAgIGxvYWRFeGFtUmVzdWx0cyxcbiAgICBpc3N1ZUNlcnRpZmljYXRlLFxuICB9O1xufTsgIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlVG9hc3QiLCJnZXRFeGFtUmVzdWx0IiwiZW5yb2xsU3R1ZGVudCIsImdldENvbnRyYWN0IiwidXNlQWNjb3VudCIsInVzZUNvbnRyYWN0IiwiSU5TVElUVVRJT05fU1RPUkFHRV9LRVkiLCJFWEFNU19TVE9SQUdFX0tFWSIsIkNFUlRJRklDQVRFU19TVE9SQUdFX0tFWSIsInVzZUluc3RpdHV0aW9uIiwiZXhhbU1hbmFnZW1lbnRDb250cmFjdCIsImNlcnRpZmljYXRlc0NvbnRyYWN0IiwiaXNJbml0aWFsaXplZCIsImNvbnRyYWN0c0luaXRpYWxpemVkIiwiaXNMb2FkaW5nIiwiY29udHJhY3RzTG9hZGluZyIsImFkZHJlc3MiLCJ1bmRlZmluZWQiLCJpc0Nvbm5lY3RlZCIsInRvYXN0Iiwic2V0SXNMb2FkaW5nIiwic2V0SXNJbml0aWFsaXplZCIsImluaXRpYWxpemF0aW9uQXR0ZW1wdHMiLCJzZXRJbml0aWFsaXphdGlvbkF0dGVtcHRzIiwiaW5zdGl0dXRpb24iLCJzZXRJbnN0aXR1dGlvbiIsImV4YW1zIiwic2V0RXhhbXMiLCJjZXJ0aWZpY2F0ZXMiLCJzZXRDZXJ0aWZpY2F0ZXMiLCJoYXNBY2Nlc3MiLCJzZXRIYXNBY2Nlc3MiLCJzZWxlY3RlZEV4YW1SZXN1bHRzIiwic2V0U2VsZWN0ZWRFeGFtUmVzdWx0cyIsImV4YW1TdGF0aXN0aWNzIiwic2V0RXhhbVN0YXRpc3RpY3MiLCJjaGVja0FjY2VzcyIsInVzZXJBZGRyZXNzIiwiY29uc29sZSIsImxvZyIsImVycm9yIiwidGl0bGUiLCJkZXNjcmlwdGlvbiIsInN0YXR1cyIsImlzSW5zdGl0dXRpb25SZXN1bHQiLCJpc0luc3RpdHV0aW9uIiwiaW5zdGl0dXRpb25EYXRhIiwiZ2V0SW5zdGl0dXRpb24iLCJsZW5ndGgiLCJpc1ZlcmlmaWVkIiwiQm9vbGVhbiIsImlzTW91bnRlZCIsImluaXRUaW1lb3V0IiwiaW5pdGlhbGl6ZURhdGEiLCJpbml0U3RhdGUiLCJoYXNBZGRyZXNzIiwiaGFzRXhhbUNvbnRyYWN0IiwiaGFzQ2VydGlmaWNhdGVzQ29udHJhY3QiLCJhdHRlbXB0cyIsInNldFRpbWVvdXQiLCJwcmV2IiwiZHVyYXRpb24iLCJpc0Nsb3NhYmxlIiwiYWNjZXNzR3JhbnRlZCIsImV4YW1zRGF0YSIsImNlcnRpZmljYXRlc0RhdGEiLCJQcm9taXNlIiwiYWxsIiwibG9hZEluc3RpdHV0aW9uRnJvbUNvbnRyYWN0IiwibG9hZEV4YW1zRnJvbUNvbnRyYWN0IiwibG9hZENlcnRpZmljYXRlc0Zyb21Db250cmFjdCIsIkVycm9yIiwibmFtZSIsIm1lc3NhZ2UiLCJzdGFjayIsInN0YXRlIiwiY29udHJhY3RTdGF0dXMiLCJjbGVhclRpbWVvdXQiLCJkYXRhIiwibWluaXN0cnkiLCJ1bml2ZXJzaXR5IiwiY29sbGVnZSIsImltYWdlVXJsIiwid2Vic2l0ZSIsImVtYWlsIiwicGhvbmUiLCJnZXRJbnN0aXR1dGlvbkV4YW1zIiwiZ2V0SW5zdGl0dXRpb25DZXJ0aWZpY2F0ZXMiLCJjcmVhdGVFeGFtIiwiZXhhbSIsImNvbnRyYWN0IiwidHgiLCJkYXRlIiwid2FpdCIsImVyciIsInVwZGF0ZUV4YW1TdGF0dXMiLCJleGFtSWQiLCJyZWdpc3RlclN0dWRlbnRzIiwic3R1ZGVudHMiLCJoYW5kbGVTdWJtaXRSZXN1bHRzIiwicmVzdWx0cyIsInN1Ym1pdFJlc3VsdHMiLCJsb2FkRXhhbVJlc3VsdHMiLCJjdXJyZW50RXhhbSIsImZpbmQiLCJpZCIsImV4YW1SZXN1bHRzTGlzdCIsIm1hcCIsInN0dWRlbnRJZCIsInJlc3VsdCIsInZhbGlkUmVzdWx0cyIsImZpbHRlciIsInRvdGFsU3R1ZGVudHMiLCJwYXNzaW5nU3R1ZGVudHMiLCJzY29yZSIsInRvdGFsU2NvcmUiLCJyZWR1Y2UiLCJzdW0iLCJncmFkZUNvdW50IiwiQSIsImdyYWRlIiwiQiIsIkMiLCJEIiwiRiIsIm1vc3RDb21tb25HcmFkZSIsIk9iamVjdCIsImVudHJpZXMiLCJhIiwiYiIsInBhc3NpbmdDb3VudCIsImFDb3VudCIsImJDb3VudCIsImNDb3VudCIsImRDb3VudCIsImZDb3VudCIsImF2ZXJhZ2VTY29yZSIsInBhc3NSYXRlIiwiaGFuZGxlRW5yb2xsU3R1ZGVudCIsInN0dWRlbnRBZGRyZXNzIiwiaXNzdWVDZXJ0aWZpY2F0ZSIsImNlcnRpZmljYXRlIiwic2F2ZUluc3RpdHV0aW9uUHJvZmlsZSIsIndyaXRlIiwidXBkYXRlSW5zdGl0dXRpb25Qcm9maWxlIiwiYXJncyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./hooks/useInstitution.ts\n"));

/***/ }),

/***/ "./utilsFront/config.ts":
/*!******************************!*\
  !*** ./utilsFront/config.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CONFIG: function() { return /* binding */ CONFIG; },\n/* harmony export */   getConfig: function() { return /* binding */ getConfig; },\n/* harmony export */   validateConfig: function() { return /* binding */ validateConfig; }\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/process/browser.js\");\n// تكوين ثابت للنظام\nconst CONFIG = {\n    ADMIN_ADDRESS: \"0xf0e48a815075849d9c689c096f163a91deae0f29\",\n    NETWORK_URL: \"http://127.0.0.1:7545\",\n    CHAIN_ID: \"1337\",\n    IDENTITY_CONTRACT_ADDRESS: \"0xaaC5DcdAeadEe8aA2eE7C7c6F381AB44948963B5\",\n    CERTIFICATES_CONTRACT_ADDRESS: \"0x2AA6Bc8e926Ee5ECaA24c3B29cf24A3e32380682\",\n    EXAMINATIONS_CONTRACT_ADDRESS: \"0x7A053c7c399511d6bCb66224F2b2b6044a62CBa6\",\n    SECURITY_UTILS_CONTRACT_ADDRESS: \"0x0C68202ED4bB6332C7dC4c7aAe125cB240F3c369\",\n    EXAM_MANAGEMENT_CONTRACT_ADDRESS: \"0x379B947EEa4EF36276B69133D28B036e46732AaB\"\n};\n// وظيفة للحصول على قيمة التكوين\nconst getConfig = (key)=>{\n    // محاولة الحصول على القيمة من متغيرات البيئة أولاً\n    const envValue = process.env[\"NEXT_PUBLIC_\".concat(key)] || process.env[key];\n    // إذا لم يتم العثور على القيمة في متغيرات البيئة، استخدم القيمة الثابتة\n    return envValue || CONFIG[key];\n};\n// وظيفة للتحقق من صحة التكوين\nconst validateConfig = ()=>{\n    const missingKeys = [];\n    Object.keys(CONFIG).forEach((key)=>{\n        const value = getConfig(key);\n        if (!value) {\n            missingKeys.push(key);\n        }\n    });\n    if (missingKeys.length > 0) {\n        throw new Error(\"Missing configuration values for: \".concat(missingKeys.join(\", \")));\n    }\n    return true;\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi91dGlsc0Zyb250L2NvbmZpZy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUEsb0JBQW9CO0FBQ2IsTUFBTUEsU0FBUztJQUNwQkMsZUFBZTtJQUNmQyxhQUFhO0lBQ2JDLFVBQVU7SUFDVkMsMkJBQTJCO0lBQzNCQywrQkFBK0I7SUFDL0JDLCtCQUErQjtJQUMvQkMsaUNBQWlDO0lBQ2pDQyxrQ0FBa0M7QUFDcEMsRUFBRTtBQUVGLGdDQUFnQztBQUN6QixNQUFNQyxZQUFZLENBQUNDO0lBQ3hCLG1EQUFtRDtJQUNuRCxNQUFNQyxXQUFXQyxPQUFPQSxDQUFDQyxHQUFHLENBQUMsZUFBbUIsT0FBSkgsS0FBTSxJQUFJRSxPQUFPQSxDQUFDQyxHQUFHLENBQUNILElBQUk7SUFFdEUsd0VBQXdFO0lBQ3hFLE9BQU9DLFlBQVlYLE1BQU0sQ0FBQ1UsSUFBSTtBQUNoQyxFQUFFO0FBRUYsOEJBQThCO0FBQ3ZCLE1BQU1JLGlCQUFpQjtJQUM1QixNQUFNQyxjQUF3QixFQUFFO0lBRWhDQyxPQUFPQyxJQUFJLENBQUNqQixRQUFRa0IsT0FBTyxDQUFDLENBQUNSO1FBQzNCLE1BQU1TLFFBQVFWLFVBQVVDO1FBQ3hCLElBQUksQ0FBQ1MsT0FBTztZQUNWSixZQUFZSyxJQUFJLENBQUNWO1FBQ25CO0lBQ0Y7SUFFQSxJQUFJSyxZQUFZTSxNQUFNLEdBQUcsR0FBRztRQUMxQixNQUFNLElBQUlDLE1BQU0scUNBQTRELE9BQXZCUCxZQUFZUSxJQUFJLENBQUM7SUFDeEU7SUFFQSxPQUFPO0FBQ1QsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi91dGlsc0Zyb250L2NvbmZpZy50cz84MDYxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vINiq2YPZiNmK2YYg2KvYp9io2Kog2YTZhNmG2LjYp9mFXG5leHBvcnQgY29uc3QgQ09ORklHID0ge1xuICBBRE1JTl9BRERSRVNTOiAnMHhmMGU0OGE4MTUwNzU4NDlkOWM2ODljMDk2ZjE2M2E5MWRlYWUwZjI5JyxcbiAgTkVUV09SS19VUkw6ICdodHRwOi8vMTI3LjAuMC4xOjc1NDUnLFxuICBDSEFJTl9JRDogJzEzMzcnLFxuICBJREVOVElUWV9DT05UUkFDVF9BRERSRVNTOiAnMHhhYUM1RGNkQWVhZEVlOGFBMmVFN0M3YzZGMzgxQUI0NDk0ODk2M0I1JyxcbiAgQ0VSVElGSUNBVEVTX0NPTlRSQUNUX0FERFJFU1M6ICcweDJBQTZCYzhlOTI2RWU1RUNhQTI0YzNCMjljZjI0QTNlMzIzODA2ODInLFxuICBFWEFNSU5BVElPTlNfQ09OVFJBQ1RfQUREUkVTUzogJzB4N0EwNTNjN2MzOTk1MTFkNmJDYjY2MjI0RjJiMmI2MDQ0YTYyQ0JhNicsXG4gIFNFQ1VSSVRZX1VUSUxTX0NPTlRSQUNUX0FERFJFU1M6ICcweDBDNjgyMDJFRDRiQjYzMzJDN2RDNGM3YUFlMTI1Y0IyNDBGM2MzNjknLFxuICBFWEFNX01BTkFHRU1FTlRfQ09OVFJBQ1RfQUREUkVTUzogJzB4Mzc5Qjk0N0VFYTRFRjM2Mjc2QjY5MTMzRDI4QjAzNmU0NjczMkFhQidcbn07XG5cbi8vINmI2LjZitmB2Kkg2YTZhNit2LXZiNmEINi52YTZiSDZgtmK2YXYqSDYp9mE2KrZg9mI2YrZhlxuZXhwb3J0IGNvbnN0IGdldENvbmZpZyA9IChrZXk6IGtleW9mIHR5cGVvZiBDT05GSUcpOiBzdHJpbmcgPT4ge1xuICAvLyDZhdit2KfZiNmE2Kkg2KfZhNit2LXZiNmEINi52YTZiSDYp9mE2YLZitmF2Kkg2YXZhiDZhdiq2LrZitix2KfYqiDYp9mE2KjZitim2Kkg2KPZiNmE2KfZi1xuICBjb25zdCBlbnZWYWx1ZSA9IHByb2Nlc3MuZW52W2BORVhUX1BVQkxJQ18ke2tleX1gXSB8fCBwcm9jZXNzLmVudltrZXldO1xuICBcbiAgLy8g2KXYsNinINmE2YUg2YrYqtmFINin2YTYudir2YjYsSDYudmE2Ykg2KfZhNmC2YrZhdipINmB2Yog2YXYqti62YrYsdin2Kog2KfZhNio2YrYptip2Iwg2KfYs9iq2K7Yr9mFINin2YTZgtmK2YXYqSDYp9mE2KvYp9io2KrYqVxuICByZXR1cm4gZW52VmFsdWUgfHwgQ09ORklHW2tleV07XG59O1xuXG4vLyDZiNi42YrZgdipINmE2YTYqtit2YLZgiDZhdmGINi12K3YqSDYp9mE2KrZg9mI2YrZhlxuZXhwb3J0IGNvbnN0IHZhbGlkYXRlQ29uZmlnID0gKCkgPT4ge1xuICBjb25zdCBtaXNzaW5nS2V5czogc3RyaW5nW10gPSBbXTtcbiAgXG4gIE9iamVjdC5rZXlzKENPTkZJRykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSBnZXRDb25maWcoa2V5IGFzIGtleW9mIHR5cGVvZiBDT05GSUcpO1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIG1pc3NpbmdLZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gIH0pO1xuXG4gIGlmIChtaXNzaW5nS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIGNvbmZpZ3VyYXRpb24gdmFsdWVzIGZvcjogJHttaXNzaW5nS2V5cy5qb2luKCcsICcpfWApO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59OyAiXSwibmFtZXMiOlsiQ09ORklHIiwiQURNSU5fQUREUkVTUyIsIk5FVFdPUktfVVJMIiwiQ0hBSU5fSUQiLCJJREVOVElUWV9DT05UUkFDVF9BRERSRVNTIiwiQ0VSVElGSUNBVEVTX0NPTlRSQUNUX0FERFJFU1MiLCJFWEFNSU5BVElPTlNfQ09OVFJBQ1RfQUREUkVTUyIsIlNFQ1VSSVRZX1VUSUxTX0NPTlRSQUNUX0FERFJFU1MiLCJFWEFNX01BTkFHRU1FTlRfQ09OVFJBQ1RfQUREUkVTUyIsImdldENvbmZpZyIsImtleSIsImVudlZhbHVlIiwicHJvY2VzcyIsImVudiIsInZhbGlkYXRlQ29uZmlnIiwibWlzc2luZ0tleXMiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsInZhbHVlIiwicHVzaCIsImxlbmd0aCIsIkVycm9yIiwiam9pbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./utilsFront/config.ts\n"));

/***/ }),

/***/ "./utilsFront/contracts.ts":
/*!*********************************!*\
  !*** ./utilsFront/contracts.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createExam: function() { return /* binding */ createExam; },\n/* harmony export */   enrollStudent: function() { return /* binding */ enrollStudent; },\n/* harmony export */   getCertificates: function() { return /* binding */ getCertificates; },\n/* harmony export */   getContract: function() { return /* binding */ getContract; },\n/* harmony export */   getContracts: function() { return /* binding */ getContracts; },\n/* harmony export */   getExam: function() { return /* binding */ getExam; },\n/* harmony export */   getExamResult: function() { return /* binding */ getExamResult; },\n/* harmony export */   getInstitutionExams: function() { return /* binding */ getInstitutionExams; },\n/* harmony export */   getOwnerAddress: function() { return /* binding */ getOwnerAddress; },\n/* harmony export */   getStudentExams: function() { return /* binding */ getStudentExams; },\n/* harmony export */   getUserRole: function() { return /* binding */ getUserRole; },\n/* harmony export */   isOwner: function() { return /* binding */ isOwner; },\n/* harmony export */   isVerifiedUser: function() { return /* binding */ isVerifiedUser; },\n/* harmony export */   issueCertificate: function() { return /* binding */ issueCertificate; },\n/* harmony export */   registerUser: function() { return /* binding */ registerUser; },\n/* harmony export */   setAdminRole: function() { return /* binding */ setAdminRole; },\n/* harmony export */   submitExamResult: function() { return /* binding */ submitExamResult; },\n/* harmony export */   updateExamStatus: function() { return /* binding */ updateExamStatus; },\n/* harmony export */   validateEnv: function() { return /* binding */ validateEnv; },\n/* harmony export */   verifyCertificate: function() { return /* binding */ verifyCertificate; },\n/* harmony export */   verifyInstitution: function() { return /* binding */ verifyInstitution; },\n/* harmony export */   verifyUser: function() { return /* binding */ verifyUser; }\n/* harmony export */ });\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"./node_modules/.pnpm/ethers@6.13.5_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/ethers/lib.esm/index.js\");\n/* harmony import */ var _constants_abis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/abis */ \"./constants/abis.ts\");\n/* harmony import */ var _ethersConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ethersConfig */ \"./utilsFront/ethersConfig.ts\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./config */ \"./utilsFront/config.ts\");\n\n\n\n\n// Contract ABIs\nconst IdentityABI = [\n    \"function registerUser(uint8 _role, string memory _ipfsHash) external\",\n    \"function verifyUser(address _userAddress) external\",\n    \"function getUserRole(address _userAddress) external view returns (uint8)\",\n    \"function isVerifiedUser(address _userAddress) external view returns (bool)\",\n    \"function updateUserIPFS(string memory _newIpfsHash) external\",\n    \"function owner() external view returns (address)\",\n    \"function isAdmin(address _address) external view returns (bool)\",\n    \"function addAdmin(address _newAdmin) external\",\n    \"function removeAdmin(address _admin) external\"\n];\nconst CertificatesABI = [\n    \"function issueCertificate(address _studentAddress, string memory _ipfsHash) external returns (bytes32)\",\n    \"function getStudentCertificates(address _student) external view returns (bytes32[])\",\n    \"function verifyCertificate(bytes32 _certificateId) external view returns (address student, address institution, string ipfsHash, uint256 issuedAt, bool isValid)\"\n];\n// Contract addresses from config\nconst IDENTITY_CONTRACT_ADDRESS = (0,_config__WEBPACK_IMPORTED_MODULE_2__.getConfig)(\"IDENTITY_CONTRACT_ADDRESS\");\nconst CERTIFICATES_CONTRACT_ADDRESS = (0,_config__WEBPACK_IMPORTED_MODULE_2__.getConfig)(\"CERTIFICATES_CONTRACT_ADDRESS\");\nconst ADMIN_ADDRESS = (0,_config__WEBPACK_IMPORTED_MODULE_2__.getConfig)(\"ADMIN_ADDRESS\");\nconst EXAM_MANAGEMENT_ADDRESS = (0,_config__WEBPACK_IMPORTED_MODULE_2__.getConfig)(\"EXAM_MANAGEMENT_CONTRACT_ADDRESS\");\n// Validate environment variables\nconst validateEnv = ()=>{\n    try {\n        // التحقق من صحة التكوين\n        (0,_config__WEBPACK_IMPORTED_MODULE_2__.validateConfig)();\n        // التحقق من صحة العناوين\n        if (!(0,ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress)(IDENTITY_CONTRACT_ADDRESS)) {\n            throw new Error(\"Invalid Identity contract address: \".concat(IDENTITY_CONTRACT_ADDRESS));\n        }\n        if (!(0,ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress)(CERTIFICATES_CONTRACT_ADDRESS)) {\n            throw new Error(\"Invalid Certificates contract address: \".concat(CERTIFICATES_CONTRACT_ADDRESS));\n        }\n        if (!(0,ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress)(ADMIN_ADDRESS)) {\n            throw new Error(\"Invalid Admin address: \".concat(ADMIN_ADDRESS));\n        }\n        if (!(0,ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress)(EXAM_MANAGEMENT_ADDRESS)) {\n            throw new Error(\"Invalid Exam Management contract address: \".concat(EXAM_MANAGEMENT_ADDRESS));\n        }\n        console.log(\"Configuration validated successfully:\", {\n            IDENTITY_CONTRACT_ADDRESS,\n            CERTIFICATES_CONTRACT_ADDRESS,\n            ADMIN_ADDRESS,\n            EXAM_MANAGEMENT_ADDRESS,\n            CHAIN_ID: (0,_config__WEBPACK_IMPORTED_MODULE_2__.getConfig)(\"CHAIN_ID\"),\n            NETWORK_URL: (0,_config__WEBPACK_IMPORTED_MODULE_2__.getConfig)(\"NETWORK_URL\")\n        });\n        return true;\n    } catch (error) {\n        console.error(\"Configuration validation failed:\", error);\n        throw error;\n    }\n};\n// Debug environment variables\nconsole.log(\"Environment variables check:\", {\n    IDENTITY_CONTRACT_ADDRESS,\n    CERTIFICATES_CONTRACT_ADDRESS,\n    ADMIN_ADDRESS,\n    EXAM_MANAGEMENT_ADDRESS,\n    CHAIN_ID: _ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.chainId,\n    NETWORK_URL: _ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl\n});\n// Role mapping with proper types\nconst USER_ROLES = {\n    NONE: 0,\n    STUDENT: 1,\n    INSTITUTION: 2,\n    EMPLOYER: 3,\n    ADMIN: 4\n};\nconst roleMap = {\n    [USER_ROLES.NONE]: \"none\",\n    [USER_ROLES.STUDENT]: \"student\",\n    [USER_ROLES.INSTITUTION]: \"institution\",\n    [USER_ROLES.EMPLOYER]: \"employer\",\n    [USER_ROLES.ADMIN]: \"admin\"\n};\nconst getContracts = async ()=>{\n    try {\n        console.log(\"Contract Addresses:\", {\n            Identity: IDENTITY_CONTRACT_ADDRESS,\n            Certificates: CERTIFICATES_CONTRACT_ADDRESS,\n            Admin: ADMIN_ADDRESS\n        });\n        const provider = await (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getProvider)();\n        await (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.validateNetwork)(provider);\n        console.log(\"Network validation passed\");\n        const signer = await (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getSigner)();\n        const userAddress = await signer.getAddress();\n        console.log(\"Connected with address:\", userAddress);\n        const userBalance = await provider.getBalance(userAddress);\n        console.log(\"User balance:\", (0,ethers__WEBPACK_IMPORTED_MODULE_3__.formatUnits)(userBalance, \"ether\"), \"ETH\");\n        const identityContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.Contract(IDENTITY_CONTRACT_ADDRESS, IdentityABI, signer);\n        console.log(\"Verifying contract exists at address:\", IDENTITY_CONTRACT_ADDRESS);\n        const code = await provider.getCode(IDENTITY_CONTRACT_ADDRESS);\n        console.log(\"Contract code length:\", code.length);\n        console.log(\"Contract exists:\", code !== \"0x\");\n        if (code === \"0x\") {\n            throw new Error(\"Identity contract not found at address: \".concat(IDENTITY_CONTRACT_ADDRESS));\n        }\n        const certificatesContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.Contract(CERTIFICATES_CONTRACT_ADDRESS, CertificatesABI, signer);\n        const examManagementContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.Contract(EXAM_MANAGEMENT_ADDRESS, _constants_abis__WEBPACK_IMPORTED_MODULE_0__.EXAM_MANAGEMENT_ABI, signer);\n        return {\n            identityContract,\n            certificatesContract,\n            examManagementContract,\n            provider,\n            signer\n        };\n    } catch (error) {\n        console.error(\"Error initializing contracts:\", error);\n        console.error(\"Error details:\", {\n            message: error.message,\n            code: error.code,\n            reason: error.reason\n        });\n        throw new Error(\"Failed to initialize contracts: \".concat(error.message));\n    }\n};\nconst registerUser = async (role)=>{\n    if (!role) {\n        throw new Error(\"Role is required\");\n    }\n    try {\n        const { identityContract, signer } = await getContracts();\n        // Get network details and user address\n        const userAddress = await signer.getAddress();\n        console.log(\"Registering address:\", userAddress);\n        console.log(\"With role:\", role);\n        // Special handling for admin address\n        if (ADMIN_ADDRESS && userAddress.toLowerCase() === ADMIN_ADDRESS.toLowerCase()) {\n            console.log(\"This is the admin address, setting admin role...\");\n            return await setAdminRole();\n        }\n        // Convert role string to enum value\n        const roleMap = {\n            \"student\": USER_ROLES.STUDENT,\n            \"institution\": USER_ROLES.INSTITUTION,\n            \"employer\": USER_ROLES.EMPLOYER,\n            \"admin\": USER_ROLES.ADMIN\n        };\n        const roleValue = roleMap[role.toLowerCase()];\n        if (roleValue === undefined) {\n            throw new Error(\"Invalid role: \".concat(role, \". Must be one of: student, institution, employer, admin\"));\n        }\n        console.log(\"Role value from mapping:\", roleValue);\n        // Check if user is already registered\n        try {\n            console.log(\"Checking if user already exists...\");\n            const existingRole = await identityContract.getUserRole(userAddress);\n            console.log(\"Existing role:\", existingRole);\n            if (existingRole > 0) {\n                console.log(\"User already registered with role:\", existingRole);\n                // If user exists but needs verification\n                const isVerified = await identityContract.isVerified(userAddress);\n                if (!isVerified) {\n                    console.log(\"User exists but not verified, attempting verification...\");\n                    const verifyTx = await identityContract.verifyUser(userAddress);\n                    await verifyTx.wait();\n                    console.log(\"User verified successfully\");\n                }\n                return {\n                    status: \"existing\",\n                    role: existingRole\n                };\n            }\n        } catch (error) {\n            if (!error.message.includes(\"User does not exist\")) {\n                throw error;\n            }\n            console.log(\"User does not exist, proceeding with registration\");\n        }\n        // Register user\n        console.log(\"Registering new user with role:\", roleValue);\n        const tx = await identityContract.registerUser(roleValue, \"\");\n        console.log(\"Registration transaction sent:\", tx.hash);\n        const receipt = await tx.wait();\n        console.log(\"Registration successful:\", receipt.hash);\n        // Verify the user automatically\n        try {\n            console.log(\"Attempting automatic verification...\");\n            const verifyTx = await identityContract.verifyUser(userAddress);\n            await verifyTx.wait();\n            console.log(\"User verified successfully\");\n        } catch (verifyError) {\n            console.warn(\"Automatic verification failed:\", verifyError);\n        // Continue even if verification fails\n        }\n        // If registering as admin, set admin role\n        if (role.toLowerCase() === \"admin\") {\n            console.log(\"Setting admin privileges...\");\n            await setAdminRole();\n        }\n        return {\n            status: \"success\",\n            role: roleValue,\n            transaction: tx\n        };\n    } catch (error) {\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst verifyUser = async (address)=>{\n    try {\n        (0,ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress)(address); // Using getAddress instead of isAddress\n    } catch (error) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        console.log(\"Verifying user:\", address);\n        const { identityContract } = await getContracts();\n        const isVerified = await identityContract.isVerified(address);\n        console.log(\"User verification status:\", isVerified);\n        return isVerified;\n    } catch (error) {\n        console.error(\"Error in verifyUser:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst getUserRole = async (address)=>{\n    try {\n        (0,ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress)(address);\n    } catch (error) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        console.log(\"Getting user role for:\", address);\n        const { identityContract } = await getContracts();\n        const role = await identityContract.getUserRole(address);\n        console.log(\"User role:\", role);\n        return role;\n    } catch (error) {\n        console.error(\"Error in getUserRole:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst issueCertificate = async (studentAddress, ipfsHash)=>{\n    if (!studentAddress || !ipfsHash) {\n        throw new Error(\"Student address and IPFS hash are required\");\n    }\n    try {\n        const { certificatesContract } = await getContracts();\n        const tx = await certificatesContract.issueCertificate(studentAddress, ipfsHash);\n        await tx.wait();\n        return tx;\n    } catch (error) {\n        console.error(\"Error issuing certificate:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst verifyCertificate = async (certificateId)=>{\n    if (!certificateId) {\n        throw new Error(\"Certificate ID is required\");\n    }\n    try {\n        const { certificatesContract } = await getContracts();\n        const isValid = await certificatesContract.verifyCertificate(certificateId);\n        return isValid;\n    } catch (error) {\n        console.error(\"Error verifying certificate:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst getCertificates = async (address)=>{\n    try {\n        (0,ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress)(address);\n    } catch (error) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        console.log(\"Getting certificates for:\", address);\n        const { certificatesContract } = await getContracts();\n        const certificates = await certificatesContract.getCertificates(address);\n        console.log(\"Certificates:\", certificates);\n        return certificates;\n    } catch (error) {\n        console.error(\"Error in getCertificates:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst isVerifiedUser = async (address)=>{\n    try {\n        (0,ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress)(address);\n    } catch (error) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        console.log(\"Checking if user is verified:\", address);\n        const { identityContract } = await getContracts();\n        const isVerified = await identityContract.isVerified(address);\n        console.log(\"User verification status:\", isVerified);\n        return isVerified;\n    } catch (error) {\n        console.error(\"Error in isVerifiedUser:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst isOwner = async (address)=>{\n    try {\n        (0,ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress)(address);\n    } catch (error) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        console.log(\"Checking if user is owner:\", address);\n        const { identityContract } = await getContracts();\n        const ownerAddress = await identityContract.owner();\n        const isOwnerRole = address.toLowerCase() === ownerAddress.toLowerCase();\n        console.log(\"User owner status:\", isOwnerRole);\n        return isOwnerRole;\n    } catch (error) {\n        console.error(\"Error in isOwner:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst verifyInstitution = async (institutionAddress)=>{\n    try {\n        (0,ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress)(institutionAddress);\n    } catch (error) {\n        throw new Error(\"Invalid institution address\");\n    }\n    try {\n        console.log(\"Verifying institution:\", institutionAddress);\n        const { identityContract } = await getContracts();\n        const tx = await identityContract.verifyUser(institutionAddress);\n        await tx.wait();\n        console.log(\"Institution verified successfully\");\n        return true;\n    } catch (error) {\n        console.error(\"Error in verifyInstitution:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst getOwnerAddress = async ()=>{\n    try {\n        const { identityContract } = await getContracts();\n        const owner = await identityContract.owner();\n        return owner;\n    } catch (error) {\n        console.error(\"Error getting owner address:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\n// Add exam management functions\nconst createExam = async (id, title, description, date, duration, ipfsHash)=>{\n    try {\n        const { examManagementContract } = await getContracts();\n        const tx = await examManagementContract.createExam(id, title, description, date, duration, ipfsHash);\n        await tx.wait();\n        return true;\n    } catch (error) {\n        console.error(\"Error creating exam:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst submitExamResult = async (examId, student, score, grade, ipfsHash)=>{\n    try {\n        const { examManagementContract } = await getContracts();\n        const tx = await examManagementContract.submitExamResult(examId, student, score, grade, ipfsHash);\n        await tx.wait();\n        return true;\n    } catch (error) {\n        console.error(\"Error submitting exam result:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst updateExamStatus = async (examId, status)=>{\n    try {\n        const { examManagementContract } = await getContracts();\n        const tx = await examManagementContract.updateExamStatus(examId, status);\n        await tx.wait();\n        return true;\n    } catch (error) {\n        console.error(\"Error updating exam status:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst getExam = async (examId)=>{\n    try {\n        const { examManagementContract } = await getContracts();\n        const exam = await examManagementContract.getExam(examId);\n        return exam;\n    } catch (error) {\n        console.error(\"Error getting exam:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst getExamResult = async (examId, student)=>{\n    try {\n        const { examManagementContract } = await getContracts();\n        const result = await examManagementContract.getExamResult(examId, student);\n        return result;\n    } catch (error) {\n        console.error(\"Error getting exam result:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst getInstitutionExams = async (institution)=>{\n    try {\n        const { examManagementContract } = await getContracts();\n        const exams = await examManagementContract.getInstitutionExams(institution);\n        return exams;\n    } catch (error) {\n        console.error(\"Error getting institution exams:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst getStudentExams = async (student)=>{\n    try {\n        const { examManagementContract } = await getContracts();\n        const exams = await examManagementContract.getStudentExams(student);\n        return exams;\n    } catch (error) {\n        console.error(\"Error getting student exams:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst enrollStudent = async (examId, studentAddress)=>{\n    try {\n        const { examManagementContract } = await getContracts();\n        const tx = await examManagementContract.enrollStudent(examId, studentAddress);\n        await tx.wait();\n        return true;\n    } catch (error) {\n        console.error(\"Error enrolling student:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst getContract = async ()=>{\n    const { examManagementContract } = await getContracts();\n    return examManagementContract;\n};\nconst setAdminRole = async ()=>{\n    try {\n        const { identityContract, signer } = await getContracts();\n        const userAddress = await signer.getAddress();\n        console.log(\"Setting admin role for address:\", userAddress);\n        console.log(\"Expected admin address:\", ADMIN_ADDRESS);\n        // First check if the address is already an admin\n        const isAdmin = await identityContract.isAdmin(userAddress);\n        console.log(\"Is already admin?\", isAdmin);\n        if (isAdmin) {\n            console.log(\"User is already an admin\");\n            return {\n                status: \"existing\",\n                isAdmin: true\n            };\n        }\n        // Check if this is the configured admin address\n        if (ADMIN_ADDRESS && userAddress.toLowerCase() === ADMIN_ADDRESS.toLowerCase()) {\n            console.log(\"Address matches configured admin, adding as admin...\");\n            // First try to register as admin if not already registered\n            try {\n                const role = await identityContract.getUserRole(userAddress);\n                if (role === 0) {\n                    console.log(\"Registering admin user first...\");\n                    const regTx = await identityContract.registerUser(USER_ROLES.ADMIN, \"\");\n                    await regTx.wait();\n                }\n            } catch (error) {\n                if (!error.message.includes(\"User does not exist\")) {\n                    throw error;\n                }\n                // If user doesn't exist, register them as admin\n                console.log(\"Registering new admin user...\");\n                const regTx = await identityContract.registerUser(USER_ROLES.ADMIN, \"\");\n                await regTx.wait();\n            }\n            // Verify the user\n            console.log(\"Verifying admin user...\");\n            const verifyTx = await identityContract.verifyUser(userAddress);\n            await verifyTx.wait();\n            // Add admin role\n            console.log(\"Adding admin role...\");\n            const tx = await identityContract.addAdmin(userAddress);\n            await tx.wait();\n            console.log(\"Successfully added as admin\");\n            return {\n                status: \"success\",\n                isAdmin: true\n            };\n        }\n        throw new Error(\"Only configured admin addresses can be set as admin\");\n    } catch (error) {\n        console.error(\"Error setting admin role:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0lBQzdCO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi91dGlsc0Zyb250L2NvbnRyYWN0cy50cz9hY2E2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFxuICBDb250cmFjdCxcbiAgZm9ybWF0VW5pdHMsXG4gIGdldEFkZHJlc3Ncbn0gZnJvbSAnZXRoZXJzJztcbmltcG9ydCB7IEVYQU1fTUFOQUdFTUVOVF9BQkkgfSBmcm9tICcuLi9jb25zdGFudHMvYWJpcyc7XG5pbXBvcnQgeyBcbiAgZ2V0UHJvdmlkZXIsIFxuICBnZXRTaWduZXIsIFxuICBFWFBFQ1RFRF9ORVRXT1JLLCBcbiAgdmFsaWRhdGVOZXR3b3JrLFxuICBmb3JtYXRFdGhlcixcbiAgaGFuZGxlQ29udHJhY3RFcnJvclxufSBmcm9tICcuL2V0aGVyc0NvbmZpZyc7XG5pbXBvcnQgdHlwZSB7IEV0aGVyZXVtUHJvdmlkZXIgfSBmcm9tICcuL2V0aGVyc0NvbmZpZyc7XG5pbXBvcnQgeyBnZXRDb25maWcsIHZhbGlkYXRlQ29uZmlnIH0gZnJvbSAnLi9jb25maWcnO1xuXG4vLyBDb250cmFjdCBBQklzXG5jb25zdCBJZGVudGl0eUFCSSA9IFtcbiAgXCJmdW5jdGlvbiByZWdpc3RlclVzZXIodWludDggX3JvbGUsIHN0cmluZyBtZW1vcnkgX2lwZnNIYXNoKSBleHRlcm5hbFwiLFxuICBcImZ1bmN0aW9uIHZlcmlmeVVzZXIoYWRkcmVzcyBfdXNlckFkZHJlc3MpIGV4dGVybmFsXCIsXG4gIFwiZnVuY3Rpb24gZ2V0VXNlclJvbGUoYWRkcmVzcyBfdXNlckFkZHJlc3MpIGV4dGVybmFsIHZpZXcgcmV0dXJucyAodWludDgpXCIsXG4gIFwiZnVuY3Rpb24gaXNWZXJpZmllZFVzZXIoYWRkcmVzcyBfdXNlckFkZHJlc3MpIGV4dGVybmFsIHZpZXcgcmV0dXJucyAoYm9vbClcIixcbiAgXCJmdW5jdGlvbiB1cGRhdGVVc2VySVBGUyhzdHJpbmcgbWVtb3J5IF9uZXdJcGZzSGFzaCkgZXh0ZXJuYWxcIixcbiAgXCJmdW5jdGlvbiBvd25lcigpIGV4dGVybmFsIHZpZXcgcmV0dXJucyAoYWRkcmVzcylcIixcbiAgXCJmdW5jdGlvbiBpc0FkbWluKGFkZHJlc3MgX2FkZHJlc3MpIGV4dGVybmFsIHZpZXcgcmV0dXJucyAoYm9vbClcIixcbiAgXCJmdW5jdGlvbiBhZGRBZG1pbihhZGRyZXNzIF9uZXdBZG1pbikgZXh0ZXJuYWxcIixcbiAgXCJmdW5jdGlvbiByZW1vdmVBZG1pbihhZGRyZXNzIF9hZG1pbikgZXh0ZXJuYWxcIlxuXTtcblxuY29uc3QgQ2VydGlmaWNhdGVzQUJJID0gW1xuICBcImZ1bmN0aW9uIGlzc3VlQ2VydGlmaWNhdGUoYWRkcmVzcyBfc3R1ZGVudEFkZHJlc3MsIHN0cmluZyBtZW1vcnkgX2lwZnNIYXNoKSBleHRlcm5hbCByZXR1cm5zIChieXRlczMyKVwiLFxuICBcImZ1bmN0aW9uIGdldFN0dWRlbnRDZXJ0aWZpY2F0ZXMoYWRkcmVzcyBfc3R1ZGVudCkgZXh0ZXJuYWwgdmlldyByZXR1cm5zIChieXRlczMyW10pXCIsXG4gIFwiZnVuY3Rpb24gdmVyaWZ5Q2VydGlmaWNhdGUoYnl0ZXMzMiBfY2VydGlmaWNhdGVJZCkgZXh0ZXJuYWwgdmlldyByZXR1cm5zIChhZGRyZXNzIHN0dWRlbnQsIGFkZHJlc3MgaW5zdGl0dXRpb24sIHN0cmluZyBpcGZzSGFzaCwgdWludDI1NiBpc3N1ZWRBdCwgYm9vbCBpc1ZhbGlkKVwiXG5dO1xuXG4vLyBDb250cmFjdCBhZGRyZXNzZXMgZnJvbSBjb25maWdcbmNvbnN0IElERU5USVRZX0NPTlRSQUNUX0FERFJFU1MgPSBnZXRDb25maWcoJ0lERU5USVRZX0NPTlRSQUNUX0FERFJFU1MnKTtcbmNvbnN0IENFUlRJRklDQVRFU19DT05UUkFDVF9BRERSRVNTID0gZ2V0Q29uZmlnKCdDRVJUSUZJQ0FURVNfQ09OVFJBQ1RfQUREUkVTUycpO1xuY29uc3QgQURNSU5fQUREUkVTUyA9IGdldENvbmZpZygnQURNSU5fQUREUkVTUycpO1xuY29uc3QgRVhBTV9NQU5BR0VNRU5UX0FERFJFU1MgPSBnZXRDb25maWcoJ0VYQU1fTUFOQUdFTUVOVF9DT05UUkFDVF9BRERSRVNTJyk7XG5cbi8vIFZhbGlkYXRlIGVudmlyb25tZW50IHZhcmlhYmxlc1xuZXhwb3J0IGNvbnN0IHZhbGlkYXRlRW52ID0gKCkgPT4ge1xuICB0cnkge1xuICAgIC8vINin2YTYqtit2YLZgiDZhdmGINi12K3YqSDYp9mE2KrZg9mI2YrZhlxuICAgIHZhbGlkYXRlQ29uZmlnKCk7XG5cbiAgICAvLyDYp9mE2KrYrdmC2YIg2YXZhiDYtdit2Kkg2KfZhNi52YbYp9mI2YrZhlxuICAgIGlmICghZ2V0QWRkcmVzcyhJREVOVElUWV9DT05UUkFDVF9BRERSRVNTKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIElkZW50aXR5IGNvbnRyYWN0IGFkZHJlc3M6ICR7SURFTlRJVFlfQ09OVFJBQ1RfQUREUkVTU31gKTtcbiAgICB9XG5cbiAgICBpZiAoIWdldEFkZHJlc3MoQ0VSVElGSUNBVEVTX0NPTlRSQUNUX0FERFJFU1MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgQ2VydGlmaWNhdGVzIGNvbnRyYWN0IGFkZHJlc3M6ICR7Q0VSVElGSUNBVEVTX0NPTlRSQUNUX0FERFJFU1N9YCk7XG4gICAgfVxuXG4gICAgaWYgKCFnZXRBZGRyZXNzKEFETUlOX0FERFJFU1MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgQWRtaW4gYWRkcmVzczogJHtBRE1JTl9BRERSRVNTfWApO1xuICAgIH1cblxuICAgIGlmICghZ2V0QWRkcmVzcyhFWEFNX01BTkFHRU1FTlRfQUREUkVTUykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBFeGFtIE1hbmFnZW1lbnQgY29udHJhY3QgYWRkcmVzczogJHtFWEFNX01BTkFHRU1FTlRfQUREUkVTU31gKTtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygnQ29uZmlndXJhdGlvbiB2YWxpZGF0ZWQgc3VjY2Vzc2Z1bGx5OicsIHtcbiAgICAgIElERU5USVRZX0NPTlRSQUNUX0FERFJFU1MsXG4gICAgICBDRVJUSUZJQ0FURVNfQ09OVFJBQ1RfQUREUkVTUyxcbiAgICAgIEFETUlOX0FERFJFU1MsXG4gICAgICBFWEFNX01BTkFHRU1FTlRfQUREUkVTUyxcbiAgICAgIENIQUlOX0lEOiBnZXRDb25maWcoJ0NIQUlOX0lEJyksXG4gICAgICBORVRXT1JLX1VSTDogZ2V0Q29uZmlnKCdORVRXT1JLX1VSTCcpXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdDb25maWd1cmF0aW9uIHZhbGlkYXRpb24gZmFpbGVkOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxuLy8gRGVidWcgZW52aXJvbm1lbnQgdmFyaWFibGVzXG5jb25zb2xlLmxvZygnRW52aXJvbm1lbnQgdmFyaWFibGVzIGNoZWNrOicsIHtcbiAgSURFTlRJVFlfQ09OVFJBQ1RfQUREUkVTUyxcbiAgQ0VSVElGSUNBVEVTX0NPTlRSQUNUX0FERFJFU1MsXG4gIEFETUlOX0FERFJFU1MsXG4gIEVYQU1fTUFOQUdFTUVOVF9BRERSRVNTLFxuICBDSEFJTl9JRDogRVhQRUNURURfTkVUV09SSy5jaGFpbklkLFxuICBORVRXT1JLX1VSTDogRVhQRUNURURfTkVUV09SSy5ycGNVcmxcbn0pO1xuXG4vLyBSb2xlIG1hcHBpbmcgd2l0aCBwcm9wZXIgdHlwZXNcbmNvbnN0IFVTRVJfUk9MRVMgPSB7XG4gIE5PTkU6IDAsXG4gIFNUVURFTlQ6IDEsXG4gIElOU1RJVFVUSU9OOiAyLFxuICBFTVBMT1lFUjogMyxcbiAgQURNSU46IDRcbn0gYXMgY29uc3Q7XG5cbnR5cGUgUm9sZVZhbHVlID0gdHlwZW9mIFVTRVJfUk9MRVNba2V5b2YgdHlwZW9mIFVTRVJfUk9MRVNdO1xudHlwZSBSb2xlU3RyaW5nID0gJ25vbmUnIHwgJ3N0dWRlbnQnIHwgJ2luc3RpdHV0aW9uJyB8ICdlbXBsb3llcicgfCAnYWRtaW4nO1xuXG5jb25zdCByb2xlTWFwOiBSZWNvcmQ8Um9sZVZhbHVlLCBSb2xlU3RyaW5nPiA9IHtcbiAgW1VTRVJfUk9MRVMuTk9ORV06ICdub25lJyxcbiAgW1VTRVJfUk9MRVMuU1RVREVOVF06ICdzdHVkZW50JyxcbiAgW1VTRVJfUk9MRVMuSU5TVElUVVRJT05dOiAnaW5zdGl0dXRpb24nLFxuICBbVVNFUl9ST0xFUy5FTVBMT1lFUl06ICdlbXBsb3llcicsXG4gIFtVU0VSX1JPTEVTLkFETUlOXTogJ2FkbWluJ1xufTtcblxuZXhwb3J0IGNvbnN0IGdldENvbnRyYWN0cyA9IGFzeW5jICgpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygnQ29udHJhY3QgQWRkcmVzc2VzOicsIHtcbiAgICAgIElkZW50aXR5OiBJREVOVElUWV9DT05UUkFDVF9BRERSRVNTLFxuICAgICAgQ2VydGlmaWNhdGVzOiBDRVJUSUZJQ0FURVNfQ09OVFJBQ1RfQUREUkVTUyxcbiAgICAgIEFkbWluOiBBRE1JTl9BRERSRVNTXG4gICAgfSk7XG5cbiAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IGdldFByb3ZpZGVyKCk7XG4gICAgYXdhaXQgdmFsaWRhdGVOZXR3b3JrKHByb3ZpZGVyKTtcbiAgICBjb25zb2xlLmxvZygnTmV0d29yayB2YWxpZGF0aW9uIHBhc3NlZCcpO1xuICAgIFxuICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IGdldFNpZ25lcigpO1xuICAgIGNvbnN0IHVzZXJBZGRyZXNzID0gYXdhaXQgc2lnbmVyLmdldEFkZHJlc3MoKTtcbiAgICBcbiAgICBjb25zb2xlLmxvZygnQ29ubmVjdGVkIHdpdGggYWRkcmVzczonLCB1c2VyQWRkcmVzcyk7XG4gICAgXG4gICAgY29uc3QgdXNlckJhbGFuY2UgPSBhd2FpdCBwcm92aWRlci5nZXRCYWxhbmNlKHVzZXJBZGRyZXNzKTtcbiAgICBjb25zb2xlLmxvZygnVXNlciBiYWxhbmNlOicsIGZvcm1hdFVuaXRzKHVzZXJCYWxhbmNlLCAnZXRoZXInKSwgJ0VUSCcpO1xuICAgIFxuICAgIGNvbnN0IGlkZW50aXR5Q29udHJhY3QgPSBuZXcgQ29udHJhY3QoXG4gICAgICBJREVOVElUWV9DT05UUkFDVF9BRERSRVNTISxcbiAgICAgIElkZW50aXR5QUJJLFxuICAgICAgc2lnbmVyXG4gICAgKTtcblxuICAgIGNvbnNvbGUubG9nKCdWZXJpZnlpbmcgY29udHJhY3QgZXhpc3RzIGF0IGFkZHJlc3M6JywgSURFTlRJVFlfQ09OVFJBQ1RfQUREUkVTUyk7XG4gICAgY29uc3QgY29kZSA9IGF3YWl0IHByb3ZpZGVyLmdldENvZGUoSURFTlRJVFlfQ09OVFJBQ1RfQUREUkVTUyEpO1xuICAgIGNvbnNvbGUubG9nKCdDb250cmFjdCBjb2RlIGxlbmd0aDonLCBjb2RlLmxlbmd0aCk7XG4gICAgY29uc29sZS5sb2coJ0NvbnRyYWN0IGV4aXN0czonLCBjb2RlICE9PSAnMHgnKTtcbiAgICBcbiAgICBpZiAoY29kZSA9PT0gJzB4Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJZGVudGl0eSBjb250cmFjdCBub3QgZm91bmQgYXQgYWRkcmVzczogJHtJREVOVElUWV9DT05UUkFDVF9BRERSRVNTfWApO1xuICAgIH1cblxuICAgIGNvbnN0IGNlcnRpZmljYXRlc0NvbnRyYWN0ID0gbmV3IENvbnRyYWN0KFxuICAgICAgQ0VSVElGSUNBVEVTX0NPTlRSQUNUX0FERFJFU1MhLFxuICAgICAgQ2VydGlmaWNhdGVzQUJJLFxuICAgICAgc2lnbmVyXG4gICAgKTtcblxuICAgIGNvbnN0IGV4YW1NYW5hZ2VtZW50Q29udHJhY3QgPSBuZXcgQ29udHJhY3QoXG4gICAgICBFWEFNX01BTkFHRU1FTlRfQUREUkVTUyEsXG4gICAgICBFWEFNX01BTkFHRU1FTlRfQUJJLFxuICAgICAgc2lnbmVyXG4gICAgKTtcblxuICAgIHJldHVybiB7IGlkZW50aXR5Q29udHJhY3QsIGNlcnRpZmljYXRlc0NvbnRyYWN0LCBleGFtTWFuYWdlbWVudENvbnRyYWN0LCBwcm92aWRlciwgc2lnbmVyIH07XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbml0aWFsaXppbmcgY29udHJhY3RzOicsIGVycm9yKTtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZXRhaWxzOicsIHtcbiAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICBjb2RlOiBlcnJvci5jb2RlLFxuICAgICAgcmVhc29uOiBlcnJvci5yZWFzb25cbiAgICB9KTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBpbml0aWFsaXplIGNvbnRyYWN0czogJHtlcnJvci5tZXNzYWdlfWApO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgcmVnaXN0ZXJVc2VyID0gYXN5bmMgKHJvbGU6IHN0cmluZykgPT4ge1xuICBpZiAoIXJvbGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JvbGUgaXMgcmVxdWlyZWQnKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgeyBpZGVudGl0eUNvbnRyYWN0LCBzaWduZXIgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xuICAgIFxuICAgIC8vIEdldCBuZXR3b3JrIGRldGFpbHMgYW5kIHVzZXIgYWRkcmVzc1xuICAgIGNvbnN0IHVzZXJBZGRyZXNzID0gYXdhaXQgc2lnbmVyLmdldEFkZHJlc3MoKTtcbiAgICBjb25zb2xlLmxvZygnUmVnaXN0ZXJpbmcgYWRkcmVzczonLCB1c2VyQWRkcmVzcyk7XG4gICAgY29uc29sZS5sb2coJ1dpdGggcm9sZTonLCByb2xlKTtcbiAgICBcbiAgICAvLyBTcGVjaWFsIGhhbmRsaW5nIGZvciBhZG1pbiBhZGRyZXNzXG4gICAgaWYgKEFETUlOX0FERFJFU1MgJiYgdXNlckFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gQURNSU5fQUREUkVTUy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICBjb25zb2xlLmxvZygnVGhpcyBpcyB0aGUgYWRtaW4gYWRkcmVzcywgc2V0dGluZyBhZG1pbiByb2xlLi4uJyk7XG4gICAgICByZXR1cm4gYXdhaXQgc2V0QWRtaW5Sb2xlKCk7XG4gICAgfVxuICAgIFxuICAgIC8vIENvbnZlcnQgcm9sZSBzdHJpbmcgdG8gZW51bSB2YWx1ZVxuICAgIGNvbnN0IHJvbGVNYXA6IHsgW2tleTogc3RyaW5nXTogbnVtYmVyIH0gPSB7XG4gICAgICAnc3R1ZGVudCc6IFVTRVJfUk9MRVMuU1RVREVOVCxcbiAgICAgICdpbnN0aXR1dGlvbic6IFVTRVJfUk9MRVMuSU5TVElUVVRJT04sXG4gICAgICAnZW1wbG95ZXInOiBVU0VSX1JPTEVTLkVNUExPWUVSLFxuICAgICAgJ2FkbWluJzogVVNFUl9ST0xFUy5BRE1JTlxuICAgIH07XG4gICAgXG4gICAgY29uc3Qgcm9sZVZhbHVlID0gcm9sZU1hcFtyb2xlLnRvTG93ZXJDYXNlKCldO1xuICAgIGlmIChyb2xlVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHJvbGU6ICR7cm9sZX0uIE11c3QgYmUgb25lIG9mOiBzdHVkZW50LCBpbnN0aXR1dGlvbiwgZW1wbG95ZXIsIGFkbWluYCk7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ1JvbGUgdmFsdWUgZnJvbSBtYXBwaW5nOicsIHJvbGVWYWx1ZSk7XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgdXNlciBpcyBhbHJlYWR5IHJlZ2lzdGVyZWRcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ0NoZWNraW5nIGlmIHVzZXIgYWxyZWFkeSBleGlzdHMuLi4nKTtcbiAgICAgIGNvbnN0IGV4aXN0aW5nUm9sZSA9IGF3YWl0IGlkZW50aXR5Q29udHJhY3QuZ2V0VXNlclJvbGUodXNlckFkZHJlc3MpO1xuICAgICAgY29uc29sZS5sb2coJ0V4aXN0aW5nIHJvbGU6JywgZXhpc3RpbmdSb2xlKTtcbiAgICAgIFxuICAgICAgaWYgKGV4aXN0aW5nUm9sZSA+IDApIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1VzZXIgYWxyZWFkeSByZWdpc3RlcmVkIHdpdGggcm9sZTonLCBleGlzdGluZ1JvbGUpO1xuICAgICAgICBcbiAgICAgICAgLy8gSWYgdXNlciBleGlzdHMgYnV0IG5lZWRzIHZlcmlmaWNhdGlvblxuICAgICAgICBjb25zdCBpc1ZlcmlmaWVkID0gYXdhaXQgaWRlbnRpdHlDb250cmFjdC5pc1ZlcmlmaWVkKHVzZXJBZGRyZXNzKTtcbiAgICAgICAgaWYgKCFpc1ZlcmlmaWVkKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1VzZXIgZXhpc3RzIGJ1dCBub3QgdmVyaWZpZWQsIGF0dGVtcHRpbmcgdmVyaWZpY2F0aW9uLi4uJyk7XG4gICAgICAgICAgY29uc3QgdmVyaWZ5VHggPSBhd2FpdCBpZGVudGl0eUNvbnRyYWN0LnZlcmlmeVVzZXIodXNlckFkZHJlc3MpO1xuICAgICAgICAgIGF3YWl0IHZlcmlmeVR4LndhaXQoKTtcbiAgICAgICAgICBjb25zb2xlLmxvZygnVXNlciB2ZXJpZmllZCBzdWNjZXNzZnVsbHknKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiAnZXhpc3RpbmcnLCByb2xlOiBleGlzdGluZ1JvbGUgfTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBpZiAoIWVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ1VzZXIgZG9lcyBub3QgZXhpc3QnKSkge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUubG9nKCdVc2VyIGRvZXMgbm90IGV4aXN0LCBwcm9jZWVkaW5nIHdpdGggcmVnaXN0cmF0aW9uJyk7XG4gICAgfVxuICAgIFxuICAgIC8vIFJlZ2lzdGVyIHVzZXJcbiAgICBjb25zb2xlLmxvZygnUmVnaXN0ZXJpbmcgbmV3IHVzZXIgd2l0aCByb2xlOicsIHJvbGVWYWx1ZSk7XG4gICAgY29uc3QgdHggPSBhd2FpdCBpZGVudGl0eUNvbnRyYWN0LnJlZ2lzdGVyVXNlcihyb2xlVmFsdWUsIFwiXCIpO1xuICAgIGNvbnNvbGUubG9nKCdSZWdpc3RyYXRpb24gdHJhbnNhY3Rpb24gc2VudDonLCB0eC5oYXNoKTtcbiAgICBcbiAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdHgud2FpdCgpO1xuICAgIGNvbnNvbGUubG9nKCdSZWdpc3RyYXRpb24gc3VjY2Vzc2Z1bDonLCByZWNlaXB0Lmhhc2gpO1xuICAgIFxuICAgIC8vIFZlcmlmeSB0aGUgdXNlciBhdXRvbWF0aWNhbGx5XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCdBdHRlbXB0aW5nIGF1dG9tYXRpYyB2ZXJpZmljYXRpb24uLi4nKTtcbiAgICAgIGNvbnN0IHZlcmlmeVR4ID0gYXdhaXQgaWRlbnRpdHlDb250cmFjdC52ZXJpZnlVc2VyKHVzZXJBZGRyZXNzKTtcbiAgICAgIGF3YWl0IHZlcmlmeVR4LndhaXQoKTtcbiAgICAgIGNvbnNvbGUubG9nKCdVc2VyIHZlcmlmaWVkIHN1Y2Nlc3NmdWxseScpO1xuICAgIH0gY2F0Y2ggKHZlcmlmeUVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0F1dG9tYXRpYyB2ZXJpZmljYXRpb24gZmFpbGVkOicsIHZlcmlmeUVycm9yKTtcbiAgICAgIC8vIENvbnRpbnVlIGV2ZW4gaWYgdmVyaWZpY2F0aW9uIGZhaWxzXG4gICAgfVxuICAgIFxuICAgIC8vIElmIHJlZ2lzdGVyaW5nIGFzIGFkbWluLCBzZXQgYWRtaW4gcm9sZVxuICAgIGlmIChyb2xlLnRvTG93ZXJDYXNlKCkgPT09ICdhZG1pbicpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdTZXR0aW5nIGFkbWluIHByaXZpbGVnZXMuLi4nKTtcbiAgICAgIGF3YWl0IHNldEFkbWluUm9sZSgpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4geyBzdGF0dXM6ICdzdWNjZXNzJywgcm9sZTogcm9sZVZhbHVlLCB0cmFuc2FjdGlvbjogdHggfTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIHJldHVybiBoYW5kbGVDb250cmFjdEVycm9yKGVycm9yKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHZlcmlmeVVzZXIgPSBhc3luYyAoYWRkcmVzczogc3RyaW5nKSA9PiB7XG4gIHRyeSB7XG4gICAgZ2V0QWRkcmVzcyhhZGRyZXNzKTsgLy8gVXNpbmcgZ2V0QWRkcmVzcyBpbnN0ZWFkIG9mIGlzQWRkcmVzc1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhZGRyZXNzJyk7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCdWZXJpZnlpbmcgdXNlcjonLCBhZGRyZXNzKTtcbiAgICBjb25zdCB7IGlkZW50aXR5Q29udHJhY3QgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xuICAgIGNvbnN0IGlzVmVyaWZpZWQgPSBhd2FpdCBpZGVudGl0eUNvbnRyYWN0LmlzVmVyaWZpZWQoYWRkcmVzcyk7XG4gICAgY29uc29sZS5sb2coJ1VzZXIgdmVyaWZpY2F0aW9uIHN0YXR1czonLCBpc1ZlcmlmaWVkKTtcbiAgICByZXR1cm4gaXNWZXJpZmllZDtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIHZlcmlmeVVzZXI6JywgZXJyb3IpO1xuICAgIHJldHVybiBoYW5kbGVDb250cmFjdEVycm9yKGVycm9yKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGdldFVzZXJSb2xlID0gYXN5bmMgKGFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8Um9sZVN0cmluZz4gPT4ge1xuICB0cnkge1xuICAgIGdldEFkZHJlc3MoYWRkcmVzcyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFkZHJlc3MnKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ0dldHRpbmcgdXNlciByb2xlIGZvcjonLCBhZGRyZXNzKTtcbiAgICBjb25zdCB7IGlkZW50aXR5Q29udHJhY3QgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xuICAgIGNvbnN0IHJvbGUgPSBhd2FpdCBpZGVudGl0eUNvbnRyYWN0LmdldFVzZXJSb2xlKGFkZHJlc3MpO1xuICAgIGNvbnNvbGUubG9nKCdVc2VyIHJvbGU6Jywgcm9sZSk7XG4gICAgcmV0dXJuIHJvbGU7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBnZXRVc2VyUm9sZTonLCBlcnJvcik7XG4gICAgcmV0dXJuIGhhbmRsZUNvbnRyYWN0RXJyb3IoZXJyb3IpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgaXNzdWVDZXJ0aWZpY2F0ZSA9IGFzeW5jIChzdHVkZW50QWRkcmVzczogc3RyaW5nLCBpcGZzSGFzaDogc3RyaW5nKSA9PiB7XG4gIGlmICghc3R1ZGVudEFkZHJlc3MgfHwgIWlwZnNIYXNoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTdHVkZW50IGFkZHJlc3MgYW5kIElQRlMgaGFzaCBhcmUgcmVxdWlyZWQnKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgeyBjZXJ0aWZpY2F0ZXNDb250cmFjdCB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XG4gICAgY29uc3QgdHggPSBhd2FpdCBjZXJ0aWZpY2F0ZXNDb250cmFjdC5pc3N1ZUNlcnRpZmljYXRlKHN0dWRlbnRBZGRyZXNzLCBpcGZzSGFzaCk7XG4gICAgYXdhaXQgdHgud2FpdCgpO1xuICAgIHJldHVybiB0eDtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGlzc3VpbmcgY2VydGlmaWNhdGU6JywgZXJyb3IpO1xuICAgIHJldHVybiBoYW5kbGVDb250cmFjdEVycm9yKGVycm9yKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHZlcmlmeUNlcnRpZmljYXRlID0gYXN5bmMgKGNlcnRpZmljYXRlSWQ6IHN0cmluZykgPT4ge1xuICBpZiAoIWNlcnRpZmljYXRlSWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NlcnRpZmljYXRlIElEIGlzIHJlcXVpcmVkJyk7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IHsgY2VydGlmaWNhdGVzQ29udHJhY3QgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xuICAgIGNvbnN0IGlzVmFsaWQgPSBhd2FpdCBjZXJ0aWZpY2F0ZXNDb250cmFjdC52ZXJpZnlDZXJ0aWZpY2F0ZShjZXJ0aWZpY2F0ZUlkKTtcbiAgICByZXR1cm4gaXNWYWxpZDtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHZlcmlmeWluZyBjZXJ0aWZpY2F0ZTonLCBlcnJvcik7XG4gICAgcmV0dXJuIGhhbmRsZUNvbnRyYWN0RXJyb3IoZXJyb3IpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0Q2VydGlmaWNhdGVzID0gYXN5bmMgKGFkZHJlc3M6IHN0cmluZykgPT4ge1xuICB0cnkge1xuICAgIGdldEFkZHJlc3MoYWRkcmVzcyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFkZHJlc3MnKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ0dldHRpbmcgY2VydGlmaWNhdGVzIGZvcjonLCBhZGRyZXNzKTtcbiAgICBjb25zdCB7IGNlcnRpZmljYXRlc0NvbnRyYWN0IH0gPSBhd2FpdCBnZXRDb250cmFjdHMoKTtcbiAgICBjb25zdCBjZXJ0aWZpY2F0ZXMgPSBhd2FpdCBjZXJ0aWZpY2F0ZXNDb250cmFjdC5nZXRDZXJ0aWZpY2F0ZXMoYWRkcmVzcyk7XG4gICAgY29uc29sZS5sb2coJ0NlcnRpZmljYXRlczonLCBjZXJ0aWZpY2F0ZXMpO1xuICAgIHJldHVybiBjZXJ0aWZpY2F0ZXM7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBnZXRDZXJ0aWZpY2F0ZXM6JywgZXJyb3IpO1xuICAgIHJldHVybiBoYW5kbGVDb250cmFjdEVycm9yKGVycm9yKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGlzVmVyaWZpZWRVc2VyID0gYXN5bmMgKGFkZHJlc3M6IHN0cmluZykgPT4ge1xuICB0cnkge1xuICAgIGdldEFkZHJlc3MoYWRkcmVzcyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFkZHJlc3MnKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ0NoZWNraW5nIGlmIHVzZXIgaXMgdmVyaWZpZWQ6JywgYWRkcmVzcyk7XG4gICAgY29uc3QgeyBpZGVudGl0eUNvbnRyYWN0IH0gPSBhd2FpdCBnZXRDb250cmFjdHMoKTtcbiAgICBjb25zdCBpc1ZlcmlmaWVkID0gYXdhaXQgaWRlbnRpdHlDb250cmFjdC5pc1ZlcmlmaWVkKGFkZHJlc3MpO1xuICAgIGNvbnNvbGUubG9nKCdVc2VyIHZlcmlmaWNhdGlvbiBzdGF0dXM6JywgaXNWZXJpZmllZCk7XG4gICAgcmV0dXJuIGlzVmVyaWZpZWQ7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBpc1ZlcmlmaWVkVXNlcjonLCBlcnJvcik7XG4gICAgcmV0dXJuIGhhbmRsZUNvbnRyYWN0RXJyb3IoZXJyb3IpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgaXNPd25lciA9IGFzeW5jIChhZGRyZXNzOiBzdHJpbmcpID0+IHtcbiAgdHJ5IHtcbiAgICBnZXRBZGRyZXNzKGFkZHJlc3MpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhZGRyZXNzJyk7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCdDaGVja2luZyBpZiB1c2VyIGlzIG93bmVyOicsIGFkZHJlc3MpO1xuICAgIGNvbnN0IHsgaWRlbnRpdHlDb250cmFjdCB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XG4gICAgY29uc3Qgb3duZXJBZGRyZXNzID0gYXdhaXQgaWRlbnRpdHlDb250cmFjdC5vd25lcigpO1xuICAgIGNvbnN0IGlzT3duZXJSb2xlID0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSBvd25lckFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zb2xlLmxvZygnVXNlciBvd25lciBzdGF0dXM6JywgaXNPd25lclJvbGUpO1xuICAgIHJldHVybiBpc093bmVyUm9sZTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGlzT3duZXI6JywgZXJyb3IpO1xuICAgIHJldHVybiBoYW5kbGVDb250cmFjdEVycm9yKGVycm9yKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHZlcmlmeUluc3RpdHV0aW9uID0gYXN5bmMgKGluc3RpdHV0aW9uQWRkcmVzczogc3RyaW5nKSA9PiB7XG4gIHRyeSB7XG4gICAgZ2V0QWRkcmVzcyhpbnN0aXR1dGlvbkFkZHJlc3MpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnN0aXR1dGlvbiBhZGRyZXNzJyk7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCdWZXJpZnlpbmcgaW5zdGl0dXRpb246JywgaW5zdGl0dXRpb25BZGRyZXNzKTtcbiAgICBjb25zdCB7IGlkZW50aXR5Q29udHJhY3QgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xuICAgIGNvbnN0IHR4ID0gYXdhaXQgaWRlbnRpdHlDb250cmFjdC52ZXJpZnlVc2VyKGluc3RpdHV0aW9uQWRkcmVzcyk7XG4gICAgYXdhaXQgdHgud2FpdCgpO1xuICAgIGNvbnNvbGUubG9nKCdJbnN0aXR1dGlvbiB2ZXJpZmllZCBzdWNjZXNzZnVsbHknKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIHZlcmlmeUluc3RpdHV0aW9uOicsIGVycm9yKTtcbiAgICByZXR1cm4gaGFuZGxlQ29udHJhY3RFcnJvcihlcnJvcik7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBnZXRPd25lckFkZHJlc3MgPSBhc3luYyAoKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBpZGVudGl0eUNvbnRyYWN0IH0gPSBhd2FpdCBnZXRDb250cmFjdHMoKTtcbiAgICBjb25zdCBvd25lciA9IGF3YWl0IGlkZW50aXR5Q29udHJhY3Qub3duZXIoKTtcbiAgICByZXR1cm4gb3duZXI7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIG93bmVyIGFkZHJlc3M6JywgZXJyb3IpO1xuICAgIHJldHVybiBoYW5kbGVDb250cmFjdEVycm9yKGVycm9yKTtcbiAgfVxufTtcblxuLy8gQWRkIGV4YW0gbWFuYWdlbWVudCBmdW5jdGlvbnNcbmV4cG9ydCBjb25zdCBjcmVhdGVFeGFtID0gYXN5bmMgKFxuICBpZDogc3RyaW5nLFxuICB0aXRsZTogc3RyaW5nLFxuICBkZXNjcmlwdGlvbjogc3RyaW5nLFxuICBkYXRlOiBudW1iZXIsXG4gIGR1cmF0aW9uOiBudW1iZXIsXG4gIGlwZnNIYXNoOiBzdHJpbmdcbikgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgZXhhbU1hbmFnZW1lbnRDb250cmFjdCB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XG4gICAgY29uc3QgdHggPSBhd2FpdCBleGFtTWFuYWdlbWVudENvbnRyYWN0LmNyZWF0ZUV4YW0oaWQsIHRpdGxlLCBkZXNjcmlwdGlvbiwgZGF0ZSwgZHVyYXRpb24sIGlwZnNIYXNoKTtcbiAgICBhd2FpdCB0eC53YWl0KCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBleGFtOicsIGVycm9yKTtcbiAgICByZXR1cm4gaGFuZGxlQ29udHJhY3RFcnJvcihlcnJvcik7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBzdWJtaXRFeGFtUmVzdWx0ID0gYXN5bmMgKFxuICBleGFtSWQ6IHN0cmluZyxcbiAgc3R1ZGVudDogc3RyaW5nLFxuICBzY29yZTogbnVtYmVyLFxuICBncmFkZTogc3RyaW5nLFxuICBpcGZzSGFzaDogc3RyaW5nXG4pID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGV4YW1NYW5hZ2VtZW50Q29udHJhY3QgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xuICAgIGNvbnN0IHR4ID0gYXdhaXQgZXhhbU1hbmFnZW1lbnRDb250cmFjdC5zdWJtaXRFeGFtUmVzdWx0KGV4YW1JZCwgc3R1ZGVudCwgc2NvcmUsIGdyYWRlLCBpcGZzSGFzaCk7XG4gICAgYXdhaXQgdHgud2FpdCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3Igc3VibWl0dGluZyBleGFtIHJlc3VsdDonLCBlcnJvcik7XG4gICAgcmV0dXJuIGhhbmRsZUNvbnRyYWN0RXJyb3IoZXJyb3IpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgdXBkYXRlRXhhbVN0YXR1cyA9IGFzeW5jIChleGFtSWQ6IHN0cmluZywgc3RhdHVzOiBzdHJpbmcpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGV4YW1NYW5hZ2VtZW50Q29udHJhY3QgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xuICAgIGNvbnN0IHR4ID0gYXdhaXQgZXhhbU1hbmFnZW1lbnRDb250cmFjdC51cGRhdGVFeGFtU3RhdHVzKGV4YW1JZCwgc3RhdHVzKTtcbiAgICBhd2FpdCB0eC53YWl0KCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBleGFtIHN0YXR1czonLCBlcnJvcik7XG4gICAgcmV0dXJuIGhhbmRsZUNvbnRyYWN0RXJyb3IoZXJyb3IpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0RXhhbSA9IGFzeW5jIChleGFtSWQ6IHN0cmluZykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgZXhhbU1hbmFnZW1lbnRDb250cmFjdCB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XG4gICAgY29uc3QgZXhhbSA9IGF3YWl0IGV4YW1NYW5hZ2VtZW50Q29udHJhY3QuZ2V0RXhhbShleGFtSWQpO1xuICAgIHJldHVybiBleGFtO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBleGFtOicsIGVycm9yKTtcbiAgICByZXR1cm4gaGFuZGxlQ29udHJhY3RFcnJvcihlcnJvcik7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBnZXRFeGFtUmVzdWx0ID0gYXN5bmMgKGV4YW1JZDogc3RyaW5nLCBzdHVkZW50OiBzdHJpbmcpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGV4YW1NYW5hZ2VtZW50Q29udHJhY3QgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV4YW1NYW5hZ2VtZW50Q29udHJhY3QuZ2V0RXhhbVJlc3VsdChleGFtSWQsIHN0dWRlbnQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIGV4YW0gcmVzdWx0OicsIGVycm9yKTtcbiAgICByZXR1cm4gaGFuZGxlQ29udHJhY3RFcnJvcihlcnJvcik7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBnZXRJbnN0aXR1dGlvbkV4YW1zID0gYXN5bmMgKGluc3RpdHV0aW9uOiBzdHJpbmcpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGV4YW1NYW5hZ2VtZW50Q29udHJhY3QgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xuICAgIGNvbnN0IGV4YW1zID0gYXdhaXQgZXhhbU1hbmFnZW1lbnRDb250cmFjdC5nZXRJbnN0aXR1dGlvbkV4YW1zKGluc3RpdHV0aW9uKTtcbiAgICByZXR1cm4gZXhhbXM7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIGluc3RpdHV0aW9uIGV4YW1zOicsIGVycm9yKTtcbiAgICByZXR1cm4gaGFuZGxlQ29udHJhY3RFcnJvcihlcnJvcik7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBnZXRTdHVkZW50RXhhbXMgPSBhc3luYyAoc3R1ZGVudDogc3RyaW5nKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBleGFtTWFuYWdlbWVudENvbnRyYWN0IH0gPSBhd2FpdCBnZXRDb250cmFjdHMoKTtcbiAgICBjb25zdCBleGFtcyA9IGF3YWl0IGV4YW1NYW5hZ2VtZW50Q29udHJhY3QuZ2V0U3R1ZGVudEV4YW1zKHN0dWRlbnQpO1xuICAgIHJldHVybiBleGFtcztcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgc3R1ZGVudCBleGFtczonLCBlcnJvcik7XG4gICAgcmV0dXJuIGhhbmRsZUNvbnRyYWN0RXJyb3IoZXJyb3IpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgZW5yb2xsU3R1ZGVudCA9IGFzeW5jIChleGFtSWQ6IHN0cmluZywgc3R1ZGVudEFkZHJlc3M6IHN0cmluZykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgZXhhbU1hbmFnZW1lbnRDb250cmFjdCB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XG4gICAgY29uc3QgdHggPSBhd2FpdCBleGFtTWFuYWdlbWVudENvbnRyYWN0LmVucm9sbFN0dWRlbnQoZXhhbUlkLCBzdHVkZW50QWRkcmVzcyk7XG4gICAgYXdhaXQgdHgud2FpdCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZW5yb2xsaW5nIHN0dWRlbnQ6JywgZXJyb3IpO1xuICAgIHJldHVybiBoYW5kbGVDb250cmFjdEVycm9yKGVycm9yKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGdldENvbnRyYWN0ID0gYXN5bmMgKCkgPT4ge1xuICBjb25zdCB7IGV4YW1NYW5hZ2VtZW50Q29udHJhY3QgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xuICByZXR1cm4gZXhhbU1hbmFnZW1lbnRDb250cmFjdDtcbn07XG5cbmV4cG9ydCBjb25zdCBzZXRBZG1pblJvbGUgPSBhc3luYyAoKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBpZGVudGl0eUNvbnRyYWN0LCBzaWduZXIgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xuICAgIGNvbnN0IHVzZXJBZGRyZXNzID0gYXdhaXQgc2lnbmVyLmdldEFkZHJlc3MoKTtcbiAgICBcbiAgICBjb25zb2xlLmxvZygnU2V0dGluZyBhZG1pbiByb2xlIGZvciBhZGRyZXNzOicsIHVzZXJBZGRyZXNzKTtcbiAgICBjb25zb2xlLmxvZygnRXhwZWN0ZWQgYWRtaW4gYWRkcmVzczonLCBBRE1JTl9BRERSRVNTKTtcbiAgICBcbiAgICAvLyBGaXJzdCBjaGVjayBpZiB0aGUgYWRkcmVzcyBpcyBhbHJlYWR5IGFuIGFkbWluXG4gICAgY29uc3QgaXNBZG1pbiA9IGF3YWl0IGlkZW50aXR5Q29udHJhY3QuaXNBZG1pbih1c2VyQWRkcmVzcyk7XG4gICAgY29uc29sZS5sb2coJ0lzIGFscmVhZHkgYWRtaW4/JywgaXNBZG1pbik7XG4gICAgXG4gICAgaWYgKGlzQWRtaW4pIHtcbiAgICAgIGNvbnNvbGUubG9nKCdVc2VyIGlzIGFscmVhZHkgYW4gYWRtaW4nKTtcbiAgICAgIHJldHVybiB7IHN0YXR1czogJ2V4aXN0aW5nJywgaXNBZG1pbjogdHJ1ZSB9O1xuICAgIH1cbiAgICBcbiAgICAvLyBDaGVjayBpZiB0aGlzIGlzIHRoZSBjb25maWd1cmVkIGFkbWluIGFkZHJlc3NcbiAgICBpZiAoQURNSU5fQUREUkVTUyAmJiB1c2VyQWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSBBRE1JTl9BRERSRVNTLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdBZGRyZXNzIG1hdGNoZXMgY29uZmlndXJlZCBhZG1pbiwgYWRkaW5nIGFzIGFkbWluLi4uJyk7XG4gICAgICBcbiAgICAgIC8vIEZpcnN0IHRyeSB0byByZWdpc3RlciBhcyBhZG1pbiBpZiBub3QgYWxyZWFkeSByZWdpc3RlcmVkXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByb2xlID0gYXdhaXQgaWRlbnRpdHlDb250cmFjdC5nZXRVc2VyUm9sZSh1c2VyQWRkcmVzcyk7XG4gICAgICAgIGlmIChyb2xlID09PSAwKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1JlZ2lzdGVyaW5nIGFkbWluIHVzZXIgZmlyc3QuLi4nKTtcbiAgICAgICAgICBjb25zdCByZWdUeCA9IGF3YWl0IGlkZW50aXR5Q29udHJhY3QucmVnaXN0ZXJVc2VyKFVTRVJfUk9MRVMuQURNSU4sIFwiXCIpO1xuICAgICAgICAgIGF3YWl0IHJlZ1R4LndhaXQoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICBpZiAoIWVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ1VzZXIgZG9lcyBub3QgZXhpc3QnKSkge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHVzZXIgZG9lc24ndCBleGlzdCwgcmVnaXN0ZXIgdGhlbSBhcyBhZG1pblxuICAgICAgICBjb25zb2xlLmxvZygnUmVnaXN0ZXJpbmcgbmV3IGFkbWluIHVzZXIuLi4nKTtcbiAgICAgICAgY29uc3QgcmVnVHggPSBhd2FpdCBpZGVudGl0eUNvbnRyYWN0LnJlZ2lzdGVyVXNlcihVU0VSX1JPTEVTLkFETUlOLCBcIlwiKTtcbiAgICAgICAgYXdhaXQgcmVnVHgud2FpdCgpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBWZXJpZnkgdGhlIHVzZXJcbiAgICAgIGNvbnNvbGUubG9nKCdWZXJpZnlpbmcgYWRtaW4gdXNlci4uLicpO1xuICAgICAgY29uc3QgdmVyaWZ5VHggPSBhd2FpdCBpZGVudGl0eUNvbnRyYWN0LnZlcmlmeVVzZXIodXNlckFkZHJlc3MpO1xuICAgICAgYXdhaXQgdmVyaWZ5VHgud2FpdCgpO1xuICAgICAgXG4gICAgICAvLyBBZGQgYWRtaW4gcm9sZVxuICAgICAgY29uc29sZS5sb2coJ0FkZGluZyBhZG1pbiByb2xlLi4uJyk7XG4gICAgICBjb25zdCB0eCA9IGF3YWl0IGlkZW50aXR5Q29udHJhY3QuYWRkQWRtaW4odXNlckFkZHJlc3MpO1xuICAgICAgYXdhaXQgdHgud2FpdCgpO1xuICAgICAgY29uc29sZS5sb2coJ1N1Y2Nlc3NmdWxseSBhZGRlZCBhcyBhZG1pbicpO1xuICAgICAgXG4gICAgICByZXR1cm4geyBzdGF0dXM6ICdzdWNjZXNzJywgaXNBZG1pbjogdHJ1ZSB9O1xuICAgIH1cbiAgICBcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgY29uZmlndXJlZCBhZG1pbiBhZGRyZXNzZXMgY2FuIGJlIHNldCBhcyBhZG1pbicpO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3Igc2V0dGluZyBhZG1pbiByb2xlOicsIGVycm9yKTtcbiAgICByZXR1cm4gaGFuZGxlQ29udHJhY3RFcnJvcihlcnJvcik7XG4gIH1cbn07ICJdLCJuYW1lcyI6WyJDb250cmFjdCIsImZvcm1hdFVuaXRzIiwiZ2V0QWRkcmVzcyIsIkVYQU1fTUFOQUdFTUVOVF9BQkkiLCJnZXRQcm92aWRlciIsImdldFNpZ25lciIsIkVYUEVDVEVEX05FVFdPUksiLCJ2YWxpZGF0ZU5ldHdvcmsiLCJoYW5kbGVDb250cmFjdEVycm9yIiwiZ2V0Q29uZmlnIiwidmFsaWRhdGVDb25maWciLCJJZGVudGl0eUFCSSIsIkNlcnRpZmljYXRlc0FCSSIsIklERU5USVRZX0NPTlRSQUNUX0FERFJFU1MiLCJDRVJUSUZJQ0FURVNfQ09OVFJBQ1RfQUREUkVTUyIsIkFETUlOX0FERFJFU1MiLCJFWEFNX01BTkFHRU1FTlRfQUREUkVTUyIsInZhbGlkYXRlRW52IiwiRXJyb3IiLCJjb25zb2xlIiwibG9nIiwiQ0hBSU5fSUQiLCJORVRXT1JLX1VSTCIsImVycm9yIiwiY2hhaW5JZCIsInJwY1VybCIsIlVTRVJfUk9MRVMiLCJOT05FIiwiU1RVREVOVCIsIklOU1RJVFVUSU9OIiwiRU1QTE9ZRVIiLCJBRE1JTiIsInJvbGVNYXAiLCJnZXRDb250cmFjdHMiLCJJZGVudGl0eSIsIkNlcnRpZmljYXRlcyIsIkFkbWluIiwicHJvdmlkZXIiLCJzaWduZXIiLCJ1c2VyQWRkcmVzcyIsInVzZXJCYWxhbmNlIiwiZ2V0QmFsYW5jZSIsImlkZW50aXR5Q29udHJhY3QiLCJjb2RlIiwiZ2V0Q29kZSIsImxlbmd0aCIsImNlcnRpZmljYXRlc0NvbnRyYWN0IiwiZXhhbU1hbmFnZW1lbnRDb250cmFjdCIsIm1lc3NhZ2UiLCJyZWFzb24iLCJyZWdpc3RlclVzZXIiLCJyb2xlIiwidG9Mb3dlckNhc2UiLCJzZXRBZG1pblJvbGUiLCJyb2xlVmFsdWUiLCJ1bmRlZmluZWQiLCJleGlzdGluZ1JvbGUiLCJnZXRVc2VyUm9sZSIsImlzVmVyaWZpZWQiLCJ2ZXJpZnlUeCIsInZlcmlmeVVzZXIiLCJ3YWl0Iiwic3RhdHVzIiwiaW5jbHVkZXMiLCJ0eCIsImhhc2giLCJyZWNlaXB0IiwidmVyaWZ5RXJyb3IiLCJ3YXJuIiwidHJhbnNhY3Rpb24iLCJhZGRyZXNzIiwiaXNzdWVDZXJ0aWZpY2F0ZSIsInN0dWRlbnRBZGRyZXNzIiwiaXBmc0hhc2giLCJ2ZXJpZnlDZXJ0aWZpY2F0ZSIsImNlcnRpZmljYXRlSWQiLCJpc1ZhbGlkIiwiZ2V0Q2VydGlmaWNhdGVzIiwiY2VydGlmaWNhdGVzIiwiaXNWZXJpZmllZFVzZXIiLCJpc093bmVyIiwib3duZXJBZGRyZXNzIiwib3duZXIiLCJpc093bmVyUm9sZSIsInZlcmlmeUluc3RpdHV0aW9uIiwiaW5zdGl0dXRpb25BZGRyZXNzIiwiZ2V0T3duZXJBZGRyZXNzIiwiY3JlYXRlRXhhbSIsImlkIiwidGl0bGUiLCJkZXNjcmlwdGlvbiIsImRhdGUiLCJkdXJhdGlvbiIsInN1Ym1pdEV4YW1SZXN1bHQiLCJleGFtSWQiLCJzdHVkZW50Iiwic2NvcmUiLCJncmFkZSIsInVwZGF0ZUV4YW1TdGF0dXMiLCJnZXRFeGFtIiwiZXhhbSIsImdldEV4YW1SZXN1bHQiLCJyZXN1bHQiLCJnZXRJbnN0aXR1dGlvbkV4YW1zIiwiaW5zdGl0dXRpb24iLCJleGFtcyIsImdldFN0dWRlbnRFeGFtcyIsImVucm9sbFN0dWRlbnQiLCJnZXRDb250cmFjdCIsImlzQWRtaW4iLCJyZWdUeCIsImFkZEFkbWluIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./utilsFront/contracts.ts\n"));

/***/ }),

/***/ "./utilsFront/ethersConfig.ts":
/*!************************************!*\
  !*** ./utilsFront/ethersConfig.ts ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EXPECTED_NETWORK: function() { return /* binding */ EXPECTED_NETWORK; },\n/* harmony export */   formatEther: function() { return /* binding */ formatEther; },\n/* harmony export */   getContract: function() { return /* binding */ getContract; },\n/* harmony export */   getProvider: function() { return /* binding */ getProvider; },\n/* harmony export */   getSigner: function() { return /* binding */ getSigner; },\n/* harmony export */   handleContractError: function() { return /* binding */ handleContractError; },\n/* harmony export */   switchToCorrectNetwork: function() { return /* binding */ switchToCorrectNetwork; },\n/* harmony export */   validateAddress: function() { return /* binding */ validateAddress; },\n/* harmony export */   validateNetwork: function() { return /* binding */ validateNetwork; }\n/* harmony export */ });\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ethers */ \"./node_modules/.pnpm/ethers@6.13.5_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/ethers/lib.esm/index.js\");\nvar _window_ethereum;\n\n// Network configuration\nconst EXPECTED_NETWORK = {\n    chainId: \"1337\",\n    chainIdHex: \"0x539\",\n    name: \"Localhost\",\n    rpcUrl: \"http://127.0.0.1:7545\",\n    nativeCurrency: {\n        name: \"ETH\",\n        symbol: \"ETH\",\n        decimals: 18\n    }\n};\n// Function to switch to the correct network\nconst switchToCorrectNetwork = async (ethereum)=>{\n    try {\n        console.log(\"Attempting to switch network...\");\n        // First check current network\n        const currentChainId = await ethereum.request({\n            method: \"eth_chainId\"\n        });\n        console.log(\"Current chainId:\", currentChainId);\n        if (currentChainId === EXPECTED_NETWORK.chainIdHex) {\n            console.log(\"Already on correct network\");\n            return;\n        }\n        console.log(\"Switching to network:\", EXPECTED_NETWORK.chainIdHex);\n        // Try to switch to the network\n        await ethereum.request({\n            method: \"wallet_switchEthereumChain\",\n            params: [\n                {\n                    chainId: EXPECTED_NETWORK.chainIdHex\n                }\n            ]\n        });\n        // Wait a bit for the network switch to complete\n        await new Promise((resolve)=>setTimeout(resolve, 1000));\n        // Verify the switch was successful\n        const newChainId = await ethereum.request({\n            method: \"eth_chainId\"\n        });\n        if (newChainId !== EXPECTED_NETWORK.chainIdHex) {\n            throw new Error(\"Network switch failed\");\n        }\n        console.log(\"Successfully switched to correct network\");\n    } catch (switchError) {\n        console.error(\"Error in switchToCorrectNetwork:\", switchError);\n        // This error code indicates that the chain has not been added to MetaMask\n        if (switchError.code === 4902) {\n            try {\n                console.log(\"Network not found, attempting to add...\");\n                await ethereum.request({\n                    method: \"wallet_addEthereumChain\",\n                    params: [\n                        {\n                            chainId: EXPECTED_NETWORK.chainIdHex,\n                            chainName: EXPECTED_NETWORK.name,\n                            rpcUrls: [\n                                EXPECTED_NETWORK.rpcUrl\n                            ],\n                            nativeCurrency: EXPECTED_NETWORK.nativeCurrency\n                        }\n                    ]\n                });\n                // Wait a bit for the network to be added\n                await new Promise((resolve)=>setTimeout(resolve, 1000));\n                // Verify the network was added and switched to\n                const finalChainId = await ethereum.request({\n                    method: \"eth_chainId\"\n                });\n                if (finalChainId !== EXPECTED_NETWORK.chainIdHex) {\n                    throw new Error(\"Network add failed\");\n                }\n                console.log(\"Successfully added and switched to network\");\n            } catch (addError) {\n                console.error(\"Error adding network:\", addError);\n                throw new Error(\"يرجى إضافة الشبكة المحلية يدوياً | Please add the local network manually\");\n            }\n        } else {\n            console.error(\"Error switching network:\", switchError);\n            throw new Error(\"يرجى تغيير الشبكة إلى الشبكة المحلية | Please switch to local network\");\n        }\n    }\n};\n// Provider and signer functions\nconst getProvider = async ()=>{\n    if (!window.ethereum) {\n        throw new Error(\"MetaMask غير مثبت - MetaMask is not installed\");\n    }\n    try {\n        // First check if we're on the correct network before doing anything else\n        const currentChainId = await window.ethereum.request({\n            method: \"eth_chainId\"\n        });\n        console.log(\"Initial chain ID check:\", currentChainId);\n        if (currentChainId !== EXPECTED_NETWORK.chainIdHex) {\n            console.log(\"Wrong network detected, attempting to switch...\");\n            await switchToCorrectNetwork(window.ethereum);\n            // Verify the switch was successful\n            const newChainId = await window.ethereum.request({\n                method: \"eth_chainId\"\n            });\n            if (newChainId !== EXPECTED_NETWORK.chainIdHex) {\n                throw new Error(\"Failed to switch to correct network\");\n            }\n        }\n        // Only request accounts after we're on the correct network\n        await window.ethereum.request({\n            method: \"eth_requestAccounts\"\n        });\n        // Create provider using BrowserProvider\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_0__.BrowserProvider(window.ethereum);\n        return provider;\n    } catch (error) {\n        console.error(\"Error getting provider:\", error);\n        throw error;\n    }\n};\nconst getSigner = async ()=>{\n    const provider = await getProvider();\n    return provider.getSigner();\n};\nconst validateNetwork = async (provider)=>{\n    try {\n        console.log(\"Validating network...\");\n        const network = await provider.getNetwork();\n        const chainId = network.chainId.toString();\n        console.log(\"Current chainId:\", chainId, \"Expected:\", EXPECTED_NETWORK.chainId);\n        if (chainId !== EXPECTED_NETWORK.chainId) {\n            console.log(\"Wrong network detected in validateNetwork\");\n            if (!window.ethereum) {\n                throw new Error(\"يرجى الاتصال بشبكة \".concat(EXPECTED_NETWORK.name, \" (Chain ID: \").concat(EXPECTED_NETWORK.chainId, \") | Please connect to \").concat(EXPECTED_NETWORK.name, \" network\"));\n            }\n            // Get the current chain ID directly from ethereum provider\n            const currentChainId = await window.ethereum.request({\n                method: \"eth_chainId\"\n            });\n            console.log(\"Current chain ID from ethereum:\", currentChainId);\n            if (currentChainId !== EXPECTED_NETWORK.chainIdHex) {\n                await switchToCorrectNetwork(window.ethereum);\n                // Wait for the network switch to complete\n                await new Promise((resolve)=>setTimeout(resolve, 1500));\n                // Verify one final time\n                const finalChainId = await window.ethereum.request({\n                    method: \"eth_chainId\"\n                });\n                if (finalChainId !== EXPECTED_NETWORK.chainIdHex) {\n                    throw new Error(\"Network switch verification failed\");\n                }\n            }\n        }\n        console.log(\"Network validation passed\");\n    } catch (error) {\n        console.error(\"Network validation failed:\", error);\n        throw error;\n    }\n};\n// Helper functions for working with contracts\nconst getContract = (address, abi, signer)=>{\n    return new ethers__WEBPACK_IMPORTED_MODULE_0__.Contract(address, abi, signer);\n};\nconst validateAddress = (address)=>{\n    if (!address) {\n        throw new Error(\"Address is required\");\n    }\n    try {\n        return (0,ethers__WEBPACK_IMPORTED_MODULE_0__.getAddress)(address);\n    } catch (error) {\n        throw new Error(\"Invalid Ethereum address\");\n    }\n};\nconst formatEther = (value)=>{\n    return (0,ethers__WEBPACK_IMPORTED_MODULE_0__.formatUnits)(value, 18);\n};\n// Utility function to handle common contract errors\nconst handleContractError = (error)=>{\n    var _error_message, _error_message1, _error_message2;\n    console.error(\"Contract error:\", error);\n    if (error.reason) {\n        throw new Error(\"Smart contract error: \".concat(error.reason));\n    } else if ((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes(\"user rejected\")) {\n        throw new Error(\"Transaction rejected by user\");\n    } else if ((_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.includes(\"insufficient funds\")) {\n        throw new Error(\"Insufficient funds to complete the transaction\");\n    } else if ((_error_message2 = error.message) === null || _error_message2 === void 0 ? void 0 : _error_message2.includes(\"network\")) {\n        throw new Error(\"Please make sure you are connected to the correct network\");\n    } else {\n        throw new Error(\"Transaction failed. Please check your connection and try again.\");\n    }\n};\n// Event listener for network changes\nif ( true && ((_window_ethereum = window.ethereum) === null || _window_ethereum === void 0 ? void 0 : _window_ethereum.on)) {\n    window.ethereum.on(\"chainChanged\", (chainId)=>{\n        console.log(\"Network changed to:\", chainId);\n        if (chainId !== EXPECTED_NETWORK.chainIdHex) {\n            console.log(\"Wrong network after change, reloading...\");\n            window.location.reload();\n        }\n    });\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QU1DLHNCQUFzQixDQUFDcEI7UUFLdkJBLGdCQUVBQSxpQkFFQUE7SUFSWFosUUFBUVksS0FBSyxDQUFDLG1CQUFtQkE7SUFFakMsSUFBSUEsTUFBTXFCLE1BQU0sRUFBRTtRQUNoQixNQUFNLElBQUl2QixNQUFNLHlCQUFzQyxPQUFiRSxNQUFNcUIsTUFBTTtJQUN2RCxPQUFPLEtBQUlyQixpQkFBQUEsTUFBTXNCLE9BQU8sY0FBYnRCLHFDQUFBQSxlQUFldUIsUUFBUSxDQUFDLGtCQUFrQjtRQUNuRCxNQUFNLElBQUl6QixNQUFNO0lBQ2xCLE9BQU8sS0FBSUUsa0JBQUFBLE1BQU1zQixPQUFPLGNBQWJ0QixzQ0FBQUEsZ0JBQWV1QixRQUFRLENBQUMsdUJBQXVCO1FBQ3hELE1BQU0sSUFBSXpCLE1BQU07SUFDbEIsT0FBTyxLQUFJRSxrQkFBQUEsTUFBTXNCLE9BQU8sY0FBYnRCLHNDQUFBQSxnQkFBZXVCLFFBQVEsQ0FBQyxZQUFZO1FBQzdDLE1BQU0sSUFBSXpCLE1BQU07SUFDbEIsT0FBTztRQUNMLE1BQU0sSUFBSUEsTUFBTTtJQUNsQjtBQUNGLEVBQUU7QUFFRixxQ0FBcUM7QUFDckMsSUFBSSxLQUFrQixNQUFlekIsbUJBQUFBLE9BQU9jLFFBQVEsY0FBZmQsdUNBQUFBLGlCQUFpQm1ELEVBQUUsR0FBRTtJQUN4RG5ELE9BQU9jLFFBQVEsQ0FBQ3FDLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQzdDO1FBQ2xDUyxRQUFRQyxHQUFHLENBQUMsdUJBQXVCVjtRQUNuQyxJQUFJQSxZQUFZRCxpQkFBaUJFLFVBQVUsRUFBRTtZQUMzQ1EsUUFBUUMsR0FBRyxDQUFDO1lBQ1poQixPQUFPb0QsUUFBUSxDQUFDQyxNQUFNO1FBQ3hCO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi91dGlsc0Zyb250L2V0aGVyc0NvbmZpZy50cz8zOGI1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFxuICBDb250cmFjdCwgXG4gIEpzb25ScGNQcm92aWRlciwgXG4gIEJyb3dzZXJQcm92aWRlcixcbiAgZm9ybWF0VW5pdHMsIFxuICBnZXRBZGRyZXNzLFxuICB0eXBlIEpzb25ScGNTaWduZXIsXG4gIHR5cGUgUHJvdmlkZXJcbn0gZnJvbSAnZXRoZXJzJztcblxuLy8gVHlwZXNcbmV4cG9ydCBpbnRlcmZhY2UgUmVxdWVzdEFyZ3VtZW50cyB7XG4gIG1ldGhvZDogc3RyaW5nO1xuICBwYXJhbXM/OiB1bmtub3duW10gfCBvYmplY3Q7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXRoZXJldW1Qcm92aWRlciB7XG4gIHJlcXVlc3QoYXJnczogUmVxdWVzdEFyZ3VtZW50cyk6IFByb21pc2U8dW5rbm93bj47XG4gIG9uPyhldmVudE5hbWU6IHN0cmluZywgY2FsbGJhY2s6ICguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZCk6IHZvaWQ7XG4gIHJlbW92ZUxpc3RlbmVyPyhldmVudE5hbWU6IHN0cmluZywgY2FsbGJhY2s6ICguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZCk6IHZvaWQ7XG4gIHNlbGVjdGVkQWRkcmVzcz86IHN0cmluZztcbiAgaXNNZXRhTWFzaz86IGJvb2xlYW47XG4gIGNoYWluSWQ/OiBzdHJpbmc7XG4gIG5ldHdvcmtWZXJzaW9uPzogc3RyaW5nO1xufVxuXG4vLyBBZGQgdHlwZSBkZWNsYXJhdGlvbiBmb3IgdGhlIGdsb2JhbCB3aW5kb3cgb2JqZWN0XG5kZWNsYXJlIGdsb2JhbCB7XG4gIGludGVyZmFjZSBXaW5kb3cge1xuICAgIGV0aGVyZXVtPzogRXRoZXJldW1Qcm92aWRlcjtcbiAgfVxufVxuXG4vLyBOZXR3b3JrIGNvbmZpZ3VyYXRpb25cbmV4cG9ydCBjb25zdCBFWFBFQ1RFRF9ORVRXT1JLID0ge1xuICBjaGFpbklkOiAnMTMzNycsXG4gIGNoYWluSWRIZXg6ICcweDUzOScsIC8vIEhleGFkZWNpbWFsIHJlcHJlc2VudGF0aW9uIG9mIDEzMzdcbiAgbmFtZTogJ0xvY2FsaG9zdCcsXG4gIHJwY1VybDogJ2h0dHA6Ly8xMjcuMC4wLjE6NzU0NScsXG4gIG5hdGl2ZUN1cnJlbmN5OiB7XG4gICAgbmFtZTogJ0VUSCcsXG4gICAgc3ltYm9sOiAnRVRIJyxcbiAgICBkZWNpbWFsczogMThcbiAgfVxufTtcblxuLy8gRnVuY3Rpb24gdG8gc3dpdGNoIHRvIHRoZSBjb3JyZWN0IG5ldHdvcmtcbmV4cG9ydCBjb25zdCBzd2l0Y2hUb0NvcnJlY3ROZXR3b3JrID0gYXN5bmMgKGV0aGVyZXVtOiBFdGhlcmV1bVByb3ZpZGVyKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ0F0dGVtcHRpbmcgdG8gc3dpdGNoIG5ldHdvcmsuLi4nKTtcbiAgICAvLyBGaXJzdCBjaGVjayBjdXJyZW50IG5ldHdvcmtcbiAgICBjb25zdCBjdXJyZW50Q2hhaW5JZCA9IGF3YWl0IGV0aGVyZXVtLnJlcXVlc3QoeyBtZXRob2Q6ICdldGhfY2hhaW5JZCcgfSk7XG4gICAgY29uc29sZS5sb2coJ0N1cnJlbnQgY2hhaW5JZDonLCBjdXJyZW50Q2hhaW5JZCk7XG4gICAgXG4gICAgaWYgKGN1cnJlbnRDaGFpbklkID09PSBFWFBFQ1RFRF9ORVRXT1JLLmNoYWluSWRIZXgpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdBbHJlYWR5IG9uIGNvcnJlY3QgbmV0d29yaycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCdTd2l0Y2hpbmcgdG8gbmV0d29yazonLCBFWFBFQ1RFRF9ORVRXT1JLLmNoYWluSWRIZXgpO1xuICAgIFxuICAgIC8vIFRyeSB0byBzd2l0Y2ggdG8gdGhlIG5ldHdvcmtcbiAgICBhd2FpdCBldGhlcmV1bS5yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogJ3dhbGxldF9zd2l0Y2hFdGhlcmV1bUNoYWluJyxcbiAgICAgIHBhcmFtczogW3sgY2hhaW5JZDogRVhQRUNURURfTkVUV09SSy5jaGFpbklkSGV4IH1dXG4gICAgfSk7XG4gICAgXG4gICAgLy8gV2FpdCBhIGJpdCBmb3IgdGhlIG5ldHdvcmsgc3dpdGNoIHRvIGNvbXBsZXRlXG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKTtcbiAgICBcbiAgICAvLyBWZXJpZnkgdGhlIHN3aXRjaCB3YXMgc3VjY2Vzc2Z1bFxuICAgIGNvbnN0IG5ld0NoYWluSWQgPSBhd2FpdCBldGhlcmV1bS5yZXF1ZXN0KHsgbWV0aG9kOiAnZXRoX2NoYWluSWQnIH0pO1xuICAgIGlmIChuZXdDaGFpbklkICE9PSBFWFBFQ1RFRF9ORVRXT1JLLmNoYWluSWRIZXgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTmV0d29yayBzd2l0Y2ggZmFpbGVkJyk7XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKCdTdWNjZXNzZnVsbHkgc3dpdGNoZWQgdG8gY29ycmVjdCBuZXR3b3JrJyk7XG4gIH0gY2F0Y2ggKHN3aXRjaEVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBzd2l0Y2hUb0NvcnJlY3ROZXR3b3JrOicsIHN3aXRjaEVycm9yKTtcbiAgICBcbiAgICAvLyBUaGlzIGVycm9yIGNvZGUgaW5kaWNhdGVzIHRoYXQgdGhlIGNoYWluIGhhcyBub3QgYmVlbiBhZGRlZCB0byBNZXRhTWFza1xuICAgIGlmIChzd2l0Y2hFcnJvci5jb2RlID09PSA0OTAyKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zb2xlLmxvZygnTmV0d29yayBub3QgZm91bmQsIGF0dGVtcHRpbmcgdG8gYWRkLi4uJyk7XG4gICAgICAgIGF3YWl0IGV0aGVyZXVtLnJlcXVlc3Qoe1xuICAgICAgICAgIG1ldGhvZDogJ3dhbGxldF9hZGRFdGhlcmV1bUNoYWluJyxcbiAgICAgICAgICBwYXJhbXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY2hhaW5JZDogRVhQRUNURURfTkVUV09SSy5jaGFpbklkSGV4LFxuICAgICAgICAgICAgICBjaGFpbk5hbWU6IEVYUEVDVEVEX05FVFdPUksubmFtZSxcbiAgICAgICAgICAgICAgcnBjVXJsczogW0VYUEVDVEVEX05FVFdPUksucnBjVXJsXSxcbiAgICAgICAgICAgICAgbmF0aXZlQ3VycmVuY3k6IEVYUEVDVEVEX05FVFdPUksubmF0aXZlQ3VycmVuY3lcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gV2FpdCBhIGJpdCBmb3IgdGhlIG5ldHdvcmsgdG8gYmUgYWRkZWRcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFZlcmlmeSB0aGUgbmV0d29yayB3YXMgYWRkZWQgYW5kIHN3aXRjaGVkIHRvXG4gICAgICAgIGNvbnN0IGZpbmFsQ2hhaW5JZCA9IGF3YWl0IGV0aGVyZXVtLnJlcXVlc3QoeyBtZXRob2Q6ICdldGhfY2hhaW5JZCcgfSk7XG4gICAgICAgIGlmIChmaW5hbENoYWluSWQgIT09IEVYUEVDVEVEX05FVFdPUksuY2hhaW5JZEhleCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTmV0d29yayBhZGQgZmFpbGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKCdTdWNjZXNzZnVsbHkgYWRkZWQgYW5kIHN3aXRjaGVkIHRvIG5ldHdvcmsnKTtcbiAgICAgIH0gY2F0Y2ggKGFkZEVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFkZGluZyBuZXR3b3JrOicsIGFkZEVycm9yKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCfZitix2KzZiSDYpdi22KfZgdipINin2YTYtNio2YPYqSDYp9mE2YXYrdmE2YrYqSDZitiv2YjZitin2YsgfCBQbGVhc2UgYWRkIHRoZSBsb2NhbCBuZXR3b3JrIG1hbnVhbGx5Jyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHN3aXRjaGluZyBuZXR3b3JrOicsIHN3aXRjaEVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcign2YrYsdis2Ykg2KrYutmK2YrYsSDYp9mE2LTYqNmD2Kkg2KXZhNmJINin2YTYtNio2YPYqSDYp9mE2YXYrdmE2YrYqSB8IFBsZWFzZSBzd2l0Y2ggdG8gbG9jYWwgbmV0d29yaycpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gUHJvdmlkZXIgYW5kIHNpZ25lciBmdW5jdGlvbnNcbmV4cG9ydCBjb25zdCBnZXRQcm92aWRlciA9IGFzeW5jICgpID0+IHtcbiAgaWYgKCF3aW5kb3cuZXRoZXJldW0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGFNYXNrINi62YrYsSDZhdir2KjYqiAtIE1ldGFNYXNrIGlzIG5vdCBpbnN0YWxsZWQnKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gRmlyc3QgY2hlY2sgaWYgd2UncmUgb24gdGhlIGNvcnJlY3QgbmV0d29yayBiZWZvcmUgZG9pbmcgYW55dGhpbmcgZWxzZVxuICAgIGNvbnN0IGN1cnJlbnRDaGFpbklkID0gYXdhaXQgd2luZG93LmV0aGVyZXVtLnJlcXVlc3QoeyBtZXRob2Q6ICdldGhfY2hhaW5JZCcgfSk7XG4gICAgY29uc29sZS5sb2coJ0luaXRpYWwgY2hhaW4gSUQgY2hlY2s6JywgY3VycmVudENoYWluSWQpO1xuICAgIFxuICAgIGlmIChjdXJyZW50Q2hhaW5JZCAhPT0gRVhQRUNURURfTkVUV09SSy5jaGFpbklkSGV4KSB7XG4gICAgICBjb25zb2xlLmxvZygnV3JvbmcgbmV0d29yayBkZXRlY3RlZCwgYXR0ZW1wdGluZyB0byBzd2l0Y2guLi4nKTtcbiAgICAgIGF3YWl0IHN3aXRjaFRvQ29ycmVjdE5ldHdvcmsod2luZG93LmV0aGVyZXVtKTtcbiAgICAgIFxuICAgICAgLy8gVmVyaWZ5IHRoZSBzd2l0Y2ggd2FzIHN1Y2Nlc3NmdWxcbiAgICAgIGNvbnN0IG5ld0NoYWluSWQgPSBhd2FpdCB3aW5kb3cuZXRoZXJldW0ucmVxdWVzdCh7IG1ldGhvZDogJ2V0aF9jaGFpbklkJyB9KTtcbiAgICAgIGlmIChuZXdDaGFpbklkICE9PSBFWFBFQ1RFRF9ORVRXT1JLLmNoYWluSWRIZXgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gc3dpdGNoIHRvIGNvcnJlY3QgbmV0d29yaycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE9ubHkgcmVxdWVzdCBhY2NvdW50cyBhZnRlciB3ZSdyZSBvbiB0aGUgY29ycmVjdCBuZXR3b3JrXG4gICAgYXdhaXQgd2luZG93LmV0aGVyZXVtLnJlcXVlc3QoeyBtZXRob2Q6IFwiZXRoX3JlcXVlc3RBY2NvdW50c1wiIH0pO1xuICAgIFxuICAgIC8vIENyZWF0ZSBwcm92aWRlciB1c2luZyBCcm93c2VyUHJvdmlkZXJcbiAgICBjb25zdCBwcm92aWRlciA9IG5ldyBCcm93c2VyUHJvdmlkZXIod2luZG93LmV0aGVyZXVtKTtcbiAgICBcbiAgICByZXR1cm4gcHJvdmlkZXI7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBwcm92aWRlcjonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBnZXRTaWduZXIgPSBhc3luYyAoKTogUHJvbWlzZTxKc29uUnBjU2lnbmVyPiA9PiB7XG4gIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgZ2V0UHJvdmlkZXIoKTtcbiAgcmV0dXJuIHByb3ZpZGVyLmdldFNpZ25lcigpO1xufTtcblxuZXhwb3J0IGNvbnN0IHZhbGlkYXRlTmV0d29yayA9IGFzeW5jIChwcm92aWRlcjogUHJvdmlkZXIpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygnVmFsaWRhdGluZyBuZXR3b3JrLi4uJyk7XG4gICAgY29uc3QgbmV0d29yayA9IGF3YWl0IHByb3ZpZGVyLmdldE5ldHdvcmsoKTtcbiAgICBjb25zdCBjaGFpbklkID0gbmV0d29yay5jaGFpbklkLnRvU3RyaW5nKCk7XG4gICAgY29uc29sZS5sb2coJ0N1cnJlbnQgY2hhaW5JZDonLCBjaGFpbklkLCAnRXhwZWN0ZWQ6JywgRVhQRUNURURfTkVUV09SSy5jaGFpbklkKTtcbiAgICBcbiAgICBpZiAoY2hhaW5JZCAhPT0gRVhQRUNURURfTkVUV09SSy5jaGFpbklkKSB7XG4gICAgICBjb25zb2xlLmxvZygnV3JvbmcgbmV0d29yayBkZXRlY3RlZCBpbiB2YWxpZGF0ZU5ldHdvcmsnKTtcbiAgICAgIGlmICghd2luZG93LmV0aGVyZXVtKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihg2YrYsdis2Ykg2KfZhNin2KrYtdin2YQg2KjYtNio2YPYqSAke0VYUEVDVEVEX05FVFdPUksubmFtZX0gKENoYWluIElEOiAke0VYUEVDVEVEX05FVFdPUksuY2hhaW5JZH0pIHwgUGxlYXNlIGNvbm5lY3QgdG8gJHtFWFBFQ1RFRF9ORVRXT1JLLm5hbWV9IG5ldHdvcmtgKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IGNoYWluIElEIGRpcmVjdGx5IGZyb20gZXRoZXJldW0gcHJvdmlkZXJcbiAgICAgIGNvbnN0IGN1cnJlbnRDaGFpbklkID0gYXdhaXQgd2luZG93LmV0aGVyZXVtLnJlcXVlc3QoeyBtZXRob2Q6ICdldGhfY2hhaW5JZCcgfSk7XG4gICAgICBjb25zb2xlLmxvZygnQ3VycmVudCBjaGFpbiBJRCBmcm9tIGV0aGVyZXVtOicsIGN1cnJlbnRDaGFpbklkKTtcbiAgICAgIFxuICAgICAgaWYgKGN1cnJlbnRDaGFpbklkICE9PSBFWFBFQ1RFRF9ORVRXT1JLLmNoYWluSWRIZXgpIHtcbiAgICAgICAgYXdhaXQgc3dpdGNoVG9Db3JyZWN0TmV0d29yayh3aW5kb3cuZXRoZXJldW0pO1xuICAgICAgICBcbiAgICAgICAgLy8gV2FpdCBmb3IgdGhlIG5ldHdvcmsgc3dpdGNoIHRvIGNvbXBsZXRlXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxNTAwKSk7XG4gICAgICAgIFxuICAgICAgICAvLyBWZXJpZnkgb25lIGZpbmFsIHRpbWVcbiAgICAgICAgY29uc3QgZmluYWxDaGFpbklkID0gYXdhaXQgd2luZG93LmV0aGVyZXVtLnJlcXVlc3QoeyBtZXRob2Q6ICdldGhfY2hhaW5JZCcgfSk7XG4gICAgICAgIGlmIChmaW5hbENoYWluSWQgIT09IEVYUEVDVEVEX05FVFdPUksuY2hhaW5JZEhleCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTmV0d29yayBzd2l0Y2ggdmVyaWZpY2F0aW9uIGZhaWxlZCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKCdOZXR3b3JrIHZhbGlkYXRpb24gcGFzc2VkJyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignTmV0d29yayB2YWxpZGF0aW9uIGZhaWxlZDonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbi8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHdvcmtpbmcgd2l0aCBjb250cmFjdHNcbmV4cG9ydCBjb25zdCBnZXRDb250cmFjdCA9IDxUIGV4dGVuZHMgQ29udHJhY3Q+KFxuICBhZGRyZXNzOiBzdHJpbmcsXG4gIGFiaTogYW55LFxuICBzaWduZXI6IEpzb25ScGNTaWduZXJcbik6IFQgPT4ge1xuICByZXR1cm4gbmV3IENvbnRyYWN0KGFkZHJlc3MsIGFiaSwgc2lnbmVyKSBhcyBUO1xufTtcblxuZXhwb3J0IGNvbnN0IHZhbGlkYXRlQWRkcmVzcyA9IChhZGRyZXNzOiBzdHJpbmcgfCB1bmRlZmluZWQgfCBudWxsKTogc3RyaW5nID0+IHtcbiAgaWYgKCFhZGRyZXNzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBZGRyZXNzIGlzIHJlcXVpcmVkJyk7XG4gIH1cbiAgXG4gIHRyeSB7XG4gICAgcmV0dXJuIGdldEFkZHJlc3MoYWRkcmVzcyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEV0aGVyZXVtIGFkZHJlc3MnKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGZvcm1hdEV0aGVyID0gKHZhbHVlOiBiaWdpbnQpOiBzdHJpbmcgPT4ge1xuICByZXR1cm4gZm9ybWF0VW5pdHModmFsdWUsIDE4KTtcbn07XG5cbi8vIFV0aWxpdHkgZnVuY3Rpb24gdG8gaGFuZGxlIGNvbW1vbiBjb250cmFjdCBlcnJvcnNcbmV4cG9ydCBjb25zdCBoYW5kbGVDb250cmFjdEVycm9yID0gKGVycm9yOiBhbnkpOiBuZXZlciA9PiB7XG4gIGNvbnNvbGUuZXJyb3IoJ0NvbnRyYWN0IGVycm9yOicsIGVycm9yKTtcbiAgXG4gIGlmIChlcnJvci5yZWFzb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFNtYXJ0IGNvbnRyYWN0IGVycm9yOiAke2Vycm9yLnJlYXNvbn1gKTtcbiAgfSBlbHNlIGlmIChlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygndXNlciByZWplY3RlZCcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc2FjdGlvbiByZWplY3RlZCBieSB1c2VyJyk7XG4gIH0gZWxzZSBpZiAoZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ2luc3VmZmljaWVudCBmdW5kcycpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnN1ZmZpY2llbnQgZnVuZHMgdG8gY29tcGxldGUgdGhlIHRyYW5zYWN0aW9uJyk7XG4gIH0gZWxzZSBpZiAoZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ25ldHdvcmsnKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIG1ha2Ugc3VyZSB5b3UgYXJlIGNvbm5lY3RlZCB0byB0aGUgY29ycmVjdCBuZXR3b3JrJyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc2FjdGlvbiBmYWlsZWQuIFBsZWFzZSBjaGVjayB5b3VyIGNvbm5lY3Rpb24gYW5kIHRyeSBhZ2Fpbi4nKTtcbiAgfVxufTtcblxuLy8gRXZlbnQgbGlzdGVuZXIgZm9yIG5ldHdvcmsgY2hhbmdlc1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5ldGhlcmV1bT8ub24pIHtcbiAgd2luZG93LmV0aGVyZXVtLm9uKCdjaGFpbkNoYW5nZWQnLCAoY2hhaW5JZDogc3RyaW5nKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ05ldHdvcmsgY2hhbmdlZCB0bzonLCBjaGFpbklkKTtcbiAgICBpZiAoY2hhaW5JZCAhPT0gRVhQRUNURURfTkVUV09SSy5jaGFpbklkSGV4KSB7XG4gICAgICBjb25zb2xlLmxvZygnV3JvbmcgbmV0d29yayBhZnRlciBjaGFuZ2UsIHJlbG9hZGluZy4uLicpO1xuICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgIH1cbiAgfSk7XG59ICJdLCJuYW1lcyI6WyJ3aW5kb3ciLCJDb250cmFjdCIsIkJyb3dzZXJQcm92aWRlciIsImZvcm1hdFVuaXRzIiwiZ2V0QWRkcmVzcyIsIkVYUEVDVEVEX05FVFdPUksiLCJjaGFpbklkIiwiY2hhaW5JZEhleCIsIm5hbWUiLCJycGNVcmwiLCJuYXRpdmVDdXJyZW5jeSIsInN5bWJvbCIsImRlY2ltYWxzIiwic3dpdGNoVG9Db3JyZWN0TmV0d29yayIsImV0aGVyZXVtIiwiY29uc29sZSIsImxvZyIsImN1cnJlbnRDaGFpbklkIiwicmVxdWVzdCIsIm1ldGhvZCIsInBhcmFtcyIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsIm5ld0NoYWluSWQiLCJFcnJvciIsInN3aXRjaEVycm9yIiwiZXJyb3IiLCJjb2RlIiwiY2hhaW5OYW1lIiwicnBjVXJscyIsImZpbmFsQ2hhaW5JZCIsImFkZEVycm9yIiwiZ2V0UHJvdmlkZXIiLCJwcm92aWRlciIsImdldFNpZ25lciIsInZhbGlkYXRlTmV0d29yayIsIm5ldHdvcmsiLCJnZXROZXR3b3JrIiwidG9TdHJpbmciLCJnZXRDb250cmFjdCIsImFkZHJlc3MiLCJhYmkiLCJzaWduZXIiLCJ2YWxpZGF0ZUFkZHJlc3MiLCJmb3JtYXRFdGhlciIsInZhbHVlIiwiaGFuZGxlQ29udHJhY3RFcnJvciIsInJlYXNvbiIsIm1lc3NhZ2UiLCJpbmNsdWRlcyIsIm9uIiwibG9jYXRpb24iLCJyZWxvYWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./utilsFront/ethersConfig.ts\n"));

/***/ })

});