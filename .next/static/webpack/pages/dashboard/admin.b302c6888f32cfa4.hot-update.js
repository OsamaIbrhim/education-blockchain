"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/dashboard/admin",{

/***/ "./utils/contracts.ts":
/*!****************************!*\
  !*** ./utils/contracts.ts ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createExam: function() { return /* binding */ createExam; },\n/* harmony export */   enrollStudent: function() { return /* binding */ enrollStudent; },\n/* harmony export */   getCertificates: function() { return /* binding */ getCertificates; },\n/* harmony export */   getContracts: function() { return /* binding */ getContracts; },\n/* harmony export */   getExam: function() { return /* binding */ getExam; },\n/* harmony export */   getExamResult: function() { return /* binding */ getExamResult; },\n/* harmony export */   getInstitutionExams: function() { return /* binding */ getInstitutionExams; },\n/* harmony export */   getOwnerAddress: function() { return /* binding */ getOwnerAddress; },\n/* harmony export */   getStudentExams: function() { return /* binding */ getStudentExams; },\n/* harmony export */   getUserRole: function() { return /* binding */ getUserRole; },\n/* harmony export */   isOwner: function() { return /* binding */ isOwner; },\n/* harmony export */   isVerifiedUser: function() { return /* binding */ isVerifiedUser; },\n/* harmony export */   issueCertificate: function() { return /* binding */ issueCertificate; },\n/* harmony export */   registerUser: function() { return /* binding */ registerUser; },\n/* harmony export */   submitExamResult: function() { return /* binding */ submitExamResult; },\n/* harmony export */   updateExamStatus: function() { return /* binding */ updateExamStatus; },\n/* harmony export */   verifyCertificate: function() { return /* binding */ verifyCertificate; },\n/* harmony export */   verifyInstitution: function() { return /* binding */ verifyInstitution; },\n/* harmony export */   verifyUser: function() { return /* binding */ verifyUser; }\n/* harmony export */ });\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"./node_modules/ethers/lib.esm/index.js\");\n/* harmony import */ var _constants_abis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/abis */ \"./constants/abis.ts\");\n/* harmony import */ var _ethersConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ethersConfig */ \"./utils/ethersConfig.ts\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./config */ \"./utils/config.ts\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/process/browser.js\");\n\n\n\n\n// Contract addresses from .env\nconst IDENTITY_CONTRACT_ADDRESS = \"0x911E250f1398F007704D0F6A527a6a71560a3B93\";\nconst CERTIFICATES_CONTRACT_ADDRESS = \"0xB5Afb0f327F7776Bff1fb9FB257eed8dC2336161\";\nconst EXAM_MANAGEMENT_CONTRACT_ADDRESS = \"0x37458DD5C9E778CF2e149E44f806D8C914bF1CE2\";\n// Role mapping with proper types\nconst USER_ROLES = {\n    NONE: 0,\n    STUDENT: 1,\n    INSTITUTION: 2,\n    EMPLOYER: 3\n};\nconst roleMap = {\n    [USER_ROLES.NONE]: \"none\",\n    [USER_ROLES.STUDENT]: \"student\",\n    [USER_ROLES.INSTITUTION]: \"institution\",\n    [USER_ROLES.EMPLOYER]: \"employer\"\n};\n// Validate environment variables\nif (!IDENTITY_CONTRACT_ADDRESS) {\n    console.error(\"NEXT_PUBLIC_IDENTITY_CONTRACT_ADDRESS is not set in .env\");\n}\nif (!CERTIFICATES_CONTRACT_ADDRESS) {\n    console.error(\"NEXT_PUBLIC_CERTIFICATES_CONTRACT_ADDRESS is not set in .env\");\n}\nconst getContracts = async ()=>{\n    try {\n        const provider = await (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getProvider)();\n        const signer = await (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getSigner)();\n        const identityContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(IDENTITY_CONTRACT_ADDRESS, _constants_abis__WEBPACK_IMPORTED_MODULE_0__.IdentityABI, signer);\n        const certificatesContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(CERTIFICATES_CONTRACT_ADDRESS, _constants_abis__WEBPACK_IMPORTED_MODULE_0__.CertificatesABI, signer);\n        const examManagementContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(EXAM_MANAGEMENT_CONTRACT_ADDRESS, _constants_abis__WEBPACK_IMPORTED_MODULE_0__.ExamManagementABI, signer);\n        return {\n            identityContract,\n            certificatesContract,\n            examManagementContract,\n            provider,\n            signer\n        };\n    } catch (error) {\n        console.error(\"Error initializing contracts:\", error);\n        throw new Error(\"Failed to initialize contracts: \".concat(error.message));\n    }\n};\nconst registerUser = async (role)=>{\n    if (!role) {\n        throw new Error(\"Role is required\");\n    }\n    try {\n        // Error.1 missing revert data  \n        // const provider = await getProvider();\n        // solve error.1\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.BrowserProvider(window.ethereum);\n        const signer = await provider.getSigner();\n        const identityAddress = (0,_config__WEBPACK_IMPORTED_MODULE_2__.getConfig)(\"IDENTITY_CONTRACT_ADDRESS\");\n        if (!identityAddress) {\n            throw new Error(\"Contract address is not configured\");\n        }\n        const identityContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(identityAddress, _constants_abis__WEBPACK_IMPORTED_MODULE_0__.IdentityABI, signer);\n        // Convert role string to enum value\n        const roleMap = {\n            \"student\": 1,\n            \"institution\": 2,\n            \"employer\": 3\n        };\n        const roleValue = roleMap[role.toLowerCase()];\n        if (roleValue === undefined) {\n            throw new Error(\"Invalid role: \".concat(role, \". Must be one of: student, institution, employer\"));\n        }\n        const tx = await identityContract.registerUser(roleValue, \"\" /*, overrides*/ );\n        await tx.wait();\n        return {\n            status: \"success\"\n        };\n    } catch (error) {\n        console.error(\"Registration error:\", error);\n        throw error;\n    }\n};\nconst verifyUser = async (address)=>{\n    if (!address || !(0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getAddress)(address)) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        const { identityContract } = await getContracts();\n        return await identityContract.verifyUser(address);\n    } catch (error) {\n        console.error(\"Error verifying user:\", error);\n        throw new Error(error.message || \"Failed to verify user\");\n    }\n};\nconst getUserRole = async (address)=>{\n    if (!address || !(0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getAddress)(address)) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        const { identityContract } = await getContracts();\n        const roleValue = await identityContract.getUserRole(address);\n        return roleMap[roleValue] || \"none\";\n    } catch (error) {\n        console.error(\"Error getting user role:\", error);\n        return \"none\";\n    }\n};\nconst issueCertificate = async (studentAddress, ipfsHash)=>{\n    if (!studentAddress || !ipfsHash) {\n        throw new Error(\"Student address and IPFS hash are required\");\n    }\n    try {\n        const { certificatesContract } = await getContracts();\n        const tx = await certificatesContract.issueCertificate(studentAddress, ipfsHash);\n        await tx.wait();\n        return tx;\n    } catch (error) {\n        console.error(\"Error issuing certificate:\", error);\n        throw error;\n    }\n};\nconst verifyCertificate = async (certificateId)=>{\n    if (!certificateId) {\n        throw new Error(\"Certificate ID is required\");\n    }\n    try {\n        const { certificatesContract } = await getContracts();\n        const isValid = await certificatesContract.verifyCertificate(certificateId);\n        return isValid;\n    } catch (error) {\n        console.error(\"Error verifying certificate:\", error);\n        throw error;\n    }\n};\nconst getCertificates = async (address)=>{\n    if (!address || !(0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getAddress)(address)) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        console.log(\"Getting certificates for address:\", address);\n        const { certificatesContract } = await getContracts();\n        // Get certificate IDs first\n        console.log(\"Getting certificate IDs...\");\n        const certificateIds = await certificatesContract.getStudentCertificates(address);\n        console.log(\"Certificate IDs:\", certificateIds);\n        if (!certificateIds || certificateIds.length === 0) {\n            console.log(\"No certificates found\");\n            return [];\n        }\n        // Get details for each certificate\n        console.log(\"Getting certificate details...\");\n        const certificates = await Promise.all(certificateIds.map(async (id)=>{\n            const cert = await certificatesContract.verifyCertificate(id);\n            return {\n                id,\n                ipfsHash: cert.ipfsHash,\n                issuer: cert.institution,\n                timestamp: cert.issuedAt.toString(),\n                isValid: cert.isValid\n            };\n        }));\n        console.log(\"Certificate details:\", certificates);\n        return certificates;\n    } catch (error) {\n        console.error(\"Error in getCertificates:\", error);\n        if (error.reason) {\n            throw new Error(\"Contract error: \".concat(error.reason));\n        }\n        throw error;\n    }\n};\nconst isVerifiedUser = async (address)=>{\n    if (!address || !(0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getAddress)(address)) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        const { identityContract } = await getContracts();\n        return await identityContract.isVerifiedUser(address);\n    } catch (error) {\n        console.error(\"Error checking verification status:\", error);\n        throw error;\n    }\n};\n// Admin functions\nconst isOwner = async (address)=>{\n    if (!address || !(0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getAddress)(address)) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        const { identityContract } = await getContracts();\n        const owner = await identityContract.owner();\n        // Add additional checks\n        if (!owner) {\n            console.warn(\"Owner address is null or undefined\");\n            return false;\n        }\n        return owner.toLowerCase() === address.toLowerCase();\n    } catch (error) {\n        console.error(\"Error checking owner status:\", error);\n        throw error;\n    }\n};\nconst verifyInstitution = async (institutionAddress)=>{\n    if (!institutionAddress || !(0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getAddress)(institutionAddress)) {\n        throw new Error(\"Invalid institution address\");\n    }\n    try {\n        const { identityContract, examManagementContract } = await getContracts();\n        const identityTx = await identityContract.verifyUser(institutionAddress);\n        await identityTx.wait();\n        const examManagementTx = await examManagementContract.verifyInstitution(institutionAddress);\n        await examManagementTx.wait();\n        return {\n            identityHash: identityTx.hash,\n            examManagementHash: examManagementTx.hash\n        };\n    } catch (error) {\n        console.error(\"Error verifying institution:\", error);\n        throw error;\n    }\n};\nconst getOwnerAddress = async ()=>{\n    try {\n        const { identityContract } = await getContracts();\n        const owner = await identityContract.owner();\n        return owner;\n    } catch (error) {\n        console.error(\"Error getting owner address:\", error);\n        throw error;\n    }\n};\n// Add exam management contract address and ABI\nconst EXAM_MANAGEMENT_ADDRESS = process.env.NEXT_PUBLIC_EXAM_MANAGEMENT_ADDRESS || \"\";\nconst EXAM_MANAGEMENT_ABI = _constants_abis__WEBPACK_IMPORTED_MODULE_0__.ExamManagementABI;\n// Add exam management functions\nconst createExam = async (id, title, description, date, duration, ipfsHash)=>{\n    try {\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.JsonRpcProvider(_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl);\n        const signer = await provider.getSigner();\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(EXAM_MANAGEMENT_ADDRESS, EXAM_MANAGEMENT_ABI, signer);\n        const tx = await contract.createExam(id, title, description, date, duration, ipfsHash);\n        await tx.wait();\n        return true;\n    } catch (error) {\n        console.error(\"Error creating exam:\", error);\n        throw error;\n    }\n};\nconst submitExamResult = async (examId, student, score, grade, ipfsHash)=>{\n    try {\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.JsonRpcProvider(_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl);\n        const signer = await provider.getSigner();\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(EXAM_MANAGEMENT_ADDRESS, EXAM_MANAGEMENT_ABI, signer);\n        const tx = await contract.submitExamResult(examId, student, score, grade, ipfsHash);\n        await tx.wait();\n        return true;\n    } catch (error) {\n        console.error(\"Error submitting exam result:\", error);\n        throw error;\n    }\n};\nconst updateExamStatus = async (examId, status)=>{\n    try {\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.JsonRpcProvider(_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl);\n        const signer = await provider.getSigner();\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(EXAM_MANAGEMENT_ADDRESS, EXAM_MANAGEMENT_ABI, signer);\n        const tx = await contract.updateExamStatus(examId, status);\n        await tx.wait();\n        return true;\n    } catch (error) {\n        console.error(\"Error updating exam status:\", error);\n        throw error;\n    }\n};\nconst getExam = async (examId)=>{\n    try {\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.JsonRpcProvider(_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl);\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(EXAM_MANAGEMENT_ADDRESS, EXAM_MANAGEMENT_ABI, provider);\n        const exam = await contract.getExam(examId);\n        return exam;\n    } catch (error) {\n        console.error(\"Error getting exam:\", error);\n        throw error;\n    }\n};\nconst getExamResult = async (examId, student)=>{\n    try {\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.JsonRpcProvider(_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl);\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(EXAM_MANAGEMENT_ADDRESS, EXAM_MANAGEMENT_ABI, provider);\n        const result = await contract.getExamResult(examId, student);\n        return result;\n    } catch (error) {\n        console.error(\"Error getting exam result:\", error);\n        throw error;\n    }\n};\nconst getInstitutionExams = async (institution)=>{\n    try {\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.JsonRpcProvider(_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl);\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(EXAM_MANAGEMENT_ADDRESS, EXAM_MANAGEMENT_ABI, provider);\n        const exams = await contract.getInstitutionExams(institution);\n        return exams;\n    } catch (error) {\n        console.error(\"Error getting institution exams:\", error);\n        throw error;\n    }\n};\nconst getStudentExams = async (student)=>{\n    try {\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.JsonRpcProvider(_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl);\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(EXAM_MANAGEMENT_ADDRESS, EXAM_MANAGEMENT_ABI, provider);\n        const exams = await contract.getStudentExams(student);\n        return exams;\n    } catch (error) {\n        console.error(\"Error getting student exams:\", error);\n        throw error;\n    }\n};\nconst enrollStudent = async (examId, studentAddress)=>{\n    try {\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.JsonRpcProvider(_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl);\n        const signer = await provider.getSigner();\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(EXAM_MANAGEMENT_ADDRESS, EXAM_MANAGEMENT_ABI, signer);\n        const tx = await contract.enrollStudent(examId, studentAddress);\n        await tx.wait();\n        return true;\n    } catch (error) {\n        console.error(\"Error enrolling student:\", error);\n        throw error;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFTYSxlQUFlLENBQUNWO1FBQzdDLE9BQU9TO0lBQ1QsRUFBRSxPQUFPbEYsT0FBTztRQUNkRCxRQUFRQyxLQUFLLENBQUMsZ0NBQWdDQTtRQUM5QyxNQUFNQTtJQUNSO0FBQ0YsRUFBRTtBQUVLLE1BQU1vRixnQkFBZ0IsT0FBT1osUUFBZ0I5QztJQUNsRCxJQUFJO1FBQ0YsSUFBSSxDQUFDZCxPQUFPQyxRQUFRLEVBQUU7WUFDcEIsTUFBTSxJQUFJTCxNQUFNO1FBQ2xCO1FBQ0EsTUFBTU4sV0FBVyxJQUFJMUIsMENBQU1BLENBQUM0RixlQUFlLENBQUN0RiwyREFBZ0JBLENBQUN1RixNQUFNO1FBQ25FLE1BQU1sRSxTQUFTLE1BQU1ELFNBQVNyQixTQUFTO1FBQ3ZDLE1BQU15RixXQUFXLElBQUk5RiwwQ0FBTUEsQ0FBQzZCLFFBQVEsQ0FBQ3VELHlCQUF5QkUscUJBQXFCM0Q7UUFFbkYsTUFBTWdCLEtBQUssTUFBTW1ELFNBQVNjLGFBQWEsQ0FBQ1osUUFBUTlDO1FBQ2hELE1BQU1QLEdBQUdDLElBQUk7UUFDYixPQUFPO0lBQ1QsRUFBRSxPQUFPcEIsT0FBTztRQUNkRCxRQUFRQyxLQUFLLENBQUMsNEJBQTRCQTtRQUMxQyxNQUFNQTtJQUNSO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi91dGlscy9jb250cmFjdHMudHM/OTg1NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBldGhlcnMgfSBmcm9tICdldGhlcnMnO1xyXG5pbXBvcnQgeyBFeGFtTWFuYWdlbWVudEFCSSwgSWRlbnRpdHlBQkksIENlcnRpZmljYXRlc0FCSSB9IGZyb20gJy4uL2NvbnN0YW50cy9hYmlzJztcclxuaW1wb3J0IHtcclxuICBnZXRQcm92aWRlcixcclxuICBnZXRTaWduZXIsXHJcbiAgRVhQRUNURURfTkVUV09SSyxcclxuICB2YWxpZGF0ZU5ldHdvcmssXHJcbiAgZm9ybWF0RXRoZXIsXHJcbiAgaGFuZGxlQ29udHJhY3RFcnJvcixcclxuICBnZXRBZGRyZXNzLFxyXG4gIHR5cGUgRXRoZXJldW1Qcm92aWRlclxyXG59IGZyb20gJy4vZXRoZXJzQ29uZmlnJztcclxuaW1wb3J0IHsgZ2V0Q29uZmlnIH0gZnJvbSAnLi9jb25maWcnO1xyXG5cclxuLy8gQ29udHJhY3QgYWRkcmVzc2VzIGZyb20gLmVudlxyXG5jb25zdCBJREVOVElUWV9DT05UUkFDVF9BRERSRVNTID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfSURFTlRJVFlfQ09OVFJBQ1RfQUREUkVTUztcclxuY29uc3QgQ0VSVElGSUNBVEVTX0NPTlRSQUNUX0FERFJFU1MgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19DRVJUSUZJQ0FURVNfQ09OVFJBQ1RfQUREUkVTUztcclxuY29uc3QgRVhBTV9NQU5BR0VNRU5UX0NPTlRSQUNUX0FERFJFU1MgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19FWEFNX01BTkFHRU1FTlRfQ09OVFJBQ1RfQUREUkVTUztcclxuXHJcbi8vIFJvbGUgbWFwcGluZyB3aXRoIHByb3BlciB0eXBlc1xyXG5jb25zdCBVU0VSX1JPTEVTID0ge1xyXG4gIE5PTkU6IDAsXHJcbiAgU1RVREVOVDogMSxcclxuICBJTlNUSVRVVElPTjogMixcclxuICBFTVBMT1lFUjogM1xyXG59IGFzIGNvbnN0O1xyXG5cclxudHlwZSBSb2xlVmFsdWUgPSB0eXBlb2YgVVNFUl9ST0xFU1trZXlvZiB0eXBlb2YgVVNFUl9ST0xFU107XHJcbnR5cGUgUm9sZVN0cmluZyA9ICdub25lJyB8ICdzdHVkZW50JyB8ICdpbnN0aXR1dGlvbicgfCAnZW1wbG95ZXInO1xyXG5cclxuY29uc3Qgcm9sZU1hcDogUmVjb3JkPFJvbGVWYWx1ZSwgUm9sZVN0cmluZz4gPSB7XHJcbiAgW1VTRVJfUk9MRVMuTk9ORV06ICdub25lJyxcclxuICBbVVNFUl9ST0xFUy5TVFVERU5UXTogJ3N0dWRlbnQnLFxyXG4gIFtVU0VSX1JPTEVTLklOU1RJVFVUSU9OXTogJ2luc3RpdHV0aW9uJyxcclxuICBbVVNFUl9ST0xFUy5FTVBMT1lFUl06ICdlbXBsb3llcidcclxufTtcclxuXHJcbi8vIFZhbGlkYXRlIGVudmlyb25tZW50IHZhcmlhYmxlc1xyXG5pZiAoIUlERU5USVRZX0NPTlRSQUNUX0FERFJFU1MpIHtcclxuICBjb25zb2xlLmVycm9yKCdORVhUX1BVQkxJQ19JREVOVElUWV9DT05UUkFDVF9BRERSRVNTIGlzIG5vdCBzZXQgaW4gLmVudicpO1xyXG59XHJcbmlmICghQ0VSVElGSUNBVEVTX0NPTlRSQUNUX0FERFJFU1MpIHtcclxuICBjb25zb2xlLmVycm9yKCdORVhUX1BVQkxJQ19DRVJUSUZJQ0FURVNfQ09OVFJBQ1RfQUREUkVTUyBpcyBub3Qgc2V0IGluIC5lbnYnKTtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGdldENvbnRyYWN0cyA9IGFzeW5jICgpID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCBnZXRQcm92aWRlcigpO1xyXG4gICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgZ2V0U2lnbmVyKCk7XHJcblxyXG4gICAgY29uc3QgaWRlbnRpdHlDb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoXHJcbiAgICAgIElERU5USVRZX0NPTlRSQUNUX0FERFJFU1MhLFxyXG4gICAgICBJZGVudGl0eUFCSSxcclxuICAgICAgc2lnbmVyXHJcbiAgICApO1xyXG5cclxuICAgIGNvbnN0IGNlcnRpZmljYXRlc0NvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChcclxuICAgICAgQ0VSVElGSUNBVEVTX0NPTlRSQUNUX0FERFJFU1MhLFxyXG4gICAgICBDZXJ0aWZpY2F0ZXNBQkksXHJcbiAgICAgIHNpZ25lclxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCBleGFtTWFuYWdlbWVudENvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChcclxuICAgICAgRVhBTV9NQU5BR0VNRU5UX0NPTlRSQUNUX0FERFJFU1MhLFxyXG4gICAgICBFeGFtTWFuYWdlbWVudEFCSSxcclxuICAgICAgc2lnbmVyXHJcbiAgICApO1xyXG5cclxuICAgIHJldHVybiB7IGlkZW50aXR5Q29udHJhY3QsIGNlcnRpZmljYXRlc0NvbnRyYWN0LCBleGFtTWFuYWdlbWVudENvbnRyYWN0LCBwcm92aWRlciwgc2lnbmVyIH07XHJcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW5pdGlhbGl6aW5nIGNvbnRyYWN0czonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBpbml0aWFsaXplIGNvbnRyYWN0czogJHtlcnJvci5tZXNzYWdlfWApO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCByZWdpc3RlclVzZXIgPSBhc3luYyAocm9sZTogc3RyaW5nKSA9PiB7XHJcbiAgaWYgKCFyb2xlKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JvbGUgaXMgcmVxdWlyZWQnKTtcclxuICB9XHJcblxyXG4gIHRyeSB7XHJcbiAgICAvLyBFcnJvci4xIG1pc3NpbmcgcmV2ZXJ0IGRhdGEgIFxyXG4gICAgLy8gY29uc3QgcHJvdmlkZXIgPSBhd2FpdCBnZXRQcm92aWRlcigpO1xyXG5cclxuICAgIC8vIHNvbHZlIGVycm9yLjFcclxuICAgIGlmICghd2luZG93LmV0aGVyZXVtKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZXRoZXJldW0gcHJvdmlkZXIgZm91bmQnKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IGV0aGVycy5Ccm93c2VyUHJvdmlkZXIod2luZG93LmV0aGVyZXVtKTtcclxuXHJcbiAgICBjb25zdCBzaWduZXIgPSBhd2FpdCBwcm92aWRlci5nZXRTaWduZXIoKTtcclxuICAgIGNvbnN0IGlkZW50aXR5QWRkcmVzcyA9IGdldENvbmZpZygnSURFTlRJVFlfQ09OVFJBQ1RfQUREUkVTUycpO1xyXG5cclxuICAgIGlmICghaWRlbnRpdHlBZGRyZXNzKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ29udHJhY3QgYWRkcmVzcyBpcyBub3QgY29uZmlndXJlZCcpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGlkZW50aXR5Q29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KGlkZW50aXR5QWRkcmVzcywgSWRlbnRpdHlBQkksIHNpZ25lcik7XHJcblxyXG4gICAgLy8gQ29udmVydCByb2xlIHN0cmluZyB0byBlbnVtIHZhbHVlXHJcbiAgICBjb25zdCByb2xlTWFwOiB7IFtrZXk6IHN0cmluZ106IG51bWJlciB9ID0ge1xyXG4gICAgICAnc3R1ZGVudCc6IDEsXHJcbiAgICAgICdpbnN0aXR1dGlvbic6IDIsXHJcbiAgICAgICdlbXBsb3llcic6IDNcclxuICAgIH07XHJcblxyXG4gICAgY29uc3Qgcm9sZVZhbHVlID0gcm9sZU1hcFtyb2xlLnRvTG93ZXJDYXNlKCldO1xyXG4gICAgaWYgKHJvbGVWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCByb2xlOiAke3JvbGV9LiBNdXN0IGJlIG9uZSBvZjogc3R1ZGVudCwgaW5zdGl0dXRpb24sIGVtcGxveWVyYCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdHggPSBhd2FpdCBpZGVudGl0eUNvbnRyYWN0LnJlZ2lzdGVyVXNlcihyb2xlVmFsdWUsIFwiXCIvKiwgb3ZlcnJpZGVzKi8pO1xyXG4gICAgYXdhaXQgdHgud2FpdCgpO1xyXG5cclxuICAgIHJldHVybiB7IHN0YXR1czogJ3N1Y2Nlc3MnIH07XHJcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgY29uc29sZS5lcnJvcignUmVnaXN0cmF0aW9uIGVycm9yOicsIGVycm9yKTtcclxuICAgIHRocm93IGVycm9yO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCB2ZXJpZnlVc2VyID0gYXN5bmMgKGFkZHJlc3M6IHN0cmluZykgPT4ge1xyXG4gIGlmICghYWRkcmVzcyB8fCAhZ2V0QWRkcmVzcyhhZGRyZXNzKSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFkZHJlc3MnKTtcclxuICB9XHJcblxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB7IGlkZW50aXR5Q29udHJhY3QgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xyXG4gICAgcmV0dXJuIGF3YWl0IGlkZW50aXR5Q29udHJhY3QudmVyaWZ5VXNlcihhZGRyZXNzKTtcclxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciB2ZXJpZnlpbmcgdXNlcjonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IubWVzc2FnZSB8fCAnRmFpbGVkIHRvIHZlcmlmeSB1c2VyJyk7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldFVzZXJSb2xlID0gYXN5bmMgKGFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8Um9sZVN0cmluZz4gPT4ge1xyXG4gIGlmICghYWRkcmVzcyB8fCAhZ2V0QWRkcmVzcyhhZGRyZXNzKSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFkZHJlc3MnKTtcclxuICB9XHJcblxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB7IGlkZW50aXR5Q29udHJhY3QgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xyXG4gICAgY29uc3Qgcm9sZVZhbHVlID0gYXdhaXQgaWRlbnRpdHlDb250cmFjdC5nZXRVc2VyUm9sZShhZGRyZXNzKTtcclxuICAgIHJldHVybiByb2xlTWFwW3JvbGVWYWx1ZSBhcyBSb2xlVmFsdWVdIHx8ICdub25lJztcclxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHVzZXIgcm9sZTonLCBlcnJvcik7XHJcbiAgICByZXR1cm4gJ25vbmUnO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBpc3N1ZUNlcnRpZmljYXRlID0gYXN5bmMgKHN0dWRlbnRBZGRyZXNzOiBzdHJpbmcsIGlwZnNIYXNoOiBzdHJpbmcpID0+IHtcclxuICBpZiAoIXN0dWRlbnRBZGRyZXNzIHx8ICFpcGZzSGFzaCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdTdHVkZW50IGFkZHJlc3MgYW5kIElQRlMgaGFzaCBhcmUgcmVxdWlyZWQnKTtcclxuICB9XHJcblxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB7IGNlcnRpZmljYXRlc0NvbnRyYWN0IH0gPSBhd2FpdCBnZXRDb250cmFjdHMoKTtcclxuICAgIGNvbnN0IHR4ID0gYXdhaXQgY2VydGlmaWNhdGVzQ29udHJhY3QuaXNzdWVDZXJ0aWZpY2F0ZShzdHVkZW50QWRkcmVzcywgaXBmc0hhc2gpO1xyXG4gICAgYXdhaXQgdHgud2FpdCgpO1xyXG4gICAgcmV0dXJuIHR4O1xyXG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGlzc3VpbmcgY2VydGlmaWNhdGU6JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHZlcmlmeUNlcnRpZmljYXRlID0gYXN5bmMgKGNlcnRpZmljYXRlSWQ6IHN0cmluZykgPT4ge1xyXG4gIGlmICghY2VydGlmaWNhdGVJZCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdDZXJ0aWZpY2F0ZSBJRCBpcyByZXF1aXJlZCcpO1xyXG4gIH1cclxuXHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHsgY2VydGlmaWNhdGVzQ29udHJhY3QgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xyXG4gICAgY29uc3QgaXNWYWxpZCA9IGF3YWl0IGNlcnRpZmljYXRlc0NvbnRyYWN0LnZlcmlmeUNlcnRpZmljYXRlKGNlcnRpZmljYXRlSWQpO1xyXG4gICAgcmV0dXJuIGlzVmFsaWQ7XHJcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgdmVyaWZ5aW5nIGNlcnRpZmljYXRlOicsIGVycm9yKTtcclxuICAgIHRocm93IGVycm9yO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRDZXJ0aWZpY2F0ZXMgPSBhc3luYyAoYWRkcmVzczogc3RyaW5nKSA9PiB7XHJcbiAgaWYgKCFhZGRyZXNzIHx8ICFnZXRBZGRyZXNzKGFkZHJlc3MpKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYWRkcmVzcycpO1xyXG4gIH1cclxuXHJcbiAgdHJ5IHtcclxuICAgIGNvbnNvbGUubG9nKCdHZXR0aW5nIGNlcnRpZmljYXRlcyBmb3IgYWRkcmVzczonLCBhZGRyZXNzKTtcclxuICAgIGNvbnN0IHsgY2VydGlmaWNhdGVzQ29udHJhY3QgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xyXG5cclxuICAgIC8vIEdldCBjZXJ0aWZpY2F0ZSBJRHMgZmlyc3RcclxuICAgIGNvbnNvbGUubG9nKCdHZXR0aW5nIGNlcnRpZmljYXRlIElEcy4uLicpO1xyXG4gICAgY29uc3QgY2VydGlmaWNhdGVJZHMgPSBhd2FpdCBjZXJ0aWZpY2F0ZXNDb250cmFjdC5nZXRTdHVkZW50Q2VydGlmaWNhdGVzKGFkZHJlc3MpO1xyXG4gICAgY29uc29sZS5sb2coJ0NlcnRpZmljYXRlIElEczonLCBjZXJ0aWZpY2F0ZUlkcyk7XHJcblxyXG4gICAgaWYgKCFjZXJ0aWZpY2F0ZUlkcyB8fCBjZXJ0aWZpY2F0ZUlkcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgY29uc29sZS5sb2coJ05vIGNlcnRpZmljYXRlcyBmb3VuZCcpO1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcblxyXG4gICAgLy8gR2V0IGRldGFpbHMgZm9yIGVhY2ggY2VydGlmaWNhdGVcclxuICAgIGNvbnNvbGUubG9nKCdHZXR0aW5nIGNlcnRpZmljYXRlIGRldGFpbHMuLi4nKTtcclxuICAgIGNvbnN0IGNlcnRpZmljYXRlcyA9IGF3YWl0IFByb21pc2UuYWxsKFxyXG4gICAgICBjZXJ0aWZpY2F0ZUlkcy5tYXAoYXN5bmMgKGlkOiBzdHJpbmcpID0+IHtcclxuICAgICAgICBjb25zdCBjZXJ0ID0gYXdhaXQgY2VydGlmaWNhdGVzQ29udHJhY3QudmVyaWZ5Q2VydGlmaWNhdGUoaWQpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBpZCxcclxuICAgICAgICAgIGlwZnNIYXNoOiBjZXJ0LmlwZnNIYXNoLFxyXG4gICAgICAgICAgaXNzdWVyOiBjZXJ0Lmluc3RpdHV0aW9uLFxyXG4gICAgICAgICAgdGltZXN0YW1wOiBjZXJ0Lmlzc3VlZEF0LnRvU3RyaW5nKCksXHJcbiAgICAgICAgICBpc1ZhbGlkOiBjZXJ0LmlzVmFsaWRcclxuICAgICAgICB9O1xyXG4gICAgICB9KVxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zb2xlLmxvZygnQ2VydGlmaWNhdGUgZGV0YWlsczonLCBjZXJ0aWZpY2F0ZXMpO1xyXG4gICAgcmV0dXJuIGNlcnRpZmljYXRlcztcclxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBnZXRDZXJ0aWZpY2F0ZXM6JywgZXJyb3IpO1xyXG4gICAgaWYgKGVycm9yLnJlYXNvbikge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbnRyYWN0IGVycm9yOiAke2Vycm9yLnJlYXNvbn1gKTtcclxuICAgIH1cclxuICAgIHRocm93IGVycm9yO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBpc1ZlcmlmaWVkVXNlciA9IGFzeW5jIChhZGRyZXNzOiBzdHJpbmcpID0+IHtcclxuICBpZiAoIWFkZHJlc3MgfHwgIWdldEFkZHJlc3MoYWRkcmVzcykpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhZGRyZXNzJyk7XHJcbiAgfVxyXG5cclxuICB0cnkge1xyXG4gICAgY29uc3QgeyBpZGVudGl0eUNvbnRyYWN0IH0gPSBhd2FpdCBnZXRDb250cmFjdHMoKTtcclxuICAgIHJldHVybiBhd2FpdCBpZGVudGl0eUNvbnRyYWN0LmlzVmVyaWZpZWRVc2VyKGFkZHJlc3MpO1xyXG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNoZWNraW5nIHZlcmlmaWNhdGlvbiBzdGF0dXM6JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gQWRtaW4gZnVuY3Rpb25zXHJcbmV4cG9ydCBjb25zdCBpc093bmVyID0gYXN5bmMgKGFkZHJlc3M6IHN0cmluZykgPT4ge1xyXG4gIGlmICghYWRkcmVzcyB8fCAhZ2V0QWRkcmVzcyhhZGRyZXNzKSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFkZHJlc3MnKTtcclxuICB9XHJcblxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB7IGlkZW50aXR5Q29udHJhY3QgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xyXG4gICAgY29uc3Qgb3duZXIgPSBhd2FpdCBpZGVudGl0eUNvbnRyYWN0Lm93bmVyKCk7XHJcblxyXG4gICAgLy8gQWRkIGFkZGl0aW9uYWwgY2hlY2tzXHJcbiAgICBpZiAoIW93bmVyKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybignT3duZXIgYWRkcmVzcyBpcyBudWxsIG9yIHVuZGVmaW5lZCcpO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG93bmVyLnRvTG93ZXJDYXNlKCkgPT09IGFkZHJlc3MudG9Mb3dlckNhc2UoKTtcclxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyBvd25lciBzdGF0dXM6JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHZlcmlmeUluc3RpdHV0aW9uID0gYXN5bmMgKGluc3RpdHV0aW9uQWRkcmVzczogc3RyaW5nKSA9PiB7XHJcbiAgaWYgKCFpbnN0aXR1dGlvbkFkZHJlc3MgfHwgIWdldEFkZHJlc3MoaW5zdGl0dXRpb25BZGRyZXNzKSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGluc3RpdHV0aW9uIGFkZHJlc3MnKTtcclxuICB9XHJcblxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB7IGlkZW50aXR5Q29udHJhY3QsIGV4YW1NYW5hZ2VtZW50Q29udHJhY3QgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xyXG4gICAgY29uc3QgaWRlbnRpdHlUeCA9IGF3YWl0IGlkZW50aXR5Q29udHJhY3QudmVyaWZ5VXNlcihpbnN0aXR1dGlvbkFkZHJlc3MpO1xyXG4gICAgYXdhaXQgaWRlbnRpdHlUeC53YWl0KCk7XHJcbiAgICBjb25zdCBleGFtTWFuYWdlbWVudFR4ID0gYXdhaXQgZXhhbU1hbmFnZW1lbnRDb250cmFjdC52ZXJpZnlJbnN0aXR1dGlvbihpbnN0aXR1dGlvbkFkZHJlc3MpO1xyXG4gICAgYXdhaXQgZXhhbU1hbmFnZW1lbnRUeC53YWl0KCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBpZGVudGl0eUhhc2g6IGlkZW50aXR5VHguaGFzaCxcclxuICAgICAgZXhhbU1hbmFnZW1lbnRIYXNoOiBleGFtTWFuYWdlbWVudFR4Lmhhc2hcclxuICAgIH07XHJcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgdmVyaWZ5aW5nIGluc3RpdHV0aW9uOicsIGVycm9yKTtcclxuICAgIHRocm93IGVycm9yO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRPd25lckFkZHJlc3MgPSBhc3luYyAoKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHsgaWRlbnRpdHlDb250cmFjdCB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XHJcbiAgICBjb25zdCBvd25lciA9IGF3YWl0IGlkZW50aXR5Q29udHJhY3Qub3duZXIoKTtcclxuICAgIHJldHVybiBvd25lcjtcclxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIG93bmVyIGFkZHJlc3M6JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gQWRkIGV4YW0gbWFuYWdlbWVudCBjb250cmFjdCBhZGRyZXNzIGFuZCBBQklcclxuY29uc3QgRVhBTV9NQU5BR0VNRU5UX0FERFJFU1MgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19FWEFNX01BTkFHRU1FTlRfQUREUkVTUyB8fCBcIlwiO1xyXG5jb25zdCBFWEFNX01BTkFHRU1FTlRfQUJJID0gRXhhbU1hbmFnZW1lbnRBQkk7XHJcblxyXG4vLyBBZGQgZXhhbSBtYW5hZ2VtZW50IGZ1bmN0aW9uc1xyXG5leHBvcnQgY29uc3QgY3JlYXRlRXhhbSA9IGFzeW5jIChcclxuICBpZDogc3RyaW5nLFxyXG4gIHRpdGxlOiBzdHJpbmcsXHJcbiAgZGVzY3JpcHRpb246IHN0cmluZyxcclxuICBkYXRlOiBudW1iZXIsXHJcbiAgZHVyYXRpb246IG51bWJlcixcclxuICBpcGZzSGFzaDogc3RyaW5nXHJcbikgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBpZiAoIXdpbmRvdy5ldGhlcmV1bSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGV0aGVyZXVtIHByb3ZpZGVyIGZvdW5kJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwcm92aWRlciA9IG5ldyBldGhlcnMuSnNvblJwY1Byb3ZpZGVyKEVYUEVDVEVEX05FVFdPUksucnBjVXJsKTtcclxuICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IHByb3ZpZGVyLmdldFNpZ25lcigpO1xyXG4gICAgY29uc3QgY29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KEVYQU1fTUFOQUdFTUVOVF9BRERSRVNTLCBFWEFNX01BTkFHRU1FTlRfQUJJLCBzaWduZXIpO1xyXG5cclxuICAgIGNvbnN0IHR4ID0gYXdhaXQgY29udHJhY3QuY3JlYXRlRXhhbShpZCwgdGl0bGUsIGRlc2NyaXB0aW9uLCBkYXRlLCBkdXJhdGlvbiwgaXBmc0hhc2gpO1xyXG4gICAgYXdhaXQgdHgud2FpdCgpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIGV4YW06JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHN1Ym1pdEV4YW1SZXN1bHQgPSBhc3luYyAoXHJcbiAgZXhhbUlkOiBzdHJpbmcsXHJcbiAgc3R1ZGVudDogc3RyaW5nLFxyXG4gIHNjb3JlOiBudW1iZXIsXHJcbiAgZ3JhZGU6IHN0cmluZyxcclxuICBpcGZzSGFzaDogc3RyaW5nXHJcbikgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBpZiAoIXdpbmRvdy5ldGhlcmV1bSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGV0aGVyZXVtIHByb3ZpZGVyIGZvdW5kJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwcm92aWRlciA9IG5ldyBldGhlcnMuSnNvblJwY1Byb3ZpZGVyKEVYUEVDVEVEX05FVFdPUksucnBjVXJsKTtcclxuICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IHByb3ZpZGVyLmdldFNpZ25lcigpO1xyXG4gICAgY29uc3QgY29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KEVYQU1fTUFOQUdFTUVOVF9BRERSRVNTLCBFWEFNX01BTkFHRU1FTlRfQUJJLCBzaWduZXIpO1xyXG5cclxuICAgIGNvbnN0IHR4ID0gYXdhaXQgY29udHJhY3Quc3VibWl0RXhhbVJlc3VsdChleGFtSWQsIHN0dWRlbnQsIHNjb3JlLCBncmFkZSwgaXBmc0hhc2gpO1xyXG4gICAgYXdhaXQgdHgud2FpdCgpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHN1Ym1pdHRpbmcgZXhhbSByZXN1bHQ6JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHVwZGF0ZUV4YW1TdGF0dXMgPSBhc3luYyAoZXhhbUlkOiBzdHJpbmcsIHN0YXR1czogc3RyaW5nKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGlmICghd2luZG93LmV0aGVyZXVtKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZXRoZXJldW0gcHJvdmlkZXIgZm91bmQnKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IGV0aGVycy5Kc29uUnBjUHJvdmlkZXIoRVhQRUNURURfTkVUV09SSy5ycGNVcmwpO1xyXG4gICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgcHJvdmlkZXIuZ2V0U2lnbmVyKCk7XHJcbiAgICBjb25zdCBjb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoRVhBTV9NQU5BR0VNRU5UX0FERFJFU1MsIEVYQU1fTUFOQUdFTUVOVF9BQkksIHNpZ25lcik7XHJcblxyXG4gICAgY29uc3QgdHggPSBhd2FpdCBjb250cmFjdC51cGRhdGVFeGFtU3RhdHVzKGV4YW1JZCwgc3RhdHVzKTtcclxuICAgIGF3YWl0IHR4LndhaXQoKTtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBleGFtIHN0YXR1czonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBlcnJvcjtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0RXhhbSA9IGFzeW5jIChleGFtSWQ6IHN0cmluZykgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBpZiAoIXdpbmRvdy5ldGhlcmV1bSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGV0aGVyZXVtIHByb3ZpZGVyIGZvdW5kJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwcm92aWRlciA9IG5ldyBldGhlcnMuSnNvblJwY1Byb3ZpZGVyKEVYUEVDVEVEX05FVFdPUksucnBjVXJsKTtcclxuICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChFWEFNX01BTkFHRU1FTlRfQUREUkVTUywgRVhBTV9NQU5BR0VNRU5UX0FCSSwgcHJvdmlkZXIpO1xyXG5cclxuICAgIGNvbnN0IGV4YW0gPSBhd2FpdCBjb250cmFjdC5nZXRFeGFtKGV4YW1JZCk7XHJcbiAgICByZXR1cm4gZXhhbTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBleGFtOicsIGVycm9yKTtcclxuICAgIHRocm93IGVycm9yO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRFeGFtUmVzdWx0ID0gYXN5bmMgKGV4YW1JZDogc3RyaW5nLCBzdHVkZW50OiBzdHJpbmcpID0+IHtcclxuICB0cnkge1xyXG4gICAgaWYgKCF3aW5kb3cuZXRoZXJldW0pIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBldGhlcmV1bSBwcm92aWRlciBmb3VuZCcpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgZXRoZXJzLkpzb25ScGNQcm92aWRlcihFWFBFQ1RFRF9ORVRXT1JLLnJwY1VybCk7XHJcbiAgICBjb25zdCBjb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoRVhBTV9NQU5BR0VNRU5UX0FERFJFU1MsIEVYQU1fTUFOQUdFTUVOVF9BQkksIHByb3ZpZGVyKTtcclxuXHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb250cmFjdC5nZXRFeGFtUmVzdWx0KGV4YW1JZCwgc3R1ZGVudCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIGV4YW0gcmVzdWx0OicsIGVycm9yKTtcclxuICAgIHRocm93IGVycm9yO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRJbnN0aXR1dGlvbkV4YW1zID0gYXN5bmMgKGluc3RpdHV0aW9uOiBzdHJpbmcpID0+IHtcclxuICB0cnkge1xyXG4gICAgaWYgKCF3aW5kb3cuZXRoZXJldW0pIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBldGhlcmV1bSBwcm92aWRlciBmb3VuZCcpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgZXRoZXJzLkpzb25ScGNQcm92aWRlcihFWFBFQ1RFRF9ORVRXT1JLLnJwY1VybCk7XHJcbiAgICBjb25zdCBjb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoRVhBTV9NQU5BR0VNRU5UX0FERFJFU1MsIEVYQU1fTUFOQUdFTUVOVF9BQkksIHByb3ZpZGVyKTtcclxuXHJcbiAgICBjb25zdCBleGFtcyA9IGF3YWl0IGNvbnRyYWN0LmdldEluc3RpdHV0aW9uRXhhbXMoaW5zdGl0dXRpb24pO1xyXG4gICAgcmV0dXJuIGV4YW1zO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIGluc3RpdHV0aW9uIGV4YW1zOicsIGVycm9yKTtcclxuICAgIHRocm93IGVycm9yO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRTdHVkZW50RXhhbXMgPSBhc3luYyAoc3R1ZGVudDogc3RyaW5nKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGlmICghd2luZG93LmV0aGVyZXVtKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZXRoZXJldW0gcHJvdmlkZXIgZm91bmQnKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IGV0aGVycy5Kc29uUnBjUHJvdmlkZXIoRVhQRUNURURfTkVUV09SSy5ycGNVcmwpO1xyXG4gICAgY29uc3QgY29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KEVYQU1fTUFOQUdFTUVOVF9BRERSRVNTLCBFWEFNX01BTkFHRU1FTlRfQUJJLCBwcm92aWRlcik7XHJcblxyXG4gICAgY29uc3QgZXhhbXMgPSBhd2FpdCBjb250cmFjdC5nZXRTdHVkZW50RXhhbXMoc3R1ZGVudCk7XHJcbiAgICByZXR1cm4gZXhhbXM7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgc3R1ZGVudCBleGFtczonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBlcnJvcjtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZW5yb2xsU3R1ZGVudCA9IGFzeW5jIChleGFtSWQ6IHN0cmluZywgc3R1ZGVudEFkZHJlc3M6IHN0cmluZykgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBpZiAoIXdpbmRvdy5ldGhlcmV1bSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGV0aGVyZXVtIHByb3ZpZGVyIGZvdW5kJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwcm92aWRlciA9IG5ldyBldGhlcnMuSnNvblJwY1Byb3ZpZGVyKEVYUEVDVEVEX05FVFdPUksucnBjVXJsKTtcclxuICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IHByb3ZpZGVyLmdldFNpZ25lcigpO1xyXG4gICAgY29uc3QgY29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KEVYQU1fTUFOQUdFTUVOVF9BRERSRVNTLCBFWEFNX01BTkFHRU1FTlRfQUJJLCBzaWduZXIpO1xyXG5cclxuICAgIGNvbnN0IHR4ID0gYXdhaXQgY29udHJhY3QuZW5yb2xsU3R1ZGVudChleGFtSWQsIHN0dWRlbnRBZGRyZXNzKTtcclxuICAgIGF3YWl0IHR4LndhaXQoKTtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBlbnJvbGxpbmcgc3R1ZGVudDonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBlcnJvcjtcclxuICB9XHJcbn07Il0sIm5hbWVzIjpbImV0aGVycyIsIkV4YW1NYW5hZ2VtZW50QUJJIiwiSWRlbnRpdHlBQkkiLCJDZXJ0aWZpY2F0ZXNBQkkiLCJnZXRQcm92aWRlciIsImdldFNpZ25lciIsIkVYUEVDVEVEX05FVFdPUksiLCJnZXRBZGRyZXNzIiwiZ2V0Q29uZmlnIiwiSURFTlRJVFlfQ09OVFJBQ1RfQUREUkVTUyIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19JREVOVElUWV9DT05UUkFDVF9BRERSRVNTIiwiQ0VSVElGSUNBVEVTX0NPTlRSQUNUX0FERFJFU1MiLCJORVhUX1BVQkxJQ19DRVJUSUZJQ0FURVNfQ09OVFJBQ1RfQUREUkVTUyIsIkVYQU1fTUFOQUdFTUVOVF9DT05UUkFDVF9BRERSRVNTIiwiTkVYVF9QVUJMSUNfRVhBTV9NQU5BR0VNRU5UX0NPTlRSQUNUX0FERFJFU1MiLCJVU0VSX1JPTEVTIiwiTk9ORSIsIlNUVURFTlQiLCJJTlNUSVRVVElPTiIsIkVNUExPWUVSIiwicm9sZU1hcCIsImNvbnNvbGUiLCJlcnJvciIsImdldENvbnRyYWN0cyIsInByb3ZpZGVyIiwic2lnbmVyIiwiaWRlbnRpdHlDb250cmFjdCIsIkNvbnRyYWN0IiwiY2VydGlmaWNhdGVzQ29udHJhY3QiLCJleGFtTWFuYWdlbWVudENvbnRyYWN0IiwiRXJyb3IiLCJtZXNzYWdlIiwicmVnaXN0ZXJVc2VyIiwicm9sZSIsIndpbmRvdyIsImV0aGVyZXVtIiwiQnJvd3NlclByb3ZpZGVyIiwiaWRlbnRpdHlBZGRyZXNzIiwicm9sZVZhbHVlIiwidG9Mb3dlckNhc2UiLCJ1bmRlZmluZWQiLCJ0eCIsIndhaXQiLCJzdGF0dXMiLCJ2ZXJpZnlVc2VyIiwiYWRkcmVzcyIsImdldFVzZXJSb2xlIiwiaXNzdWVDZXJ0aWZpY2F0ZSIsInN0dWRlbnRBZGRyZXNzIiwiaXBmc0hhc2giLCJ2ZXJpZnlDZXJ0aWZpY2F0ZSIsImNlcnRpZmljYXRlSWQiLCJpc1ZhbGlkIiwiZ2V0Q2VydGlmaWNhdGVzIiwibG9nIiwiY2VydGlmaWNhdGVJZHMiLCJnZXRTdHVkZW50Q2VydGlmaWNhdGVzIiwibGVuZ3RoIiwiY2VydGlmaWNhdGVzIiwiUHJvbWlzZSIsImFsbCIsIm1hcCIsImlkIiwiY2VydCIsImlzc3VlciIsImluc3RpdHV0aW9uIiwidGltZXN0YW1wIiwiaXNzdWVkQXQiLCJ0b1N0cmluZyIsInJlYXNvbiIsImlzVmVyaWZpZWRVc2VyIiwiaXNPd25lciIsIm93bmVyIiwid2FybiIsInZlcmlmeUluc3RpdHV0aW9uIiwiaW5zdGl0dXRpb25BZGRyZXNzIiwiaWRlbnRpdHlUeCIsImV4YW1NYW5hZ2VtZW50VHgiLCJpZGVudGl0eUhhc2giLCJoYXNoIiwiZXhhbU1hbmFnZW1lbnRIYXNoIiwiZ2V0T3duZXJBZGRyZXNzIiwiRVhBTV9NQU5BR0VNRU5UX0FERFJFU1MiLCJORVhUX1BVQkxJQ19FWEFNX01BTkFHRU1FTlRfQUREUkVTUyIsIkVYQU1fTUFOQUdFTUVOVF9BQkkiLCJjcmVhdGVFeGFtIiwidGl0bGUiLCJkZXNjcmlwdGlvbiIsImRhdGUiLCJkdXJhdGlvbiIsIkpzb25ScGNQcm92aWRlciIsInJwY1VybCIsImNvbnRyYWN0Iiwic3VibWl0RXhhbVJlc3VsdCIsImV4YW1JZCIsInN0dWRlbnQiLCJzY29yZSIsImdyYWRlIiwidXBkYXRlRXhhbVN0YXR1cyIsImdldEV4YW0iLCJleGFtIiwiZ2V0RXhhbVJlc3VsdCIsInJlc3VsdCIsImdldEluc3RpdHV0aW9uRXhhbXMiLCJleGFtcyIsImdldFN0dWRlbnRFeGFtcyIsImVucm9sbFN0dWRlbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./utils/contracts.ts\n"));

/***/ })

});