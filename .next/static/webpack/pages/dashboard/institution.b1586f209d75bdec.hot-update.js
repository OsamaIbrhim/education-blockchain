"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/dashboard/institution",{

/***/ "./utilsFront/contracts.ts":
/*!*********************************!*\
  !*** ./utilsFront/contracts.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createExam: function() { return /* binding */ createExam; },\n/* harmony export */   enrollStudent: function() { return /* binding */ enrollStudent; },\n/* harmony export */   getCertificates: function() { return /* binding */ getCertificates; },\n/* harmony export */   getContract: function() { return /* binding */ getContract; },\n/* harmony export */   getContracts: function() { return /* binding */ getContracts; },\n/* harmony export */   getExam: function() { return /* binding */ getExam; },\n/* harmony export */   getExamResult: function() { return /* binding */ getExamResult; },\n/* harmony export */   getInstitutionExams: function() { return /* binding */ getInstitutionExams; },\n/* harmony export */   getOwnerAddress: function() { return /* binding */ getOwnerAddress; },\n/* harmony export */   getStudentExams: function() { return /* binding */ getStudentExams; },\n/* harmony export */   getUserRole: function() { return /* binding */ getUserRole; },\n/* harmony export */   isOwner: function() { return /* binding */ isOwner; },\n/* harmony export */   isVerifiedUser: function() { return /* binding */ isVerifiedUser; },\n/* harmony export */   issueCertificate: function() { return /* binding */ issueCertificate; },\n/* harmony export */   registerUser: function() { return /* binding */ registerUser; },\n/* harmony export */   setAdminRole: function() { return /* binding */ setAdminRole; },\n/* harmony export */   submitExamResult: function() { return /* binding */ submitExamResult; },\n/* harmony export */   updateExamStatus: function() { return /* binding */ updateExamStatus; },\n/* harmony export */   validateEnv: function() { return /* binding */ validateEnv; },\n/* harmony export */   verifyCertificate: function() { return /* binding */ verifyCertificate; },\n/* harmony export */   verifyInstitution: function() { return /* binding */ verifyInstitution; },\n/* harmony export */   verifyUser: function() { return /* binding */ verifyUser; }\n/* harmony export */ });\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"./node_modules/.pnpm/ethers@6.13.5_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/ethers/lib.esm/index.js\");\n/* harmony import */ var _constants_abis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/abis */ \"./constants/abis.ts\");\n/* harmony import */ var _ethersConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ethersConfig */ \"./utilsFront/ethersConfig.ts\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./config */ \"./utilsFront/config.ts\");\n\n\n\n\n// Contract ABIs\nconst IdentityABI = [\n    \"function registerUser(uint8 _role, string memory _ipfsHash) external\",\n    \"function verifyUser(address _userAddress) external\",\n    \"function getUserRole(address _userAddress) external view returns (uint8)\",\n    \"function isVerifiedUser(address _userAddress) external view returns (bool)\",\n    \"function updateUserIPFS(string memory _newIpfsHash) external\",\n    \"function owner() external view returns (address)\",\n    \"function isAdmin(address _address) external view returns (bool)\",\n    \"function addAdmin(address _newAdmin) external\",\n    \"function removeAdmin(address _admin) external\"\n];\nconst CertificatesABI = [\n    \"function issueCertificate(address _studentAddress, string memory _ipfsHash) external returns (bytes32)\",\n    \"function getStudentCertificates(address _student) external view returns (bytes32[])\",\n    \"function verifyCertificate(bytes32 _certificateId) external view returns (address student, address institution, string ipfsHash, uint256 issuedAt, bool isValid)\"\n];\n// Contract addresses from config\nconst IDENTITY_CONTRACT_ADDRESS = (0,_config__WEBPACK_IMPORTED_MODULE_2__.getConfig)(\"IDENTITY_CONTRACT_ADDRESS\");\nconst CERTIFICATES_CONTRACT_ADDRESS = (0,_config__WEBPACK_IMPORTED_MODULE_2__.getConfig)(\"CERTIFICATES_CONTRACT_ADDRESS\");\nconst ADMIN_ADDRESS = (0,_config__WEBPACK_IMPORTED_MODULE_2__.getConfig)(\"ADMIN_ADDRESS\");\nconst EXAM_MANAGEMENT_ADDRESS = (0,_config__WEBPACK_IMPORTED_MODULE_2__.getConfig)(\"EXAM_MANAGEMENT_CONTRACT_ADDRESS\");\n// Validate environment variables\nconst validateEnv = ()=>{\n    try {\n        // التحقق من صحة التكوين\n        (0,_config__WEBPACK_IMPORTED_MODULE_2__.validateConfig)();\n        // التحقق من صحة العناوين\n        if (!(0,ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress)(IDENTITY_CONTRACT_ADDRESS)) {\n            throw new Error(\"Invalid Identity contract address: \".concat(IDENTITY_CONTRACT_ADDRESS));\n        }\n        if (!(0,ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress)(CERTIFICATES_CONTRACT_ADDRESS)) {\n            throw new Error(\"Invalid Certificates contract address: \".concat(CERTIFICATES_CONTRACT_ADDRESS));\n        }\n        if (!(0,ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress)(ADMIN_ADDRESS)) {\n            throw new Error(\"Invalid Admin address: \".concat(ADMIN_ADDRESS));\n        }\n        if (!(0,ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress)(EXAM_MANAGEMENT_ADDRESS)) {\n            throw new Error(\"Invalid Exam Management contract address: \".concat(EXAM_MANAGEMENT_ADDRESS));\n        }\n        console.log(\"Configuration validated successfully:\", {\n            IDENTITY_CONTRACT_ADDRESS,\n            CERTIFICATES_CONTRACT_ADDRESS,\n            ADMIN_ADDRESS,\n            EXAM_MANAGEMENT_ADDRESS,\n            CHAIN_ID: (0,_config__WEBPACK_IMPORTED_MODULE_2__.getConfig)(\"CHAIN_ID\"),\n            NETWORK_URL: (0,_config__WEBPACK_IMPORTED_MODULE_2__.getConfig)(\"NETWORK_URL\")\n        });\n        return true;\n    } catch (error) {\n        console.error(\"Configuration validation failed:\", error);\n        throw error;\n    }\n};\n// Debug environment variables\nconsole.log(\"Environment variables check:\", {\n    IDENTITY_CONTRACT_ADDRESS,\n    CERTIFICATES_CONTRACT_ADDRESS,\n    ADMIN_ADDRESS,\n    EXAM_MANAGEMENT_ADDRESS,\n    CHAIN_ID: _ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.chainId,\n    NETWORK_URL: _ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl\n});\n// Role mapping with proper types\nconst USER_ROLES = {\n    NONE: 0,\n    STUDENT: 1,\n    INSTITUTION: 2,\n    EMPLOYER: 3,\n    ADMIN: 4\n};\nconst roleMap = {\n    [USER_ROLES.NONE]: \"none\",\n    [USER_ROLES.STUDENT]: \"student\",\n    [USER_ROLES.INSTITUTION]: \"institution\",\n    [USER_ROLES.EMPLOYER]: \"employer\",\n    [USER_ROLES.ADMIN]: \"admin\"\n};\nconst getContracts = async ()=>{\n    try {\n        console.log(\"Contract Addresses:\", {\n            Identity: IDENTITY_CONTRACT_ADDRESS,\n            Certificates: CERTIFICATES_CONTRACT_ADDRESS,\n            Admin: ADMIN_ADDRESS\n        });\n        const provider = await (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getProvider)();\n        await (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.validateNetwork)(provider);\n        console.log(\"Network validation passed\");\n        const signer = await (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getSigner)();\n        const userAddress = await signer.getAddress();\n        console.log(\"Connected with address:\", userAddress);\n        const userBalance = await provider.getBalance(userAddress);\n        console.log(\"User balance:\", (0,ethers__WEBPACK_IMPORTED_MODULE_3__.formatUnits)(userBalance, \"ether\"), \"ETH\");\n        const identityContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.Contract(IDENTITY_CONTRACT_ADDRESS, IdentityABI, signer);\n        console.log(\"Verifying contract exists at address:\", IDENTITY_CONTRACT_ADDRESS);\n        const code = await provider.getCode(IDENTITY_CONTRACT_ADDRESS);\n        console.log(\"Contract code length:\", code.length);\n        console.log(\"Contract exists:\", code !== \"0x\");\n        if (code === \"0x\") {\n            throw new Error(\"Identity contract not found at address: \".concat(IDENTITY_CONTRACT_ADDRESS));\n        }\n        const certificatesContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.Contract(CERTIFICATES_CONTRACT_ADDRESS, CertificatesABI, signer);\n        const examManagementContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.Contract(EXAM_MANAGEMENT_ADDRESS, _constants_abis__WEBPACK_IMPORTED_MODULE_0__.ExamManagementABI, signer);\n        return {\n            identityContract,\n            certificatesContract,\n            examManagementContract,\n            provider,\n            signer\n        };\n    } catch (error) {\n        console.error(\"Error initializing contracts:\", error);\n        console.error(\"Error details:\", {\n            message: error.message,\n            code: error.code,\n            reason: error.reason\n        });\n        throw new Error(\"Failed to initialize contracts: \".concat(error.message));\n    }\n};\nconst registerUser = async (role)=>{\n    if (!role) {\n        throw new Error(\"Role is required\");\n    }\n    try {\n        const { identityContract, signer } = await getContracts();\n        // Get network details and user address\n        const userAddress = await signer.getAddress();\n        console.log(\"Registering address:\", userAddress);\n        console.log(\"With role:\", role);\n        // Special handling for admin address\n        if (ADMIN_ADDRESS && userAddress.toLowerCase() === ADMIN_ADDRESS.toLowerCase()) {\n            console.log(\"This is the admin address, setting admin role...\");\n            return await setAdminRole();\n        }\n        // Convert role string to enum value\n        const roleMap = {\n            \"student\": USER_ROLES.STUDENT,\n            \"institution\": USER_ROLES.INSTITUTION,\n            \"employer\": USER_ROLES.EMPLOYER,\n            \"admin\": USER_ROLES.ADMIN\n        };\n        const roleValue = roleMap[role.toLowerCase()];\n        if (roleValue === undefined) {\n            throw new Error(\"Invalid role: \".concat(role, \". Must be one of: student, institution, employer, admin\"));\n        }\n        console.log(\"Role value from mapping:\", roleValue);\n        // Check if user is already registered\n        try {\n            console.log(\"Checking if user already exists...\");\n            const existingRole = await identityContract.getUserRole(userAddress);\n            console.log(\"Existing role:\", existingRole);\n            if (existingRole > 0) {\n                console.log(\"User already registered with role:\", existingRole);\n                // If user exists but needs verification\n                const isVerified = await identityContract.isVerified(userAddress);\n                if (!isVerified) {\n                    console.log(\"User exists but not verified, attempting verification...\");\n                    const verifyTx = await identityContract.verifyUser(userAddress);\n                    await verifyTx.wait();\n                    console.log(\"User verified successfully\");\n                }\n                return {\n                    status: \"existing\",\n                    role: existingRole\n                };\n            }\n        } catch (error) {\n            if (!error.message.includes(\"User does not exist\")) {\n                throw error;\n            }\n            console.log(\"User does not exist, proceeding with registration\");\n        }\n        // Register user\n        console.log(\"Registering new user with role:\", roleValue);\n        const tx = await identityContract.registerUser(roleValue, \"\");\n        console.log(\"Registration transaction sent:\", tx.hash);\n        const receipt = await tx.wait();\n        console.log(\"Registration successful:\", receipt.hash);\n        // Verify the user automatically\n        try {\n            console.log(\"Attempting automatic verification...\");\n            const verifyTx = await identityContract.verifyUser(userAddress);\n            await verifyTx.wait();\n            console.log(\"User verified successfully\");\n        } catch (verifyError) {\n            console.warn(\"Automatic verification failed:\", verifyError);\n        // Continue even if verification fails\n        }\n        // If registering as admin, set admin role\n        if (role.toLowerCase() === \"admin\") {\n            console.log(\"Setting admin privileges...\");\n            await setAdminRole();\n        }\n        return {\n            status: \"success\",\n            role: roleValue,\n            transaction: tx\n        };\n    } catch (error) {\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst verifyUser = async (address)=>{\n    try {\n        (0,ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress)(address); // Using getAddress instead of isAddress\n    } catch (error) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        console.log(\"Verifying user:\", address);\n        const { identityContract } = await getContracts();\n        const isVerified = await identityContract.isVerified(address);\n        console.log(\"User verification status:\", isVerified);\n        return isVerified;\n    } catch (error) {\n        console.error(\"Error in verifyUser:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst getUserRole = async (address)=>{\n    try {\n        (0,ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress)(address);\n    } catch (error) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        console.log(\"Getting user role for:\", address);\n        const { identityContract } = await getContracts();\n        const role = await identityContract.getUserRole(address);\n        console.log(\"User role:\", role);\n        return role;\n    } catch (error) {\n        console.error(\"Error in getUserRole:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst issueCertificate = async (studentAddress, ipfsHash)=>{\n    if (!studentAddress || !ipfsHash) {\n        throw new Error(\"Student address and IPFS hash are required\");\n    }\n    try {\n        const { certificatesContract } = await getContracts();\n        const tx = await certificatesContract.issueCertificate(studentAddress, ipfsHash);\n        await tx.wait();\n        return tx;\n    } catch (error) {\n        console.error(\"Error issuing certificate:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst verifyCertificate = async (certificateId)=>{\n    if (!certificateId) {\n        throw new Error(\"Certificate ID is required\");\n    }\n    try {\n        const { certificatesContract } = await getContracts();\n        const isValid = await certificatesContract.verifyCertificate(certificateId);\n        return isValid;\n    } catch (error) {\n        console.error(\"Error verifying certificate:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst getCertificates = async (address)=>{\n    try {\n        (0,ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress)(address);\n    } catch (error) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        console.log(\"Getting certificates for:\", address);\n        const { certificatesContract } = await getContracts();\n        const certificates = await certificatesContract.getCertificates(address);\n        console.log(\"Certificates:\", certificates);\n        return certificates;\n    } catch (error) {\n        console.error(\"Error in getCertificates:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst isVerifiedUser = async (address)=>{\n    try {\n        (0,ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress)(address);\n    } catch (error) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        console.log(\"Checking if user is verified:\", address);\n        const { identityContract } = await getContracts();\n        const isVerified = await identityContract.isVerified(address);\n        console.log(\"User verification status:\", isVerified);\n        return isVerified;\n    } catch (error) {\n        console.error(\"Error in isVerifiedUser:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst isOwner = async (address)=>{\n    try {\n        (0,ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress)(address);\n    } catch (error) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        console.log(\"Checking if user is owner:\", address);\n        const { identityContract } = await getContracts();\n        const ownerAddress = await identityContract.owner();\n        const isOwnerRole = address.toLowerCase() === ownerAddress.toLowerCase();\n        console.log(\"User owner status:\", isOwnerRole);\n        return isOwnerRole;\n    } catch (error) {\n        console.error(\"Error in isOwner:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst verifyInstitution = async (institutionAddress)=>{\n    try {\n        (0,ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress)(institutionAddress);\n    } catch (error) {\n        throw new Error(\"Invalid institution address\");\n    }\n    try {\n        console.log(\"Verifying institution:\", institutionAddress);\n        const { identityContract } = await getContracts();\n        const tx = await identityContract.verifyUser(institutionAddress);\n        await tx.wait();\n        console.log(\"Institution verified successfully\");\n        return true;\n    } catch (error) {\n        console.error(\"Error in verifyInstitution:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst getOwnerAddress = async ()=>{\n    try {\n        const { identityContract } = await getContracts();\n        const owner = await identityContract.owner();\n        return owner;\n    } catch (error) {\n        console.error(\"Error getting owner address:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\n// Add exam management functions\nconst createExam = async (id, title, description, date, duration, ipfsHash)=>{\n    try {\n        const { examManagementContract } = await getContracts();\n        const tx = await examManagementContract.createExam(id, title, description, date, duration, ipfsHash);\n        await tx.wait();\n        return true;\n    } catch (error) {\n        console.error(\"Error creating exam:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst submitExamResult = async (examId, student, score, grade, ipfsHash)=>{\n    try {\n        const { examManagementContract } = await getContracts();\n        const tx = await examManagementContract.submitExamResult(examId, student, score, grade, ipfsHash);\n        await tx.wait();\n        return true;\n    } catch (error) {\n        console.error(\"Error submitting exam result:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst updateExamStatus = async (examId, status)=>{\n    try {\n        const { examManagementContract } = await getContracts();\n        const tx = await examManagementContract.updateExamStatus(examId, status);\n        await tx.wait();\n        return true;\n    } catch (error) {\n        console.error(\"Error updating exam status:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst getExam = async (examId)=>{\n    try {\n        const { examManagementContract } = await getContracts();\n        const exam = await examManagementContract.getExam(examId);\n        return exam;\n    } catch (error) {\n        console.error(\"Error getting exam:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst getExamResult = async (examId, student)=>{\n    try {\n        const { examManagementContract } = await getContracts();\n        const result = await examManagementContract.getExamResult(examId, student);\n        return result;\n    } catch (error) {\n        console.error(\"Error getting exam result:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst getInstitutionExams = async (institution)=>{\n    try {\n        const { examManagementContract } = await getContracts();\n        const exams = await examManagementContract.getInstitutionExams(institution);\n        return exams;\n    } catch (error) {\n        console.error(\"Error getting institution exams:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst getStudentExams = async (student)=>{\n    try {\n        const { examManagementContract } = await getContracts();\n        const exams = await examManagementContract.getStudentExams(student);\n        return exams;\n    } catch (error) {\n        console.error(\"Error getting student exams:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst enrollStudent = async (examId, studentAddress)=>{\n    try {\n        const { examManagementContract } = await getContracts();\n        const tx = await examManagementContract.enrollStudent(examId, studentAddress);\n        await tx.wait();\n        return true;\n    } catch (error) {\n        console.error(\"Error enrolling student:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst getContract = async ()=>{\n    const { examManagementContract } = await getContracts();\n    return examManagementContract;\n};\nconst setAdminRole = async ()=>{\n    try {\n        const { identityContract, signer } = await getContracts();\n        const userAddress = await signer.getAddress();\n        console.log(\"Setting admin role for address:\", userAddress);\n        console.log(\"Expected admin address:\", ADMIN_ADDRESS);\n        // First check if the address is already an admin\n        const isAdmin = await identityContract.isAdmin(userAddress);\n        console.log(\"Is already admin?\", isAdmin);\n        if (isAdmin) {\n            console.log(\"User is already an admin\");\n            return {\n                status: \"existing\",\n                isAdmin: true\n            };\n        }\n        // Check if this is the configured admin address\n        if (ADMIN_ADDRESS && userAddress.toLowerCase() === ADMIN_ADDRESS.toLowerCase()) {\n            console.log(\"Address matches configured admin, adding as admin...\");\n            // First try to register as admin if not already registered\n            try {\n                const role = await identityContract.getUserRole(userAddress);\n                if (role === 0) {\n                    console.log(\"Registering admin user first...\");\n                    const regTx = await identityContract.registerUser(USER_ROLES.ADMIN, \"\");\n                    await regTx.wait();\n                }\n            } catch (error) {\n                if (!error.message.includes(\"User does not exist\")) {\n                    throw error;\n                }\n                // If user doesn't exist, register them as admin\n                console.log(\"Registering new admin user...\");\n                const regTx = await identityContract.registerUser(USER_ROLES.ADMIN, \"\");\n                await regTx.wait();\n            }\n            // Verify the user\n            console.log(\"Verifying admin user...\");\n            const verifyTx = await identityContract.verifyUser(userAddress);\n            await verifyTx.wait();\n            // Add admin role\n            console.log(\"Adding admin role...\");\n            const tx = await identityContract.addAdmin(userAddress);\n            await tx.wait();\n            console.log(\"Successfully added as admin\");\n            return {\n                status: \"success\",\n                isAdmin: true\n            };\n        }\n        throw new Error(\"Only configured admin addresses can be set as admin\");\n    } catch (error) {\n        console.error(\"Error setting admin role:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0lBQzdCO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi91dGlsc0Zyb250L2NvbnRyYWN0cy50cz9hY2E2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFxuICBDb250cmFjdCxcbiAgZm9ybWF0VW5pdHMsXG4gIGdldEFkZHJlc3Ncbn0gZnJvbSAnZXRoZXJzJztcbmltcG9ydCB7IEV4YW1NYW5hZ2VtZW50QUJJIH0gZnJvbSAnLi4vY29uc3RhbnRzL2FiaXMnO1xuaW1wb3J0IHsgXG4gIGdldFByb3ZpZGVyLCBcbiAgZ2V0U2lnbmVyLCBcbiAgRVhQRUNURURfTkVUV09SSywgXG4gIHZhbGlkYXRlTmV0d29yayxcbiAgZm9ybWF0RXRoZXIsXG4gIGhhbmRsZUNvbnRyYWN0RXJyb3Jcbn0gZnJvbSAnLi9ldGhlcnNDb25maWcnO1xuaW1wb3J0IHR5cGUgeyBFdGhlcmV1bVByb3ZpZGVyIH0gZnJvbSAnLi9ldGhlcnNDb25maWcnO1xuaW1wb3J0IHsgZ2V0Q29uZmlnLCB2YWxpZGF0ZUNvbmZpZyB9IGZyb20gJy4vY29uZmlnJztcblxuLy8gQ29udHJhY3QgQUJJc1xuY29uc3QgSWRlbnRpdHlBQkkgPSBbXG4gIFwiZnVuY3Rpb24gcmVnaXN0ZXJVc2VyKHVpbnQ4IF9yb2xlLCBzdHJpbmcgbWVtb3J5IF9pcGZzSGFzaCkgZXh0ZXJuYWxcIixcbiAgXCJmdW5jdGlvbiB2ZXJpZnlVc2VyKGFkZHJlc3MgX3VzZXJBZGRyZXNzKSBleHRlcm5hbFwiLFxuICBcImZ1bmN0aW9uIGdldFVzZXJSb2xlKGFkZHJlc3MgX3VzZXJBZGRyZXNzKSBleHRlcm5hbCB2aWV3IHJldHVybnMgKHVpbnQ4KVwiLFxuICBcImZ1bmN0aW9uIGlzVmVyaWZpZWRVc2VyKGFkZHJlc3MgX3VzZXJBZGRyZXNzKSBleHRlcm5hbCB2aWV3IHJldHVybnMgKGJvb2wpXCIsXG4gIFwiZnVuY3Rpb24gdXBkYXRlVXNlcklQRlMoc3RyaW5nIG1lbW9yeSBfbmV3SXBmc0hhc2gpIGV4dGVybmFsXCIsXG4gIFwiZnVuY3Rpb24gb3duZXIoKSBleHRlcm5hbCB2aWV3IHJldHVybnMgKGFkZHJlc3MpXCIsXG4gIFwiZnVuY3Rpb24gaXNBZG1pbihhZGRyZXNzIF9hZGRyZXNzKSBleHRlcm5hbCB2aWV3IHJldHVybnMgKGJvb2wpXCIsXG4gIFwiZnVuY3Rpb24gYWRkQWRtaW4oYWRkcmVzcyBfbmV3QWRtaW4pIGV4dGVybmFsXCIsXG4gIFwiZnVuY3Rpb24gcmVtb3ZlQWRtaW4oYWRkcmVzcyBfYWRtaW4pIGV4dGVybmFsXCJcbl07XG5cbmNvbnN0IENlcnRpZmljYXRlc0FCSSA9IFtcbiAgXCJmdW5jdGlvbiBpc3N1ZUNlcnRpZmljYXRlKGFkZHJlc3MgX3N0dWRlbnRBZGRyZXNzLCBzdHJpbmcgbWVtb3J5IF9pcGZzSGFzaCkgZXh0ZXJuYWwgcmV0dXJucyAoYnl0ZXMzMilcIixcbiAgXCJmdW5jdGlvbiBnZXRTdHVkZW50Q2VydGlmaWNhdGVzKGFkZHJlc3MgX3N0dWRlbnQpIGV4dGVybmFsIHZpZXcgcmV0dXJucyAoYnl0ZXMzMltdKVwiLFxuICBcImZ1bmN0aW9uIHZlcmlmeUNlcnRpZmljYXRlKGJ5dGVzMzIgX2NlcnRpZmljYXRlSWQpIGV4dGVybmFsIHZpZXcgcmV0dXJucyAoYWRkcmVzcyBzdHVkZW50LCBhZGRyZXNzIGluc3RpdHV0aW9uLCBzdHJpbmcgaXBmc0hhc2gsIHVpbnQyNTYgaXNzdWVkQXQsIGJvb2wgaXNWYWxpZClcIlxuXTtcblxuLy8gQ29udHJhY3QgYWRkcmVzc2VzIGZyb20gY29uZmlnXG5jb25zdCBJREVOVElUWV9DT05UUkFDVF9BRERSRVNTID0gZ2V0Q29uZmlnKCdJREVOVElUWV9DT05UUkFDVF9BRERSRVNTJyk7XG5jb25zdCBDRVJUSUZJQ0FURVNfQ09OVFJBQ1RfQUREUkVTUyA9IGdldENvbmZpZygnQ0VSVElGSUNBVEVTX0NPTlRSQUNUX0FERFJFU1MnKTtcbmNvbnN0IEFETUlOX0FERFJFU1MgPSBnZXRDb25maWcoJ0FETUlOX0FERFJFU1MnKTtcbmNvbnN0IEVYQU1fTUFOQUdFTUVOVF9BRERSRVNTID0gZ2V0Q29uZmlnKCdFWEFNX01BTkFHRU1FTlRfQ09OVFJBQ1RfQUREUkVTUycpO1xuXG4vLyBWYWxpZGF0ZSBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbmV4cG9ydCBjb25zdCB2YWxpZGF0ZUVudiA9ICgpID0+IHtcbiAgdHJ5IHtcbiAgICAvLyDYp9mE2KrYrdmC2YIg2YXZhiDYtdit2Kkg2KfZhNiq2YPZiNmK2YZcbiAgICB2YWxpZGF0ZUNvbmZpZygpO1xuXG4gICAgLy8g2KfZhNiq2K3ZgtmCINmF2YYg2LXYrdipINin2YTYudmG2KfZiNmK2YZcbiAgICBpZiAoIWdldEFkZHJlc3MoSURFTlRJVFlfQ09OVFJBQ1RfQUREUkVTUykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBJZGVudGl0eSBjb250cmFjdCBhZGRyZXNzOiAke0lERU5USVRZX0NPTlRSQUNUX0FERFJFU1N9YCk7XG4gICAgfVxuXG4gICAgaWYgKCFnZXRBZGRyZXNzKENFUlRJRklDQVRFU19DT05UUkFDVF9BRERSRVNTKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIENlcnRpZmljYXRlcyBjb250cmFjdCBhZGRyZXNzOiAke0NFUlRJRklDQVRFU19DT05UUkFDVF9BRERSRVNTfWApO1xuICAgIH1cblxuICAgIGlmICghZ2V0QWRkcmVzcyhBRE1JTl9BRERSRVNTKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEFkbWluIGFkZHJlc3M6ICR7QURNSU5fQUREUkVTU31gKTtcbiAgICB9XG5cbiAgICBpZiAoIWdldEFkZHJlc3MoRVhBTV9NQU5BR0VNRU5UX0FERFJFU1MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgRXhhbSBNYW5hZ2VtZW50IGNvbnRyYWN0IGFkZHJlc3M6ICR7RVhBTV9NQU5BR0VNRU5UX0FERFJFU1N9YCk7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ0NvbmZpZ3VyYXRpb24gdmFsaWRhdGVkIHN1Y2Nlc3NmdWxseTonLCB7XG4gICAgICBJREVOVElUWV9DT05UUkFDVF9BRERSRVNTLFxuICAgICAgQ0VSVElGSUNBVEVTX0NPTlRSQUNUX0FERFJFU1MsXG4gICAgICBBRE1JTl9BRERSRVNTLFxuICAgICAgRVhBTV9NQU5BR0VNRU5UX0FERFJFU1MsXG4gICAgICBDSEFJTl9JRDogZ2V0Q29uZmlnKCdDSEFJTl9JRCcpLFxuICAgICAgTkVUV09SS19VUkw6IGdldENvbmZpZygnTkVUV09SS19VUkwnKVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignQ29uZmlndXJhdGlvbiB2YWxpZGF0aW9uIGZhaWxlZDonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbi8vIERlYnVnIGVudmlyb25tZW50IHZhcmlhYmxlc1xuY29uc29sZS5sb2coJ0Vudmlyb25tZW50IHZhcmlhYmxlcyBjaGVjazonLCB7XG4gIElERU5USVRZX0NPTlRSQUNUX0FERFJFU1MsXG4gIENFUlRJRklDQVRFU19DT05UUkFDVF9BRERSRVNTLFxuICBBRE1JTl9BRERSRVNTLFxuICBFWEFNX01BTkFHRU1FTlRfQUREUkVTUyxcbiAgQ0hBSU5fSUQ6IEVYUEVDVEVEX05FVFdPUksuY2hhaW5JZCxcbiAgTkVUV09SS19VUkw6IEVYUEVDVEVEX05FVFdPUksucnBjVXJsXG59KTtcblxuLy8gUm9sZSBtYXBwaW5nIHdpdGggcHJvcGVyIHR5cGVzXG5jb25zdCBVU0VSX1JPTEVTID0ge1xuICBOT05FOiAwLFxuICBTVFVERU5UOiAxLFxuICBJTlNUSVRVVElPTjogMixcbiAgRU1QTE9ZRVI6IDMsXG4gIEFETUlOOiA0XG59IGFzIGNvbnN0O1xuXG50eXBlIFJvbGVWYWx1ZSA9IHR5cGVvZiBVU0VSX1JPTEVTW2tleW9mIHR5cGVvZiBVU0VSX1JPTEVTXTtcbnR5cGUgUm9sZVN0cmluZyA9ICdub25lJyB8ICdzdHVkZW50JyB8ICdpbnN0aXR1dGlvbicgfCAnZW1wbG95ZXInIHwgJ2FkbWluJztcblxuY29uc3Qgcm9sZU1hcDogUmVjb3JkPFJvbGVWYWx1ZSwgUm9sZVN0cmluZz4gPSB7XG4gIFtVU0VSX1JPTEVTLk5PTkVdOiAnbm9uZScsXG4gIFtVU0VSX1JPTEVTLlNUVURFTlRdOiAnc3R1ZGVudCcsXG4gIFtVU0VSX1JPTEVTLklOU1RJVFVUSU9OXTogJ2luc3RpdHV0aW9uJyxcbiAgW1VTRVJfUk9MRVMuRU1QTE9ZRVJdOiAnZW1wbG95ZXInLFxuICBbVVNFUl9ST0xFUy5BRE1JTl06ICdhZG1pbidcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRDb250cmFjdHMgPSBhc3luYyAoKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ0NvbnRyYWN0IEFkZHJlc3NlczonLCB7XG4gICAgICBJZGVudGl0eTogSURFTlRJVFlfQ09OVFJBQ1RfQUREUkVTUyxcbiAgICAgIENlcnRpZmljYXRlczogQ0VSVElGSUNBVEVTX0NPTlRSQUNUX0FERFJFU1MsXG4gICAgICBBZG1pbjogQURNSU5fQUREUkVTU1xuICAgIH0pO1xuXG4gICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCBnZXRQcm92aWRlcigpO1xuICAgIGF3YWl0IHZhbGlkYXRlTmV0d29yayhwcm92aWRlcik7XG4gICAgY29uc29sZS5sb2coJ05ldHdvcmsgdmFsaWRhdGlvbiBwYXNzZWQnKTtcbiAgICBcbiAgICBjb25zdCBzaWduZXIgPSBhd2FpdCBnZXRTaWduZXIoKTtcbiAgICBjb25zdCB1c2VyQWRkcmVzcyA9IGF3YWl0IHNpZ25lci5nZXRBZGRyZXNzKCk7XG4gICAgXG4gICAgY29uc29sZS5sb2coJ0Nvbm5lY3RlZCB3aXRoIGFkZHJlc3M6JywgdXNlckFkZHJlc3MpO1xuICAgIFxuICAgIGNvbnN0IHVzZXJCYWxhbmNlID0gYXdhaXQgcHJvdmlkZXIuZ2V0QmFsYW5jZSh1c2VyQWRkcmVzcyk7XG4gICAgY29uc29sZS5sb2coJ1VzZXIgYmFsYW5jZTonLCBmb3JtYXRVbml0cyh1c2VyQmFsYW5jZSwgJ2V0aGVyJyksICdFVEgnKTtcbiAgICBcbiAgICBjb25zdCBpZGVudGl0eUNvbnRyYWN0ID0gbmV3IENvbnRyYWN0KFxuICAgICAgSURFTlRJVFlfQ09OVFJBQ1RfQUREUkVTUyEsXG4gICAgICBJZGVudGl0eUFCSSxcbiAgICAgIHNpZ25lclxuICAgICk7XG5cbiAgICBjb25zb2xlLmxvZygnVmVyaWZ5aW5nIGNvbnRyYWN0IGV4aXN0cyBhdCBhZGRyZXNzOicsIElERU5USVRZX0NPTlRSQUNUX0FERFJFU1MpO1xuICAgIGNvbnN0IGNvZGUgPSBhd2FpdCBwcm92aWRlci5nZXRDb2RlKElERU5USVRZX0NPTlRSQUNUX0FERFJFU1MhKTtcbiAgICBjb25zb2xlLmxvZygnQ29udHJhY3QgY29kZSBsZW5ndGg6JywgY29kZS5sZW5ndGgpO1xuICAgIGNvbnNvbGUubG9nKCdDb250cmFjdCBleGlzdHM6JywgY29kZSAhPT0gJzB4Jyk7XG4gICAgXG4gICAgaWYgKGNvZGUgPT09ICcweCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSWRlbnRpdHkgY29udHJhY3Qgbm90IGZvdW5kIGF0IGFkZHJlc3M6ICR7SURFTlRJVFlfQ09OVFJBQ1RfQUREUkVTU31gKTtcbiAgICB9XG5cbiAgICBjb25zdCBjZXJ0aWZpY2F0ZXNDb250cmFjdCA9IG5ldyBDb250cmFjdChcbiAgICAgIENFUlRJRklDQVRFU19DT05UUkFDVF9BRERSRVNTISxcbiAgICAgIENlcnRpZmljYXRlc0FCSSxcbiAgICAgIHNpZ25lclxuICAgICk7XG5cbiAgICBjb25zdCBleGFtTWFuYWdlbWVudENvbnRyYWN0ID0gbmV3IENvbnRyYWN0KFxuICAgICAgRVhBTV9NQU5BR0VNRU5UX0FERFJFU1MhLFxuICAgICAgRXhhbU1hbmFnZW1lbnRBQkksXG4gICAgICBzaWduZXJcbiAgICApO1xuXG4gICAgcmV0dXJuIHsgaWRlbnRpdHlDb250cmFjdCwgY2VydGlmaWNhdGVzQ29udHJhY3QsIGV4YW1NYW5hZ2VtZW50Q29udHJhY3QsIHByb3ZpZGVyLCBzaWduZXIgfTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluaXRpYWxpemluZyBjb250cmFjdHM6JywgZXJyb3IpO1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRldGFpbHM6Jywge1xuICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgIGNvZGU6IGVycm9yLmNvZGUsXG4gICAgICByZWFzb246IGVycm9yLnJlYXNvblxuICAgIH0pO1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGluaXRpYWxpemUgY29udHJhY3RzOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCByZWdpc3RlclVzZXIgPSBhc3luYyAocm9sZTogc3RyaW5nKSA9PiB7XG4gIGlmICghcm9sZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUm9sZSBpcyByZXF1aXJlZCcpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCB7IGlkZW50aXR5Q29udHJhY3QsIHNpZ25lciB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XG4gICAgXG4gICAgLy8gR2V0IG5ldHdvcmsgZGV0YWlscyBhbmQgdXNlciBhZGRyZXNzXG4gICAgY29uc3QgdXNlckFkZHJlc3MgPSBhd2FpdCBzaWduZXIuZ2V0QWRkcmVzcygpO1xuICAgIGNvbnNvbGUubG9nKCdSZWdpc3RlcmluZyBhZGRyZXNzOicsIHVzZXJBZGRyZXNzKTtcbiAgICBjb25zb2xlLmxvZygnV2l0aCByb2xlOicsIHJvbGUpO1xuICAgIFxuICAgIC8vIFNwZWNpYWwgaGFuZGxpbmcgZm9yIGFkbWluIGFkZHJlc3NcbiAgICBpZiAoQURNSU5fQUREUkVTUyAmJiB1c2VyQWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSBBRE1JTl9BRERSRVNTLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdUaGlzIGlzIHRoZSBhZG1pbiBhZGRyZXNzLCBzZXR0aW5nIGFkbWluIHJvbGUuLi4nKTtcbiAgICAgIHJldHVybiBhd2FpdCBzZXRBZG1pblJvbGUoKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ29udmVydCByb2xlIHN0cmluZyB0byBlbnVtIHZhbHVlXG4gICAgY29uc3Qgcm9sZU1hcDogeyBba2V5OiBzdHJpbmddOiBudW1iZXIgfSA9IHtcbiAgICAgICdzdHVkZW50JzogVVNFUl9ST0xFUy5TVFVERU5ULFxuICAgICAgJ2luc3RpdHV0aW9uJzogVVNFUl9ST0xFUy5JTlNUSVRVVElPTixcbiAgICAgICdlbXBsb3llcic6IFVTRVJfUk9MRVMuRU1QTE9ZRVIsXG4gICAgICAnYWRtaW4nOiBVU0VSX1JPTEVTLkFETUlOXG4gICAgfTtcbiAgICBcbiAgICBjb25zdCByb2xlVmFsdWUgPSByb2xlTWFwW3JvbGUudG9Mb3dlckNhc2UoKV07XG4gICAgaWYgKHJvbGVWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcm9sZTogJHtyb2xlfS4gTXVzdCBiZSBvbmUgb2Y6IHN0dWRlbnQsIGluc3RpdHV0aW9uLCBlbXBsb3llciwgYWRtaW5gKTtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygnUm9sZSB2YWx1ZSBmcm9tIG1hcHBpbmc6Jywgcm9sZVZhbHVlKTtcbiAgICBcbiAgICAvLyBDaGVjayBpZiB1c2VyIGlzIGFscmVhZHkgcmVnaXN0ZXJlZFxuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygnQ2hlY2tpbmcgaWYgdXNlciBhbHJlYWR5IGV4aXN0cy4uLicpO1xuICAgICAgY29uc3QgZXhpc3RpbmdSb2xlID0gYXdhaXQgaWRlbnRpdHlDb250cmFjdC5nZXRVc2VyUm9sZSh1c2VyQWRkcmVzcyk7XG4gICAgICBjb25zb2xlLmxvZygnRXhpc3Rpbmcgcm9sZTonLCBleGlzdGluZ1JvbGUpO1xuICAgICAgXG4gICAgICBpZiAoZXhpc3RpbmdSb2xlID4gMCkge1xuICAgICAgICBjb25zb2xlLmxvZygnVXNlciBhbHJlYWR5IHJlZ2lzdGVyZWQgd2l0aCByb2xlOicsIGV4aXN0aW5nUm9sZSk7XG4gICAgICAgIFxuICAgICAgICAvLyBJZiB1c2VyIGV4aXN0cyBidXQgbmVlZHMgdmVyaWZpY2F0aW9uXG4gICAgICAgIGNvbnN0IGlzVmVyaWZpZWQgPSBhd2FpdCBpZGVudGl0eUNvbnRyYWN0LmlzVmVyaWZpZWQodXNlckFkZHJlc3MpO1xuICAgICAgICBpZiAoIWlzVmVyaWZpZWQpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnVXNlciBleGlzdHMgYnV0IG5vdCB2ZXJpZmllZCwgYXR0ZW1wdGluZyB2ZXJpZmljYXRpb24uLi4nKTtcbiAgICAgICAgICBjb25zdCB2ZXJpZnlUeCA9IGF3YWl0IGlkZW50aXR5Q29udHJhY3QudmVyaWZ5VXNlcih1c2VyQWRkcmVzcyk7XG4gICAgICAgICAgYXdhaXQgdmVyaWZ5VHgud2FpdCgpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdVc2VyIHZlcmlmaWVkIHN1Y2Nlc3NmdWxseScpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4geyBzdGF0dXM6ICdleGlzdGluZycsIHJvbGU6IGV4aXN0aW5nUm9sZSB9O1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGlmICghZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnVXNlciBkb2VzIG5vdCBleGlzdCcpKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgY29uc29sZS5sb2coJ1VzZXIgZG9lcyBub3QgZXhpc3QsIHByb2NlZWRpbmcgd2l0aCByZWdpc3RyYXRpb24nKTtcbiAgICB9XG4gICAgXG4gICAgLy8gUmVnaXN0ZXIgdXNlclxuICAgIGNvbnNvbGUubG9nKCdSZWdpc3RlcmluZyBuZXcgdXNlciB3aXRoIHJvbGU6Jywgcm9sZVZhbHVlKTtcbiAgICBjb25zdCB0eCA9IGF3YWl0IGlkZW50aXR5Q29udHJhY3QucmVnaXN0ZXJVc2VyKHJvbGVWYWx1ZSwgXCJcIik7XG4gICAgY29uc29sZS5sb2coJ1JlZ2lzdHJhdGlvbiB0cmFuc2FjdGlvbiBzZW50OicsIHR4Lmhhc2gpO1xuICAgIFxuICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0eC53YWl0KCk7XG4gICAgY29uc29sZS5sb2coJ1JlZ2lzdHJhdGlvbiBzdWNjZXNzZnVsOicsIHJlY2VpcHQuaGFzaCk7XG4gICAgXG4gICAgLy8gVmVyaWZ5IHRoZSB1c2VyIGF1dG9tYXRpY2FsbHlcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ0F0dGVtcHRpbmcgYXV0b21hdGljIHZlcmlmaWNhdGlvbi4uLicpO1xuICAgICAgY29uc3QgdmVyaWZ5VHggPSBhd2FpdCBpZGVudGl0eUNvbnRyYWN0LnZlcmlmeVVzZXIodXNlckFkZHJlc3MpO1xuICAgICAgYXdhaXQgdmVyaWZ5VHgud2FpdCgpO1xuICAgICAgY29uc29sZS5sb2coJ1VzZXIgdmVyaWZpZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgfSBjYXRjaCAodmVyaWZ5RXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybignQXV0b21hdGljIHZlcmlmaWNhdGlvbiBmYWlsZWQ6JywgdmVyaWZ5RXJyb3IpO1xuICAgICAgLy8gQ29udGludWUgZXZlbiBpZiB2ZXJpZmljYXRpb24gZmFpbHNcbiAgICB9XG4gICAgXG4gICAgLy8gSWYgcmVnaXN0ZXJpbmcgYXMgYWRtaW4sIHNldCBhZG1pbiByb2xlXG4gICAgaWYgKHJvbGUudG9Mb3dlckNhc2UoKSA9PT0gJ2FkbWluJykge1xuICAgICAgY29uc29sZS5sb2coJ1NldHRpbmcgYWRtaW4gcHJpdmlsZWdlcy4uLicpO1xuICAgICAgYXdhaXQgc2V0QWRtaW5Sb2xlKCk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB7IHN0YXR1czogJ3N1Y2Nlc3MnLCByb2xlOiByb2xlVmFsdWUsIHRyYW5zYWN0aW9uOiB0eCB9O1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgcmV0dXJuIGhhbmRsZUNvbnRyYWN0RXJyb3IoZXJyb3IpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgdmVyaWZ5VXNlciA9IGFzeW5jIChhZGRyZXNzOiBzdHJpbmcpID0+IHtcbiAgdHJ5IHtcbiAgICBnZXRBZGRyZXNzKGFkZHJlc3MpOyAvLyBVc2luZyBnZXRBZGRyZXNzIGluc3RlYWQgb2YgaXNBZGRyZXNzXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFkZHJlc3MnKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ1ZlcmlmeWluZyB1c2VyOicsIGFkZHJlc3MpO1xuICAgIGNvbnN0IHsgaWRlbnRpdHlDb250cmFjdCB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XG4gICAgY29uc3QgaXNWZXJpZmllZCA9IGF3YWl0IGlkZW50aXR5Q29udHJhY3QuaXNWZXJpZmllZChhZGRyZXNzKTtcbiAgICBjb25zb2xlLmxvZygnVXNlciB2ZXJpZmljYXRpb24gc3RhdHVzOicsIGlzVmVyaWZpZWQpO1xuICAgIHJldHVybiBpc1ZlcmlmaWVkO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gdmVyaWZ5VXNlcjonLCBlcnJvcik7XG4gICAgcmV0dXJuIGhhbmRsZUNvbnRyYWN0RXJyb3IoZXJyb3IpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0VXNlclJvbGUgPSBhc3luYyAoYWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTxSb2xlU3RyaW5nPiA9PiB7XG4gIHRyeSB7XG4gICAgZ2V0QWRkcmVzcyhhZGRyZXNzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYWRkcmVzcycpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygnR2V0dGluZyB1c2VyIHJvbGUgZm9yOicsIGFkZHJlc3MpO1xuICAgIGNvbnN0IHsgaWRlbnRpdHlDb250cmFjdCB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XG4gICAgY29uc3Qgcm9sZSA9IGF3YWl0IGlkZW50aXR5Q29udHJhY3QuZ2V0VXNlclJvbGUoYWRkcmVzcyk7XG4gICAgY29uc29sZS5sb2coJ1VzZXIgcm9sZTonLCByb2xlKTtcbiAgICByZXR1cm4gcm9sZTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGdldFVzZXJSb2xlOicsIGVycm9yKTtcbiAgICByZXR1cm4gaGFuZGxlQ29udHJhY3RFcnJvcihlcnJvcik7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBpc3N1ZUNlcnRpZmljYXRlID0gYXN5bmMgKHN0dWRlbnRBZGRyZXNzOiBzdHJpbmcsIGlwZnNIYXNoOiBzdHJpbmcpID0+IHtcbiAgaWYgKCFzdHVkZW50QWRkcmVzcyB8fCAhaXBmc0hhc2gpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0dWRlbnQgYWRkcmVzcyBhbmQgSVBGUyBoYXNoIGFyZSByZXF1aXJlZCcpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCB7IGNlcnRpZmljYXRlc0NvbnRyYWN0IH0gPSBhd2FpdCBnZXRDb250cmFjdHMoKTtcbiAgICBjb25zdCB0eCA9IGF3YWl0IGNlcnRpZmljYXRlc0NvbnRyYWN0Lmlzc3VlQ2VydGlmaWNhdGUoc3R1ZGVudEFkZHJlc3MsIGlwZnNIYXNoKTtcbiAgICBhd2FpdCB0eC53YWl0KCk7XG4gICAgcmV0dXJuIHR4O1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaXNzdWluZyBjZXJ0aWZpY2F0ZTonLCBlcnJvcik7XG4gICAgcmV0dXJuIGhhbmRsZUNvbnRyYWN0RXJyb3IoZXJyb3IpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgdmVyaWZ5Q2VydGlmaWNhdGUgPSBhc3luYyAoY2VydGlmaWNhdGVJZDogc3RyaW5nKSA9PiB7XG4gIGlmICghY2VydGlmaWNhdGVJZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2VydGlmaWNhdGUgSUQgaXMgcmVxdWlyZWQnKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgeyBjZXJ0aWZpY2F0ZXNDb250cmFjdCB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XG4gICAgY29uc3QgaXNWYWxpZCA9IGF3YWl0IGNlcnRpZmljYXRlc0NvbnRyYWN0LnZlcmlmeUNlcnRpZmljYXRlKGNlcnRpZmljYXRlSWQpO1xuICAgIHJldHVybiBpc1ZhbGlkO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgdmVyaWZ5aW5nIGNlcnRpZmljYXRlOicsIGVycm9yKTtcbiAgICByZXR1cm4gaGFuZGxlQ29udHJhY3RFcnJvcihlcnJvcik7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBnZXRDZXJ0aWZpY2F0ZXMgPSBhc3luYyAoYWRkcmVzczogc3RyaW5nKSA9PiB7XG4gIHRyeSB7XG4gICAgZ2V0QWRkcmVzcyhhZGRyZXNzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYWRkcmVzcycpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygnR2V0dGluZyBjZXJ0aWZpY2F0ZXMgZm9yOicsIGFkZHJlc3MpO1xuICAgIGNvbnN0IHsgY2VydGlmaWNhdGVzQ29udHJhY3QgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xuICAgIGNvbnN0IGNlcnRpZmljYXRlcyA9IGF3YWl0IGNlcnRpZmljYXRlc0NvbnRyYWN0LmdldENlcnRpZmljYXRlcyhhZGRyZXNzKTtcbiAgICBjb25zb2xlLmxvZygnQ2VydGlmaWNhdGVzOicsIGNlcnRpZmljYXRlcyk7XG4gICAgcmV0dXJuIGNlcnRpZmljYXRlcztcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGdldENlcnRpZmljYXRlczonLCBlcnJvcik7XG4gICAgcmV0dXJuIGhhbmRsZUNvbnRyYWN0RXJyb3IoZXJyb3IpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgaXNWZXJpZmllZFVzZXIgPSBhc3luYyAoYWRkcmVzczogc3RyaW5nKSA9PiB7XG4gIHRyeSB7XG4gICAgZ2V0QWRkcmVzcyhhZGRyZXNzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYWRkcmVzcycpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygnQ2hlY2tpbmcgaWYgdXNlciBpcyB2ZXJpZmllZDonLCBhZGRyZXNzKTtcbiAgICBjb25zdCB7IGlkZW50aXR5Q29udHJhY3QgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xuICAgIGNvbnN0IGlzVmVyaWZpZWQgPSBhd2FpdCBpZGVudGl0eUNvbnRyYWN0LmlzVmVyaWZpZWQoYWRkcmVzcyk7XG4gICAgY29uc29sZS5sb2coJ1VzZXIgdmVyaWZpY2F0aW9uIHN0YXR1czonLCBpc1ZlcmlmaWVkKTtcbiAgICByZXR1cm4gaXNWZXJpZmllZDtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGlzVmVyaWZpZWRVc2VyOicsIGVycm9yKTtcbiAgICByZXR1cm4gaGFuZGxlQ29udHJhY3RFcnJvcihlcnJvcik7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBpc093bmVyID0gYXN5bmMgKGFkZHJlc3M6IHN0cmluZykgPT4ge1xuICB0cnkge1xuICAgIGdldEFkZHJlc3MoYWRkcmVzcyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFkZHJlc3MnKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ0NoZWNraW5nIGlmIHVzZXIgaXMgb3duZXI6JywgYWRkcmVzcyk7XG4gICAgY29uc3QgeyBpZGVudGl0eUNvbnRyYWN0IH0gPSBhd2FpdCBnZXRDb250cmFjdHMoKTtcbiAgICBjb25zdCBvd25lckFkZHJlc3MgPSBhd2FpdCBpZGVudGl0eUNvbnRyYWN0Lm93bmVyKCk7XG4gICAgY29uc3QgaXNPd25lclJvbGUgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IG93bmVyQWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnNvbGUubG9nKCdVc2VyIG93bmVyIHN0YXR1czonLCBpc093bmVyUm9sZSk7XG4gICAgcmV0dXJuIGlzT3duZXJSb2xlO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gaXNPd25lcjonLCBlcnJvcik7XG4gICAgcmV0dXJuIGhhbmRsZUNvbnRyYWN0RXJyb3IoZXJyb3IpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgdmVyaWZ5SW5zdGl0dXRpb24gPSBhc3luYyAoaW5zdGl0dXRpb25BZGRyZXNzOiBzdHJpbmcpID0+IHtcbiAgdHJ5IHtcbiAgICBnZXRBZGRyZXNzKGluc3RpdHV0aW9uQWRkcmVzcyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGluc3RpdHV0aW9uIGFkZHJlc3MnKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ1ZlcmlmeWluZyBpbnN0aXR1dGlvbjonLCBpbnN0aXR1dGlvbkFkZHJlc3MpO1xuICAgIGNvbnN0IHsgaWRlbnRpdHlDb250cmFjdCB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XG4gICAgY29uc3QgdHggPSBhd2FpdCBpZGVudGl0eUNvbnRyYWN0LnZlcmlmeVVzZXIoaW5zdGl0dXRpb25BZGRyZXNzKTtcbiAgICBhd2FpdCB0eC53YWl0KCk7XG4gICAgY29uc29sZS5sb2coJ0luc3RpdHV0aW9uIHZlcmlmaWVkIHN1Y2Nlc3NmdWxseScpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gdmVyaWZ5SW5zdGl0dXRpb246JywgZXJyb3IpO1xuICAgIHJldHVybiBoYW5kbGVDb250cmFjdEVycm9yKGVycm9yKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGdldE93bmVyQWRkcmVzcyA9IGFzeW5jICgpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGlkZW50aXR5Q29udHJhY3QgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xuICAgIGNvbnN0IG93bmVyID0gYXdhaXQgaWRlbnRpdHlDb250cmFjdC5vd25lcigpO1xuICAgIHJldHVybiBvd25lcjtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgb3duZXIgYWRkcmVzczonLCBlcnJvcik7XG4gICAgcmV0dXJuIGhhbmRsZUNvbnRyYWN0RXJyb3IoZXJyb3IpO1xuICB9XG59O1xuXG4vLyBBZGQgZXhhbSBtYW5hZ2VtZW50IGZ1bmN0aW9uc1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUV4YW0gPSBhc3luYyAoXG4gIGlkOiBzdHJpbmcsXG4gIHRpdGxlOiBzdHJpbmcsXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmcsXG4gIGRhdGU6IG51bWJlcixcbiAgZHVyYXRpb246IG51bWJlcixcbiAgaXBmc0hhc2g6IHN0cmluZ1xuKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBleGFtTWFuYWdlbWVudENvbnRyYWN0IH0gPSBhd2FpdCBnZXRDb250cmFjdHMoKTtcbiAgICBjb25zdCB0eCA9IGF3YWl0IGV4YW1NYW5hZ2VtZW50Q29udHJhY3QuY3JlYXRlRXhhbShpZCwgdGl0bGUsIGRlc2NyaXB0aW9uLCBkYXRlLCBkdXJhdGlvbiwgaXBmc0hhc2gpO1xuICAgIGF3YWl0IHR4LndhaXQoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIGV4YW06JywgZXJyb3IpO1xuICAgIHJldHVybiBoYW5kbGVDb250cmFjdEVycm9yKGVycm9yKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHN1Ym1pdEV4YW1SZXN1bHQgPSBhc3luYyAoXG4gIGV4YW1JZDogc3RyaW5nLFxuICBzdHVkZW50OiBzdHJpbmcsXG4gIHNjb3JlOiBudW1iZXIsXG4gIGdyYWRlOiBzdHJpbmcsXG4gIGlwZnNIYXNoOiBzdHJpbmdcbikgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgZXhhbU1hbmFnZW1lbnRDb250cmFjdCB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XG4gICAgY29uc3QgdHggPSBhd2FpdCBleGFtTWFuYWdlbWVudENvbnRyYWN0LnN1Ym1pdEV4YW1SZXN1bHQoZXhhbUlkLCBzdHVkZW50LCBzY29yZSwgZ3JhZGUsIGlwZnNIYXNoKTtcbiAgICBhd2FpdCB0eC53YWl0KCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzdWJtaXR0aW5nIGV4YW0gcmVzdWx0OicsIGVycm9yKTtcbiAgICByZXR1cm4gaGFuZGxlQ29udHJhY3RFcnJvcihlcnJvcik7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCB1cGRhdGVFeGFtU3RhdHVzID0gYXN5bmMgKGV4YW1JZDogc3RyaW5nLCBzdGF0dXM6IHN0cmluZykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgZXhhbU1hbmFnZW1lbnRDb250cmFjdCB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XG4gICAgY29uc3QgdHggPSBhd2FpdCBleGFtTWFuYWdlbWVudENvbnRyYWN0LnVwZGF0ZUV4YW1TdGF0dXMoZXhhbUlkLCBzdGF0dXMpO1xuICAgIGF3YWl0IHR4LndhaXQoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIGV4YW0gc3RhdHVzOicsIGVycm9yKTtcbiAgICByZXR1cm4gaGFuZGxlQ29udHJhY3RFcnJvcihlcnJvcik7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBnZXRFeGFtID0gYXN5bmMgKGV4YW1JZDogc3RyaW5nKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBleGFtTWFuYWdlbWVudENvbnRyYWN0IH0gPSBhd2FpdCBnZXRDb250cmFjdHMoKTtcbiAgICBjb25zdCBleGFtID0gYXdhaXQgZXhhbU1hbmFnZW1lbnRDb250cmFjdC5nZXRFeGFtKGV4YW1JZCk7XG4gICAgcmV0dXJuIGV4YW07XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIGV4YW06JywgZXJyb3IpO1xuICAgIHJldHVybiBoYW5kbGVDb250cmFjdEVycm9yKGVycm9yKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGdldEV4YW1SZXN1bHQgPSBhc3luYyAoZXhhbUlkOiBzdHJpbmcsIHN0dWRlbnQ6IHN0cmluZykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgZXhhbU1hbmFnZW1lbnRDb250cmFjdCB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXhhbU1hbmFnZW1lbnRDb250cmFjdC5nZXRFeGFtUmVzdWx0KGV4YW1JZCwgc3R1ZGVudCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgZXhhbSByZXN1bHQ6JywgZXJyb3IpO1xuICAgIHJldHVybiBoYW5kbGVDb250cmFjdEVycm9yKGVycm9yKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGdldEluc3RpdHV0aW9uRXhhbXMgPSBhc3luYyAoaW5zdGl0dXRpb246IHN0cmluZykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgZXhhbU1hbmFnZW1lbnRDb250cmFjdCB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XG4gICAgY29uc3QgZXhhbXMgPSBhd2FpdCBleGFtTWFuYWdlbWVudENvbnRyYWN0LmdldEluc3RpdHV0aW9uRXhhbXMoaW5zdGl0dXRpb24pO1xuICAgIHJldHVybiBleGFtcztcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgaW5zdGl0dXRpb24gZXhhbXM6JywgZXJyb3IpO1xuICAgIHJldHVybiBoYW5kbGVDb250cmFjdEVycm9yKGVycm9yKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGdldFN0dWRlbnRFeGFtcyA9IGFzeW5jIChzdHVkZW50OiBzdHJpbmcpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGV4YW1NYW5hZ2VtZW50Q29udHJhY3QgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xuICAgIGNvbnN0IGV4YW1zID0gYXdhaXQgZXhhbU1hbmFnZW1lbnRDb250cmFjdC5nZXRTdHVkZW50RXhhbXMoc3R1ZGVudCk7XG4gICAgcmV0dXJuIGV4YW1zO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBzdHVkZW50IGV4YW1zOicsIGVycm9yKTtcbiAgICByZXR1cm4gaGFuZGxlQ29udHJhY3RFcnJvcihlcnJvcik7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBlbnJvbGxTdHVkZW50ID0gYXN5bmMgKGV4YW1JZDogc3RyaW5nLCBzdHVkZW50QWRkcmVzczogc3RyaW5nKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBleGFtTWFuYWdlbWVudENvbnRyYWN0IH0gPSBhd2FpdCBnZXRDb250cmFjdHMoKTtcbiAgICBjb25zdCB0eCA9IGF3YWl0IGV4YW1NYW5hZ2VtZW50Q29udHJhY3QuZW5yb2xsU3R1ZGVudChleGFtSWQsIHN0dWRlbnRBZGRyZXNzKTtcbiAgICBhd2FpdCB0eC53YWl0KCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBlbnJvbGxpbmcgc3R1ZGVudDonLCBlcnJvcik7XG4gICAgcmV0dXJuIGhhbmRsZUNvbnRyYWN0RXJyb3IoZXJyb3IpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0Q29udHJhY3QgPSBhc3luYyAoKSA9PiB7XG4gIGNvbnN0IHsgZXhhbU1hbmFnZW1lbnRDb250cmFjdCB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XG4gIHJldHVybiBleGFtTWFuYWdlbWVudENvbnRyYWN0O1xufTtcblxuZXhwb3J0IGNvbnN0IHNldEFkbWluUm9sZSA9IGFzeW5jICgpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGlkZW50aXR5Q29udHJhY3QsIHNpZ25lciB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XG4gICAgY29uc3QgdXNlckFkZHJlc3MgPSBhd2FpdCBzaWduZXIuZ2V0QWRkcmVzcygpO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKCdTZXR0aW5nIGFkbWluIHJvbGUgZm9yIGFkZHJlc3M6JywgdXNlckFkZHJlc3MpO1xuICAgIGNvbnNvbGUubG9nKCdFeHBlY3RlZCBhZG1pbiBhZGRyZXNzOicsIEFETUlOX0FERFJFU1MpO1xuICAgIFxuICAgIC8vIEZpcnN0IGNoZWNrIGlmIHRoZSBhZGRyZXNzIGlzIGFscmVhZHkgYW4gYWRtaW5cbiAgICBjb25zdCBpc0FkbWluID0gYXdhaXQgaWRlbnRpdHlDb250cmFjdC5pc0FkbWluKHVzZXJBZGRyZXNzKTtcbiAgICBjb25zb2xlLmxvZygnSXMgYWxyZWFkeSBhZG1pbj8nLCBpc0FkbWluKTtcbiAgICBcbiAgICBpZiAoaXNBZG1pbikge1xuICAgICAgY29uc29sZS5sb2coJ1VzZXIgaXMgYWxyZWFkeSBhbiBhZG1pbicpO1xuICAgICAgcmV0dXJuIHsgc3RhdHVzOiAnZXhpc3RpbmcnLCBpc0FkbWluOiB0cnVlIH07XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgdGhlIGNvbmZpZ3VyZWQgYWRtaW4gYWRkcmVzc1xuICAgIGlmIChBRE1JTl9BRERSRVNTICYmIHVzZXJBZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IEFETUlOX0FERFJFU1MudG9Mb3dlckNhc2UoKSkge1xuICAgICAgY29uc29sZS5sb2coJ0FkZHJlc3MgbWF0Y2hlcyBjb25maWd1cmVkIGFkbWluLCBhZGRpbmcgYXMgYWRtaW4uLi4nKTtcbiAgICAgIFxuICAgICAgLy8gRmlyc3QgdHJ5IHRvIHJlZ2lzdGVyIGFzIGFkbWluIGlmIG5vdCBhbHJlYWR5IHJlZ2lzdGVyZWRcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJvbGUgPSBhd2FpdCBpZGVudGl0eUNvbnRyYWN0LmdldFVzZXJSb2xlKHVzZXJBZGRyZXNzKTtcbiAgICAgICAgaWYgKHJvbGUgPT09IDApIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnUmVnaXN0ZXJpbmcgYWRtaW4gdXNlciBmaXJzdC4uLicpO1xuICAgICAgICAgIGNvbnN0IHJlZ1R4ID0gYXdhaXQgaWRlbnRpdHlDb250cmFjdC5yZWdpc3RlclVzZXIoVVNFUl9ST0xFUy5BRE1JTiwgXCJcIik7XG4gICAgICAgICAgYXdhaXQgcmVnVHgud2FpdCgpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgIGlmICghZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnVXNlciBkb2VzIG5vdCBleGlzdCcpKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdXNlciBkb2Vzbid0IGV4aXN0LCByZWdpc3RlciB0aGVtIGFzIGFkbWluXG4gICAgICAgIGNvbnNvbGUubG9nKCdSZWdpc3RlcmluZyBuZXcgYWRtaW4gdXNlci4uLicpO1xuICAgICAgICBjb25zdCByZWdUeCA9IGF3YWl0IGlkZW50aXR5Q29udHJhY3QucmVnaXN0ZXJVc2VyKFVTRVJfUk9MRVMuQURNSU4sIFwiXCIpO1xuICAgICAgICBhd2FpdCByZWdUeC53YWl0KCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFZlcmlmeSB0aGUgdXNlclxuICAgICAgY29uc29sZS5sb2coJ1ZlcmlmeWluZyBhZG1pbiB1c2VyLi4uJyk7XG4gICAgICBjb25zdCB2ZXJpZnlUeCA9IGF3YWl0IGlkZW50aXR5Q29udHJhY3QudmVyaWZ5VXNlcih1c2VyQWRkcmVzcyk7XG4gICAgICBhd2FpdCB2ZXJpZnlUeC53YWl0KCk7XG4gICAgICBcbiAgICAgIC8vIEFkZCBhZG1pbiByb2xlXG4gICAgICBjb25zb2xlLmxvZygnQWRkaW5nIGFkbWluIHJvbGUuLi4nKTtcbiAgICAgIGNvbnN0IHR4ID0gYXdhaXQgaWRlbnRpdHlDb250cmFjdC5hZGRBZG1pbih1c2VyQWRkcmVzcyk7XG4gICAgICBhd2FpdCB0eC53YWl0KCk7XG4gICAgICBjb25zb2xlLmxvZygnU3VjY2Vzc2Z1bGx5IGFkZGVkIGFzIGFkbWluJyk7XG4gICAgICBcbiAgICAgIHJldHVybiB7IHN0YXR1czogJ3N1Y2Nlc3MnLCBpc0FkbWluOiB0cnVlIH07XG4gICAgfVxuICAgIFxuICAgIHRocm93IG5ldyBFcnJvcignT25seSBjb25maWd1cmVkIGFkbWluIGFkZHJlc3NlcyBjYW4gYmUgc2V0IGFzIGFkbWluJyk7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzZXR0aW5nIGFkbWluIHJvbGU6JywgZXJyb3IpO1xuICAgIHJldHVybiBoYW5kbGVDb250cmFjdEVycm9yKGVycm9yKTtcbiAgfVxufTsgIl0sIm5hbWVzIjpbIkNvbnRyYWN0IiwiZm9ybWF0VW5pdHMiLCJnZXRBZGRyZXNzIiwiRXhhbU1hbmFnZW1lbnRBQkkiLCJnZXRQcm92aWRlciIsImdldFNpZ25lciIsIkVYUEVDVEVEX05FVFdPUksiLCJ2YWxpZGF0ZU5ldHdvcmsiLCJoYW5kbGVDb250cmFjdEVycm9yIiwiZ2V0Q29uZmlnIiwidmFsaWRhdGVDb25maWciLCJJZGVudGl0eUFCSSIsIkNlcnRpZmljYXRlc0FCSSIsIklERU5USVRZX0NPTlRSQUNUX0FERFJFU1MiLCJDRVJUSUZJQ0FURVNfQ09OVFJBQ1RfQUREUkVTUyIsIkFETUlOX0FERFJFU1MiLCJFWEFNX01BTkFHRU1FTlRfQUREUkVTUyIsInZhbGlkYXRlRW52IiwiRXJyb3IiLCJjb25zb2xlIiwibG9nIiwiQ0hBSU5fSUQiLCJORVRXT1JLX1VSTCIsImVycm9yIiwiY2hhaW5JZCIsInJwY1VybCIsIlVTRVJfUk9MRVMiLCJOT05FIiwiU1RVREVOVCIsIklOU1RJVFVUSU9OIiwiRU1QTE9ZRVIiLCJBRE1JTiIsInJvbGVNYXAiLCJnZXRDb250cmFjdHMiLCJJZGVudGl0eSIsIkNlcnRpZmljYXRlcyIsIkFkbWluIiwicHJvdmlkZXIiLCJzaWduZXIiLCJ1c2VyQWRkcmVzcyIsInVzZXJCYWxhbmNlIiwiZ2V0QmFsYW5jZSIsImlkZW50aXR5Q29udHJhY3QiLCJjb2RlIiwiZ2V0Q29kZSIsImxlbmd0aCIsImNlcnRpZmljYXRlc0NvbnRyYWN0IiwiZXhhbU1hbmFnZW1lbnRDb250cmFjdCIsIm1lc3NhZ2UiLCJyZWFzb24iLCJyZWdpc3RlclVzZXIiLCJyb2xlIiwidG9Mb3dlckNhc2UiLCJzZXRBZG1pblJvbGUiLCJyb2xlVmFsdWUiLCJ1bmRlZmluZWQiLCJleGlzdGluZ1JvbGUiLCJnZXRVc2VyUm9sZSIsImlzVmVyaWZpZWQiLCJ2ZXJpZnlUeCIsInZlcmlmeVVzZXIiLCJ3YWl0Iiwic3RhdHVzIiwiaW5jbHVkZXMiLCJ0eCIsImhhc2giLCJyZWNlaXB0IiwidmVyaWZ5RXJyb3IiLCJ3YXJuIiwidHJhbnNhY3Rpb24iLCJhZGRyZXNzIiwiaXNzdWVDZXJ0aWZpY2F0ZSIsInN0dWRlbnRBZGRyZXNzIiwiaXBmc0hhc2giLCJ2ZXJpZnlDZXJ0aWZpY2F0ZSIsImNlcnRpZmljYXRlSWQiLCJpc1ZhbGlkIiwiZ2V0Q2VydGlmaWNhdGVzIiwiY2VydGlmaWNhdGVzIiwiaXNWZXJpZmllZFVzZXIiLCJpc093bmVyIiwib3duZXJBZGRyZXNzIiwib3duZXIiLCJpc093bmVyUm9sZSIsInZlcmlmeUluc3RpdHV0aW9uIiwiaW5zdGl0dXRpb25BZGRyZXNzIiwiZ2V0T3duZXJBZGRyZXNzIiwiY3JlYXRlRXhhbSIsImlkIiwidGl0bGUiLCJkZXNjcmlwdGlvbiIsImRhdGUiLCJkdXJhdGlvbiIsInN1Ym1pdEV4YW1SZXN1bHQiLCJleGFtSWQiLCJzdHVkZW50Iiwic2NvcmUiLCJncmFkZSIsInVwZGF0ZUV4YW1TdGF0dXMiLCJnZXRFeGFtIiwiZXhhbSIsImdldEV4YW1SZXN1bHQiLCJyZXN1bHQiLCJnZXRJbnN0aXR1dGlvbkV4YW1zIiwiaW5zdGl0dXRpb24iLCJleGFtcyIsImdldFN0dWRlbnRFeGFtcyIsImVucm9sbFN0dWRlbnQiLCJnZXRDb250cmFjdCIsImlzQWRtaW4iLCJyZWdUeCIsImFkZEFkbWluIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./utilsFront/contracts.ts\n"));

/***/ })

});