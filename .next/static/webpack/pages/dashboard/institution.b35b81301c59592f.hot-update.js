"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/dashboard/institution",{

/***/ "./utils/contracts.ts":
/*!****************************!*\
  !*** ./utils/contracts.ts ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createExam: function() { return /* binding */ createExam; },\n/* harmony export */   enrollStudent: function() { return /* binding */ enrollStudent; },\n/* harmony export */   getCertificates: function() { return /* binding */ getCertificates; },\n/* harmony export */   getContract: function() { return /* binding */ getContract; },\n/* harmony export */   getContracts: function() { return /* binding */ getContracts; },\n/* harmony export */   getExam: function() { return /* binding */ getExam; },\n/* harmony export */   getExamResult: function() { return /* binding */ getExamResult; },\n/* harmony export */   getInstitutionExams: function() { return /* binding */ getInstitutionExams; },\n/* harmony export */   getOwnerAddress: function() { return /* binding */ getOwnerAddress; },\n/* harmony export */   getStudentExams: function() { return /* binding */ getStudentExams; },\n/* harmony export */   getUserRole: function() { return /* binding */ getUserRole; },\n/* harmony export */   isOwner: function() { return /* binding */ isOwner; },\n/* harmony export */   isVerifiedUser: function() { return /* binding */ isVerifiedUser; },\n/* harmony export */   issueCertificate: function() { return /* binding */ issueCertificate; },\n/* harmony export */   registerUser: function() { return /* binding */ registerUser; },\n/* harmony export */   setAdminRole: function() { return /* binding */ setAdminRole; },\n/* harmony export */   submitExamResult: function() { return /* binding */ submitExamResult; },\n/* harmony export */   updateExamStatus: function() { return /* binding */ updateExamStatus; },\n/* harmony export */   validateEnv: function() { return /* binding */ validateEnv; },\n/* harmony export */   verifyCertificate: function() { return /* binding */ verifyCertificate; },\n/* harmony export */   verifyInstitution: function() { return /* binding */ verifyInstitution; },\n/* harmony export */   verifyUser: function() { return /* binding */ verifyUser; }\n/* harmony export */ });\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"./node_modules/.pnpm/ethers@6.13.5_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/ethers/lib.esm/index.js\");\n/* harmony import */ var _constants_abis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/abis */ \"./constants/abis.ts\");\n/* harmony import */ var _ethersConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ethersConfig */ \"./utils/ethersConfig.ts\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./config */ \"./utils/config.ts\");\n\n\n\n\n// Contract ABIs\nconst IdentityABI = [\n    \"function registerUser(uint8 _role, string memory _ipfsHash) external\",\n    \"function verifyUser(address _userAddress) external\",\n    \"function getUserRole(address _userAddress) external view returns (uint8)\",\n    \"function isVerifiedUser(address _userAddress) external view returns (bool)\",\n    \"function updateUserIPFS(string memory _newIpfsHash) external\",\n    \"function owner() external view returns (address)\",\n    \"function isAdmin(address _address) external view returns (bool)\",\n    \"function addAdmin(address _newAdmin) external\",\n    \"function removeAdmin(address _admin) external\"\n];\nconst CertificatesABI = [\n    \"function issueCertificate(address _studentAddress, string memory _ipfsHash) external returns (bytes32)\",\n    \"function getStudentCertificates(address _student) external view returns (bytes32[])\",\n    \"function verifyCertificate(bytes32 _certificateId) external view returns (address student, address institution, string ipfsHash, uint256 issuedAt, bool isValid)\"\n];\n// Contract addresses from config\nconst IDENTITY_CONTRACT_ADDRESS = (0,_config__WEBPACK_IMPORTED_MODULE_2__.getConfig)(\"IDENTITY_CONTRACT_ADDRESS\");\nconst CERTIFICATES_CONTRACT_ADDRESS = (0,_config__WEBPACK_IMPORTED_MODULE_2__.getConfig)(\"CERTIFICATES_CONTRACT_ADDRESS\");\nconst ADMIN_ADDRESS = (0,_config__WEBPACK_IMPORTED_MODULE_2__.getConfig)(\"ADMIN_ADDRESS\");\nconst EXAM_MANAGEMENT_ADDRESS = (0,_config__WEBPACK_IMPORTED_MODULE_2__.getConfig)(\"EXAM_MANAGEMENT_CONTRACT_ADDRESS\");\n// Validate environment variables\nconst validateEnv = ()=>{\n    try {\n        // التحقق من صحة التكوين\n        (0,_config__WEBPACK_IMPORTED_MODULE_2__.validateConfig)();\n        // التحقق من صحة العناوين\n        if (!(0,ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress)(IDENTITY_CONTRACT_ADDRESS)) {\n            throw new Error(\"Invalid Identity contract address: \".concat(IDENTITY_CONTRACT_ADDRESS));\n        }\n        if (!(0,ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress)(CERTIFICATES_CONTRACT_ADDRESS)) {\n            throw new Error(\"Invalid Certificates contract address: \".concat(CERTIFICATES_CONTRACT_ADDRESS));\n        }\n        if (!(0,ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress)(ADMIN_ADDRESS)) {\n            throw new Error(\"Invalid Admin address: \".concat(ADMIN_ADDRESS));\n        }\n        if (!(0,ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress)(EXAM_MANAGEMENT_ADDRESS)) {\n            throw new Error(\"Invalid Exam Management contract address: \".concat(EXAM_MANAGEMENT_ADDRESS));\n        }\n        console.log(\"Configuration validated successfully:\", {\n            IDENTITY_CONTRACT_ADDRESS,\n            CERTIFICATES_CONTRACT_ADDRESS,\n            ADMIN_ADDRESS,\n            EXAM_MANAGEMENT_ADDRESS,\n            CHAIN_ID: (0,_config__WEBPACK_IMPORTED_MODULE_2__.getConfig)(\"CHAIN_ID\"),\n            NETWORK_URL: (0,_config__WEBPACK_IMPORTED_MODULE_2__.getConfig)(\"NETWORK_URL\")\n        });\n        return true;\n    } catch (error) {\n        console.error(\"Configuration validation failed:\", error);\n        throw error;\n    }\n};\n// Debug environment variables\nconsole.log(\"Environment variables check:\", {\n    IDENTITY_CONTRACT_ADDRESS,\n    CERTIFICATES_CONTRACT_ADDRESS,\n    ADMIN_ADDRESS,\n    EXAM_MANAGEMENT_ADDRESS,\n    CHAIN_ID: _ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.chainId,\n    NETWORK_URL: _ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl\n});\n// Role mapping with proper types\nconst USER_ROLES = {\n    NONE: 0,\n    STUDENT: 1,\n    INSTITUTION: 2,\n    EMPLOYER: 3,\n    ADMIN: 4\n};\nconst roleMap = {\n    [USER_ROLES.NONE]: \"none\",\n    [USER_ROLES.STUDENT]: \"student\",\n    [USER_ROLES.INSTITUTION]: \"institution\",\n    [USER_ROLES.EMPLOYER]: \"employer\",\n    [USER_ROLES.ADMIN]: \"admin\"\n};\nconst getContracts = async ()=>{\n    try {\n        console.log(\"Contract Addresses:\", {\n            Identity: IDENTITY_CONTRACT_ADDRESS,\n            Certificates: CERTIFICATES_CONTRACT_ADDRESS,\n            Admin: ADMIN_ADDRESS\n        });\n        const provider = await (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getProvider)();\n        await (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.validateNetwork)(provider);\n        console.log(\"Network validation passed\");\n        const signer = await (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getSigner)();\n        const userAddress = await signer.getAddress();\n        console.log(\"Connected with address:\", userAddress);\n        const userBalance = await provider.getBalance(userAddress);\n        console.log(\"User balance:\", (0,ethers__WEBPACK_IMPORTED_MODULE_3__.formatUnits)(userBalance, \"ether\"), \"ETH\");\n        const identityContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.Contract(IDENTITY_CONTRACT_ADDRESS, IdentityABI, signer);\n        console.log(\"Verifying contract exists at address:\", IDENTITY_CONTRACT_ADDRESS);\n        const code = await provider.getCode(IDENTITY_CONTRACT_ADDRESS);\n        console.log(\"Contract code length:\", code.length);\n        console.log(\"Contract exists:\", code !== \"0x\");\n        if (code === \"0x\") {\n            throw new Error(\"Identity contract not found at address: \".concat(IDENTITY_CONTRACT_ADDRESS));\n        }\n        const certificatesContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.Contract(CERTIFICATES_CONTRACT_ADDRESS, CertificatesABI, signer);\n        const examManagementContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.Contract(EXAM_MANAGEMENT_ADDRESS, _constants_abis__WEBPACK_IMPORTED_MODULE_0__.ExamManagementABI, signer);\n        return {\n            identityContract,\n            certificatesContract,\n            examManagementContract,\n            provider,\n            signer\n        };\n    } catch (error) {\n        console.error(\"Error initializing contracts:\", error);\n        console.error(\"Error details:\", {\n            message: error.message,\n            code: error.code,\n            reason: error.reason\n        });\n        throw new Error(\"Failed to initialize contracts: \".concat(error.message));\n    }\n};\nconst registerUser = async (role)=>{\n    if (!role) {\n        throw new Error(\"Role is required\");\n    }\n    try {\n        const { identityContract, signer } = await getContracts();\n        // Get network details and user address\n        const userAddress = await signer.getAddress();\n        console.log(\"Registering address:\", userAddress);\n        console.log(\"With role:\", role);\n        // Special handling for admin address\n        if (ADMIN_ADDRESS && userAddress.toLowerCase() === ADMIN_ADDRESS.toLowerCase()) {\n            console.log(\"This is the admin address, setting admin role...\");\n            return await setAdminRole();\n        }\n        // Convert role string to enum value\n        const roleMap = {\n            \"student\": USER_ROLES.STUDENT,\n            \"institution\": USER_ROLES.INSTITUTION,\n            \"employer\": USER_ROLES.EMPLOYER,\n            \"admin\": USER_ROLES.ADMIN\n        };\n        const roleValue = roleMap[role.toLowerCase()];\n        if (roleValue === undefined) {\n            throw new Error(\"Invalid role: \".concat(role, \". Must be one of: student, institution, employer, admin\"));\n        }\n        console.log(\"Role value from mapping:\", roleValue);\n        // Check if user is already registered\n        try {\n            console.log(\"Checking if user already exists...\");\n            const existingRole = await identityContract.getUserRole(userAddress);\n            console.log(\"Existing role:\", existingRole);\n            if (existingRole > 0) {\n                console.log(\"User already registered with role:\", existingRole);\n                // If user exists but needs verification\n                const isVerified = await identityContract.isVerified(userAddress);\n                if (!isVerified) {\n                    console.log(\"User exists but not verified, attempting verification...\");\n                    const verifyTx = await identityContract.verifyUser(userAddress);\n                    await verifyTx.wait();\n                    console.log(\"User verified successfully\");\n                }\n                return {\n                    status: \"existing\",\n                    role: existingRole\n                };\n            }\n        } catch (error) {\n            if (!error.message.includes(\"User does not exist\")) {\n                throw error;\n            }\n            console.log(\"User does not exist, proceeding with registration\");\n        }\n        // Register user\n        console.log(\"Registering new user with role:\", roleValue);\n        const tx = await identityContract.registerUser(roleValue, \"\");\n        console.log(\"Registration transaction sent:\", tx.hash);\n        const receipt = await tx.wait();\n        console.log(\"Registration successful:\", receipt.hash);\n        // Verify the user automatically\n        try {\n            console.log(\"Attempting automatic verification...\");\n            const verifyTx = await identityContract.verifyUser(userAddress);\n            await verifyTx.wait();\n            console.log(\"User verified successfully\");\n        } catch (verifyError) {\n            console.warn(\"Automatic verification failed:\", verifyError);\n        // Continue even if verification fails\n        }\n        // If registering as admin, set admin role\n        if (role.toLowerCase() === \"admin\") {\n            console.log(\"Setting admin privileges...\");\n            await setAdminRole();\n        }\n        return {\n            status: \"success\",\n            role: roleValue,\n            transaction: tx\n        };\n    } catch (error) {\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst verifyUser = async (address)=>{\n    try {\n        (0,ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress)(address); // Using getAddress instead of isAddress\n    } catch (error) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        console.log(\"Verifying user:\", address);\n        const { identityContract } = await getContracts();\n        const isVerified = await identityContract.isVerified(address);\n        console.log(\"User verification status:\", isVerified);\n        return isVerified;\n    } catch (error) {\n        console.error(\"Error in verifyUser:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst getUserRole = async (address)=>{\n    try {\n        (0,ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress)(address);\n    } catch (error) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        console.log(\"Getting user role for:\", address);\n        const { identityContract } = await getContracts();\n        const role = await identityContract.getUserRole(address);\n        console.log(\"User role:\", role);\n        return role;\n    } catch (error) {\n        console.error(\"Error in getUserRole:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst issueCertificate = async (studentAddress, ipfsHash)=>{\n    if (!studentAddress || !ipfsHash) {\n        throw new Error(\"Student address and IPFS hash are required\");\n    }\n    try {\n        const { certificatesContract } = await getContracts();\n        const tx = await certificatesContract.issueCertificate(studentAddress, ipfsHash);\n        await tx.wait();\n        return tx;\n    } catch (error) {\n        console.error(\"Error issuing certificate:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst verifyCertificate = async (certificateId)=>{\n    if (!certificateId) {\n        throw new Error(\"Certificate ID is required\");\n    }\n    try {\n        const { certificatesContract } = await getContracts();\n        const isValid = await certificatesContract.verifyCertificate(certificateId);\n        return isValid;\n    } catch (error) {\n        console.error(\"Error verifying certificate:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst getCertificates = async (address)=>{\n    try {\n        (0,ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress)(address);\n    } catch (error) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        console.log(\"Getting certificates for:\", address);\n        const { certificatesContract } = await getContracts();\n        const certificates = await certificatesContract.getCertificates(address);\n        console.log(\"Certificates:\", certificates);\n        return certificates;\n    } catch (error) {\n        console.error(\"Error in getCertificates:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst isVerifiedUser = async (address)=>{\n    try {\n        (0,ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress)(address);\n    } catch (error) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        console.log(\"Checking if user is verified:\", address);\n        const { identityContract } = await getContracts();\n        const isVerified = await identityContract.isVerified(address);\n        console.log(\"User verification status:\", isVerified);\n        return isVerified;\n    } catch (error) {\n        console.error(\"Error in isVerifiedUser:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst isOwner = async (address)=>{\n    try {\n        (0,ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress)(address);\n    } catch (error) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        console.log(\"Checking if user is owner:\", address);\n        const { identityContract } = await getContracts();\n        const ownerAddress = await identityContract.owner();\n        const isOwnerRole = address.toLowerCase() === ownerAddress.toLowerCase();\n        console.log(\"User owner status:\", isOwnerRole);\n        return isOwnerRole;\n    } catch (error) {\n        console.error(\"Error in isOwner:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst verifyInstitution = async (institutionAddress)=>{\n    try {\n        (0,ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress)(institutionAddress);\n    } catch (error) {\n        throw new Error(\"Invalid institution address\");\n    }\n    try {\n        console.log(\"Verifying institution:\", institutionAddress);\n        const { identityContract } = await getContracts();\n        const tx = await identityContract.verifyUser(institutionAddress);\n        await tx.wait();\n        console.log(\"Institution verified successfully\");\n        return true;\n    } catch (error) {\n        console.error(\"Error in verifyInstitution:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst getOwnerAddress = async ()=>{\n    try {\n        const { identityContract } = await getContracts();\n        const owner = await identityContract.owner();\n        return owner;\n    } catch (error) {\n        console.error(\"Error getting owner address:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\n// Add exam management functions\nconst createExam = async (id, title, description, date, duration, ipfsHash)=>{\n    try {\n        const { examManagementContract } = await getContracts();\n        const tx = await examManagementContract.createExam(id, title, description, date, duration, ipfsHash);\n        await tx.wait();\n        return true;\n    } catch (error) {\n        console.error(\"Error creating exam:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst submitExamResult = async (examId, student, score, grade, ipfsHash)=>{\n    try {\n        const { examManagementContract } = await getContracts();\n        const tx = await examManagementContract.submitExamResult(examId, student, score, grade, ipfsHash);\n        await tx.wait();\n        return true;\n    } catch (error) {\n        console.error(\"Error submitting exam result:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst updateExamStatus = async (examId, status)=>{\n    try {\n        const { examManagementContract } = await getContracts();\n        const tx = await examManagementContract.updateExamStatus(examId, status);\n        await tx.wait();\n        return true;\n    } catch (error) {\n        console.error(\"Error updating exam status:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst getExam = async (examId)=>{\n    try {\n        const { examManagementContract } = await getContracts();\n        const exam = await examManagementContract.getExam(examId);\n        return exam;\n    } catch (error) {\n        console.error(\"Error getting exam:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst getExamResult = async (examId, student)=>{\n    try {\n        const { examManagementContract } = await getContracts();\n        const result = await examManagementContract.getExamResult(examId, student);\n        return result;\n    } catch (error) {\n        console.error(\"Error getting exam result:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst getInstitutionExams = async (institution)=>{\n    try {\n        const { examManagementContract } = await getContracts();\n        const exams = await examManagementContract.getInstitutionExams(institution);\n        return exams;\n    } catch (error) {\n        console.error(\"Error getting institution exams:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst getStudentExams = async (student)=>{\n    try {\n        const { examManagementContract } = await getContracts();\n        const exams = await examManagementContract.getStudentExams(student);\n        return exams;\n    } catch (error) {\n        console.error(\"Error getting student exams:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst enrollStudent = async (examId, studentAddress)=>{\n    try {\n        const { examManagementContract } = await getContracts();\n        const tx = await examManagementContract.enrollStudent(examId, studentAddress);\n        await tx.wait();\n        return true;\n    } catch (error) {\n        console.error(\"Error enrolling student:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\nconst getContract = async ()=>{\n    const { examManagementContract } = await getContracts();\n    return examManagementContract;\n};\nconst setAdminRole = async ()=>{\n    try {\n        const { identityContract, signer } = await getContracts();\n        const userAddress = await signer.getAddress();\n        console.log(\"Setting admin role for address:\", userAddress);\n        console.log(\"Expected admin address:\", ADMIN_ADDRESS);\n        // First check if the address is already an admin\n        const isAdmin = await identityContract.isAdmin(userAddress);\n        console.log(\"Is already admin?\", isAdmin);\n        if (isAdmin) {\n            console.log(\"User is already an admin\");\n            return {\n                status: \"existing\",\n                isAdmin: true\n            };\n        }\n        // Check if this is the configured admin address\n        if (ADMIN_ADDRESS && userAddress.toLowerCase() === ADMIN_ADDRESS.toLowerCase()) {\n            console.log(\"Address matches configured admin, adding as admin...\");\n            // First try to register as admin if not already registered\n            try {\n                const role = await identityContract.getUserRole(userAddress);\n                if (role === 0) {\n                    console.log(\"Registering admin user first...\");\n                    const regTx = await identityContract.registerUser(USER_ROLES.ADMIN, \"\");\n                    await regTx.wait();\n                }\n            } catch (error) {\n                if (!error.message.includes(\"User does not exist\")) {\n                    throw error;\n                }\n                // If user doesn't exist, register them as admin\n                console.log(\"Registering new admin user...\");\n                const regTx = await identityContract.registerUser(USER_ROLES.ADMIN, \"\");\n                await regTx.wait();\n            }\n            // Verify the user\n            console.log(\"Verifying admin user...\");\n            const verifyTx = await identityContract.verifyUser(userAddress);\n            await verifyTx.wait();\n            // Add admin role\n            console.log(\"Adding admin role...\");\n            const tx = await identityContract.addAdmin(userAddress);\n            await tx.wait();\n            console.log(\"Successfully added as admin\");\n            return {\n                status: \"success\",\n                isAdmin: true\n            };\n        }\n        throw new Error(\"Only configured admin addresses can be set as admin\");\n    } catch (error) {\n        console.error(\"Error setting admin role:\", error);\n        return (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.handleContractError)(error);\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi91dGlscy9jb250cmFjdHMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFJZ0I7QUFDc0M7QUFROUI7QUFFNkI7QUFFckQsZ0JBQWdCO0FBQ2hCLE1BQU1XLGNBQWM7SUFDbEI7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0Q7QUFFRCxNQUFNQyxrQkFBa0I7SUFDdEI7SUFDQTtJQUNBO0NBQ0Q7QUFFRCxpQ0FBaUM7QUFDakMsTUFBTUMsNEJBQTRCSixrREFBU0EsQ0FBQztBQUM1QyxNQUFNSyxnQ0FBZ0NMLGtEQUFTQSxDQUFDO0FBQ2hELE1BQU1NLGdCQUFnQk4sa0RBQVNBLENBQUM7QUFDaEMsTUFBTU8sMEJBQTBCUCxrREFBU0EsQ0FBQztBQUUxQyxpQ0FBaUM7QUFDMUIsTUFBTVEsY0FBYztJQUN6QixJQUFJO1FBQ0Ysd0JBQXdCO1FBQ3hCUCx1REFBY0E7UUFFZCx5QkFBeUI7UUFDekIsSUFBSSxDQUFDUixrREFBVUEsQ0FBQ1csNEJBQTRCO1lBQzFDLE1BQU0sSUFBSUssTUFBTSxzQ0FBZ0UsT0FBMUJMO1FBQ3hEO1FBRUEsSUFBSSxDQUFDWCxrREFBVUEsQ0FBQ1ksZ0NBQWdDO1lBQzlDLE1BQU0sSUFBSUksTUFBTSwwQ0FBd0UsT0FBOUJKO1FBQzVEO1FBRUEsSUFBSSxDQUFDWixrREFBVUEsQ0FBQ2EsZ0JBQWdCO1lBQzlCLE1BQU0sSUFBSUcsTUFBTSwwQkFBd0MsT0FBZEg7UUFDNUM7UUFFQSxJQUFJLENBQUNiLGtEQUFVQSxDQUFDYywwQkFBMEI7WUFDeEMsTUFBTSxJQUFJRSxNQUFNLDZDQUFxRSxPQUF4QkY7UUFDL0Q7UUFFQUcsUUFBUUMsR0FBRyxDQUFDLHlDQUF5QztZQUNuRFA7WUFDQUM7WUFDQUM7WUFDQUM7WUFDQUssVUFBVVosa0RBQVNBLENBQUM7WUFDcEJhLGFBQWFiLGtEQUFTQSxDQUFDO1FBQ3pCO1FBRUEsT0FBTztJQUNULEVBQUUsT0FBT2MsT0FBTztRQUNkSixRQUFRSSxLQUFLLENBQUMsb0NBQW9DQTtRQUNsRCxNQUFNQTtJQUNSO0FBQ0YsRUFBRTtBQUVGLDhCQUE4QjtBQUM5QkosUUFBUUMsR0FBRyxDQUFDLGdDQUFnQztJQUMxQ1A7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUssVUFBVWYsMkRBQWdCQSxDQUFDa0IsT0FBTztJQUNsQ0YsYUFBYWhCLDJEQUFnQkEsQ0FBQ21CLE1BQU07QUFDdEM7QUFFQSxpQ0FBaUM7QUFDakMsTUFBTUMsYUFBYTtJQUNqQkMsTUFBTTtJQUNOQyxTQUFTO0lBQ1RDLGFBQWE7SUFDYkMsVUFBVTtJQUNWQyxPQUFPO0FBQ1Q7QUFLQSxNQUFNQyxVQUF5QztJQUM3QyxDQUFDTixXQUFXQyxJQUFJLENBQUMsRUFBRTtJQUNuQixDQUFDRCxXQUFXRSxPQUFPLENBQUMsRUFBRTtJQUN0QixDQUFDRixXQUFXRyxXQUFXLENBQUMsRUFBRTtJQUMxQixDQUFDSCxXQUFXSSxRQUFRLENBQUMsRUFBRTtJQUN2QixDQUFDSixXQUFXSyxLQUFLLENBQUMsRUFBRTtBQUN0QjtBQUVPLE1BQU1FLGVBQWU7SUFDMUIsSUFBSTtRQUNGZCxRQUFRQyxHQUFHLENBQUMsdUJBQXVCO1lBQ2pDYyxVQUFVckI7WUFDVnNCLGNBQWNyQjtZQUNkc0IsT0FBT3JCO1FBQ1Q7UUFFQSxNQUFNc0IsV0FBVyxNQUFNakMsMERBQVdBO1FBQ2xDLE1BQU1HLDhEQUFlQSxDQUFDOEI7UUFDdEJsQixRQUFRQyxHQUFHLENBQUM7UUFFWixNQUFNa0IsU0FBUyxNQUFNakMsd0RBQVNBO1FBQzlCLE1BQU1rQyxjQUFjLE1BQU1ELE9BQU9wQyxVQUFVO1FBRTNDaUIsUUFBUUMsR0FBRyxDQUFDLDJCQUEyQm1CO1FBRXZDLE1BQU1DLGNBQWMsTUFBTUgsU0FBU0ksVUFBVSxDQUFDRjtRQUM5Q3BCLFFBQVFDLEdBQUcsQ0FBQyxpQkFBaUJuQixtREFBV0EsQ0FBQ3VDLGFBQWEsVUFBVTtRQUVoRSxNQUFNRSxtQkFBbUIsSUFBSTFDLDRDQUFRQSxDQUNuQ2EsMkJBQ0FGLGFBQ0EyQjtRQUdGbkIsUUFBUUMsR0FBRyxDQUFDLHlDQUF5Q1A7UUFDckQsTUFBTThCLE9BQU8sTUFBTU4sU0FBU08sT0FBTyxDQUFDL0I7UUFDcENNLFFBQVFDLEdBQUcsQ0FBQyx5QkFBeUJ1QixLQUFLRSxNQUFNO1FBQ2hEMUIsUUFBUUMsR0FBRyxDQUFDLG9CQUFvQnVCLFNBQVM7UUFFekMsSUFBSUEsU0FBUyxNQUFNO1lBQ2pCLE1BQU0sSUFBSXpCLE1BQU0sMkNBQXFFLE9BQTFCTDtRQUM3RDtRQUVBLE1BQU1pQyx1QkFBdUIsSUFBSTlDLDRDQUFRQSxDQUN2Q2MsK0JBQ0FGLGlCQUNBMEI7UUFHRixNQUFNUyx5QkFBeUIsSUFBSS9DLDRDQUFRQSxDQUN6Q2dCLHlCQUNBYiw4REFBaUJBLEVBQ2pCbUM7UUFHRixPQUFPO1lBQUVJO1lBQWtCSTtZQUFzQkM7WUFBd0JWO1lBQVVDO1FBQU87SUFDNUYsRUFBRSxPQUFPZixPQUFZO1FBQ25CSixRQUFRSSxLQUFLLENBQUMsaUNBQWlDQTtRQUMvQ0osUUFBUUksS0FBSyxDQUFDLGtCQUFrQjtZQUM5QnlCLFNBQVN6QixNQUFNeUIsT0FBTztZQUN0QkwsTUFBTXBCLE1BQU1vQixJQUFJO1lBQ2hCTSxRQUFRMUIsTUFBTTBCLE1BQU07UUFDdEI7UUFDQSxNQUFNLElBQUkvQixNQUFNLG1DQUFpRCxPQUFkSyxNQUFNeUIsT0FBTztJQUNsRTtBQUNGLEVBQUU7QUFFSyxNQUFNRSxlQUFlLE9BQU9DO0lBQ2pDLElBQUksQ0FBQ0EsTUFBTTtRQUNULE1BQU0sSUFBSWpDLE1BQU07SUFDbEI7SUFFQSxJQUFJO1FBQ0YsTUFBTSxFQUFFd0IsZ0JBQWdCLEVBQUVKLE1BQU0sRUFBRSxHQUFHLE1BQU1MO1FBRTNDLHVDQUF1QztRQUN2QyxNQUFNTSxjQUFjLE1BQU1ELE9BQU9wQyxVQUFVO1FBQzNDaUIsUUFBUUMsR0FBRyxDQUFDLHdCQUF3Qm1CO1FBQ3BDcEIsUUFBUUMsR0FBRyxDQUFDLGNBQWMrQjtRQUUxQixxQ0FBcUM7UUFDckMsSUFBSXBDLGlCQUFpQndCLFlBQVlhLFdBQVcsT0FBT3JDLGNBQWNxQyxXQUFXLElBQUk7WUFDOUVqQyxRQUFRQyxHQUFHLENBQUM7WUFDWixPQUFPLE1BQU1pQztRQUNmO1FBRUEsb0NBQW9DO1FBQ3BDLE1BQU1yQixVQUFxQztZQUN6QyxXQUFXTixXQUFXRSxPQUFPO1lBQzdCLGVBQWVGLFdBQVdHLFdBQVc7WUFDckMsWUFBWUgsV0FBV0ksUUFBUTtZQUMvQixTQUFTSixXQUFXSyxLQUFLO1FBQzNCO1FBRUEsTUFBTXVCLFlBQVl0QixPQUFPLENBQUNtQixLQUFLQyxXQUFXLEdBQUc7UUFDN0MsSUFBSUUsY0FBY0MsV0FBVztZQUMzQixNQUFNLElBQUlyQyxNQUFNLGlCQUFzQixPQUFMaUMsTUFBSztRQUN4QztRQUVBaEMsUUFBUUMsR0FBRyxDQUFDLDRCQUE0QmtDO1FBRXhDLHNDQUFzQztRQUN0QyxJQUFJO1lBQ0ZuQyxRQUFRQyxHQUFHLENBQUM7WUFDWixNQUFNb0MsZUFBZSxNQUFNZCxpQkFBaUJlLFdBQVcsQ0FBQ2xCO1lBQ3hEcEIsUUFBUUMsR0FBRyxDQUFDLGtCQUFrQm9DO1lBRTlCLElBQUlBLGVBQWUsR0FBRztnQkFDcEJyQyxRQUFRQyxHQUFHLENBQUMsc0NBQXNDb0M7Z0JBRWxELHdDQUF3QztnQkFDeEMsTUFBTUUsYUFBYSxNQUFNaEIsaUJBQWlCZ0IsVUFBVSxDQUFDbkI7Z0JBQ3JELElBQUksQ0FBQ21CLFlBQVk7b0JBQ2Z2QyxRQUFRQyxHQUFHLENBQUM7b0JBQ1osTUFBTXVDLFdBQVcsTUFBTWpCLGlCQUFpQmtCLFVBQVUsQ0FBQ3JCO29CQUNuRCxNQUFNb0IsU0FBU0UsSUFBSTtvQkFDbkIxQyxRQUFRQyxHQUFHLENBQUM7Z0JBQ2Q7Z0JBRUEsT0FBTztvQkFBRTBDLFFBQVE7b0JBQVlYLE1BQU1LO2dCQUFhO1lBQ2xEO1FBQ0YsRUFBRSxPQUFPakMsT0FBWTtZQUNuQixJQUFJLENBQUNBLE1BQU15QixPQUFPLENBQUNlLFFBQVEsQ0FBQyx3QkFBd0I7Z0JBQ2xELE1BQU14QztZQUNSO1lBQ0FKLFFBQVFDLEdBQUcsQ0FBQztRQUNkO1FBRUEsZ0JBQWdCO1FBQ2hCRCxRQUFRQyxHQUFHLENBQUMsbUNBQW1Da0M7UUFDL0MsTUFBTVUsS0FBSyxNQUFNdEIsaUJBQWlCUSxZQUFZLENBQUNJLFdBQVc7UUFDMURuQyxRQUFRQyxHQUFHLENBQUMsa0NBQWtDNEMsR0FBR0MsSUFBSTtRQUVyRCxNQUFNQyxVQUFVLE1BQU1GLEdBQUdILElBQUk7UUFDN0IxQyxRQUFRQyxHQUFHLENBQUMsNEJBQTRCOEMsUUFBUUQsSUFBSTtRQUVwRCxnQ0FBZ0M7UUFDaEMsSUFBSTtZQUNGOUMsUUFBUUMsR0FBRyxDQUFDO1lBQ1osTUFBTXVDLFdBQVcsTUFBTWpCLGlCQUFpQmtCLFVBQVUsQ0FBQ3JCO1lBQ25ELE1BQU1vQixTQUFTRSxJQUFJO1lBQ25CMUMsUUFBUUMsR0FBRyxDQUFDO1FBQ2QsRUFBRSxPQUFPK0MsYUFBYTtZQUNwQmhELFFBQVFpRCxJQUFJLENBQUMsa0NBQWtDRDtRQUMvQyxzQ0FBc0M7UUFDeEM7UUFFQSwwQ0FBMEM7UUFDMUMsSUFBSWhCLEtBQUtDLFdBQVcsT0FBTyxTQUFTO1lBQ2xDakMsUUFBUUMsR0FBRyxDQUFDO1lBQ1osTUFBTWlDO1FBQ1I7UUFFQSxPQUFPO1lBQUVTLFFBQVE7WUFBV1gsTUFBTUc7WUFBV2UsYUFBYUw7UUFBRztJQUMvRCxFQUFFLE9BQU96QyxPQUFZO1FBQ25CLE9BQU9mLGtFQUFtQkEsQ0FBQ2U7SUFDN0I7QUFDRixFQUFFO0FBRUssTUFBTXFDLGFBQWEsT0FBT1U7SUFDL0IsSUFBSTtRQUNGcEUsa0RBQVVBLENBQUNvRSxVQUFVLHdDQUF3QztJQUMvRCxFQUFFLE9BQU8vQyxPQUFPO1FBQ2QsTUFBTSxJQUFJTCxNQUFNO0lBQ2xCO0lBRUEsSUFBSTtRQUNGQyxRQUFRQyxHQUFHLENBQUMsbUJBQW1Ca0Q7UUFDL0IsTUFBTSxFQUFFNUIsZ0JBQWdCLEVBQUUsR0FBRyxNQUFNVDtRQUNuQyxNQUFNeUIsYUFBYSxNQUFNaEIsaUJBQWlCZ0IsVUFBVSxDQUFDWTtRQUNyRG5ELFFBQVFDLEdBQUcsQ0FBQyw2QkFBNkJzQztRQUN6QyxPQUFPQTtJQUNULEVBQUUsT0FBT25DLE9BQVk7UUFDbkJKLFFBQVFJLEtBQUssQ0FBQyx3QkFBd0JBO1FBQ3RDLE9BQU9mLGtFQUFtQkEsQ0FBQ2U7SUFDN0I7QUFDRixFQUFFO0FBRUssTUFBTWtDLGNBQWMsT0FBT2E7SUFDaEMsSUFBSTtRQUNGcEUsa0RBQVVBLENBQUNvRTtJQUNiLEVBQUUsT0FBTy9DLE9BQU87UUFDZCxNQUFNLElBQUlMLE1BQU07SUFDbEI7SUFFQSxJQUFJO1FBQ0ZDLFFBQVFDLEdBQUcsQ0FBQywwQkFBMEJrRDtRQUN0QyxNQUFNLEVBQUU1QixnQkFBZ0IsRUFBRSxHQUFHLE1BQU1UO1FBQ25DLE1BQU1rQixPQUFPLE1BQU1ULGlCQUFpQmUsV0FBVyxDQUFDYTtRQUNoRG5ELFFBQVFDLEdBQUcsQ0FBQyxjQUFjK0I7UUFDMUIsT0FBT0E7SUFDVCxFQUFFLE9BQU81QixPQUFZO1FBQ25CSixRQUFRSSxLQUFLLENBQUMseUJBQXlCQTtRQUN2QyxPQUFPZixrRUFBbUJBLENBQUNlO0lBQzdCO0FBQ0YsRUFBRTtBQUVLLE1BQU1nRCxtQkFBbUIsT0FBT0MsZ0JBQXdCQztJQUM3RCxJQUFJLENBQUNELGtCQUFrQixDQUFDQyxVQUFVO1FBQ2hDLE1BQU0sSUFBSXZELE1BQU07SUFDbEI7SUFFQSxJQUFJO1FBQ0YsTUFBTSxFQUFFNEIsb0JBQW9CLEVBQUUsR0FBRyxNQUFNYjtRQUN2QyxNQUFNK0IsS0FBSyxNQUFNbEIscUJBQXFCeUIsZ0JBQWdCLENBQUNDLGdCQUFnQkM7UUFDdkUsTUFBTVQsR0FBR0gsSUFBSTtRQUNiLE9BQU9HO0lBQ1QsRUFBRSxPQUFPekMsT0FBWTtRQUNuQkosUUFBUUksS0FBSyxDQUFDLDhCQUE4QkE7UUFDNUMsT0FBT2Ysa0VBQW1CQSxDQUFDZTtJQUM3QjtBQUNGLEVBQUU7QUFFSyxNQUFNbUQsb0JBQW9CLE9BQU9DO0lBQ3RDLElBQUksQ0FBQ0EsZUFBZTtRQUNsQixNQUFNLElBQUl6RCxNQUFNO0lBQ2xCO0lBRUEsSUFBSTtRQUNGLE1BQU0sRUFBRTRCLG9CQUFvQixFQUFFLEdBQUcsTUFBTWI7UUFDdkMsTUFBTTJDLFVBQVUsTUFBTTlCLHFCQUFxQjRCLGlCQUFpQixDQUFDQztRQUM3RCxPQUFPQztJQUNULEVBQUUsT0FBT3JELE9BQVk7UUFDbkJKLFFBQVFJLEtBQUssQ0FBQyxnQ0FBZ0NBO1FBQzlDLE9BQU9mLGtFQUFtQkEsQ0FBQ2U7SUFDN0I7QUFDRixFQUFFO0FBRUssTUFBTXNELGtCQUFrQixPQUFPUDtJQUNwQyxJQUFJO1FBQ0ZwRSxrREFBVUEsQ0FBQ29FO0lBQ2IsRUFBRSxPQUFPL0MsT0FBTztRQUNkLE1BQU0sSUFBSUwsTUFBTTtJQUNsQjtJQUVBLElBQUk7UUFDRkMsUUFBUUMsR0FBRyxDQUFDLDZCQUE2QmtEO1FBQ3pDLE1BQU0sRUFBRXhCLG9CQUFvQixFQUFFLEdBQUcsTUFBTWI7UUFDdkMsTUFBTTZDLGVBQWUsTUFBTWhDLHFCQUFxQitCLGVBQWUsQ0FBQ1A7UUFDaEVuRCxRQUFRQyxHQUFHLENBQUMsaUJBQWlCMEQ7UUFDN0IsT0FBT0E7SUFDVCxFQUFFLE9BQU92RCxPQUFZO1FBQ25CSixRQUFRSSxLQUFLLENBQUMsNkJBQTZCQTtRQUMzQyxPQUFPZixrRUFBbUJBLENBQUNlO0lBQzdCO0FBQ0YsRUFBRTtBQUVLLE1BQU13RCxpQkFBaUIsT0FBT1Q7SUFDbkMsSUFBSTtRQUNGcEUsa0RBQVVBLENBQUNvRTtJQUNiLEVBQUUsT0FBTy9DLE9BQU87UUFDZCxNQUFNLElBQUlMLE1BQU07SUFDbEI7SUFFQSxJQUFJO1FBQ0ZDLFFBQVFDLEdBQUcsQ0FBQyxpQ0FBaUNrRDtRQUM3QyxNQUFNLEVBQUU1QixnQkFBZ0IsRUFBRSxHQUFHLE1BQU1UO1FBQ25DLE1BQU15QixhQUFhLE1BQU1oQixpQkFBaUJnQixVQUFVLENBQUNZO1FBQ3JEbkQsUUFBUUMsR0FBRyxDQUFDLDZCQUE2QnNDO1FBQ3pDLE9BQU9BO0lBQ1QsRUFBRSxPQUFPbkMsT0FBWTtRQUNuQkosUUFBUUksS0FBSyxDQUFDLDRCQUE0QkE7UUFDMUMsT0FBT2Ysa0VBQW1CQSxDQUFDZTtJQUM3QjtBQUNGLEVBQUU7QUFFSyxNQUFNeUQsVUFBVSxPQUFPVjtJQUM1QixJQUFJO1FBQ0ZwRSxrREFBVUEsQ0FBQ29FO0lBQ2IsRUFBRSxPQUFPL0MsT0FBTztRQUNkLE1BQU0sSUFBSUwsTUFBTTtJQUNsQjtJQUVBLElBQUk7UUFDRkMsUUFBUUMsR0FBRyxDQUFDLDhCQUE4QmtEO1FBQzFDLE1BQU0sRUFBRTVCLGdCQUFnQixFQUFFLEdBQUcsTUFBTVQ7UUFDbkMsTUFBTWdELGVBQWUsTUFBTXZDLGlCQUFpQndDLEtBQUs7UUFDakQsTUFBTUMsY0FBY2IsUUFBUWxCLFdBQVcsT0FBTzZCLGFBQWE3QixXQUFXO1FBQ3RFakMsUUFBUUMsR0FBRyxDQUFDLHNCQUFzQitEO1FBQ2xDLE9BQU9BO0lBQ1QsRUFBRSxPQUFPNUQsT0FBWTtRQUNuQkosUUFBUUksS0FBSyxDQUFDLHFCQUFxQkE7UUFDbkMsT0FBT2Ysa0VBQW1CQSxDQUFDZTtJQUM3QjtBQUNGLEVBQUU7QUFFSyxNQUFNNkQsb0JBQW9CLE9BQU9DO0lBQ3RDLElBQUk7UUFDRm5GLGtEQUFVQSxDQUFDbUY7SUFDYixFQUFFLE9BQU85RCxPQUFPO1FBQ2QsTUFBTSxJQUFJTCxNQUFNO0lBQ2xCO0lBRUEsSUFBSTtRQUNGQyxRQUFRQyxHQUFHLENBQUMsMEJBQTBCaUU7UUFDdEMsTUFBTSxFQUFFM0MsZ0JBQWdCLEVBQUUsR0FBRyxNQUFNVDtRQUNuQyxNQUFNK0IsS0FBSyxNQUFNdEIsaUJBQWlCa0IsVUFBVSxDQUFDeUI7UUFDN0MsTUFBTXJCLEdBQUdILElBQUk7UUFDYjFDLFFBQVFDLEdBQUcsQ0FBQztRQUNaLE9BQU87SUFDVCxFQUFFLE9BQU9HLE9BQVk7UUFDbkJKLFFBQVFJLEtBQUssQ0FBQywrQkFBK0JBO1FBQzdDLE9BQU9mLGtFQUFtQkEsQ0FBQ2U7SUFDN0I7QUFDRixFQUFFO0FBRUssTUFBTStELGtCQUFrQjtJQUM3QixJQUFJO1FBQ0YsTUFBTSxFQUFFNUMsZ0JBQWdCLEVBQUUsR0FBRyxNQUFNVDtRQUNuQyxNQUFNaUQsUUFBUSxNQUFNeEMsaUJBQWlCd0MsS0FBSztRQUMxQyxPQUFPQTtJQUNULEVBQUUsT0FBTzNELE9BQVk7UUFDbkJKLFFBQVFJLEtBQUssQ0FBQyxnQ0FBZ0NBO1FBQzlDLE9BQU9mLGtFQUFtQkEsQ0FBQ2U7SUFDN0I7QUFDRixFQUFFO0FBRUYsZ0NBQWdDO0FBQ3pCLE1BQU1nRSxhQUFhLE9BQ3hCQyxJQUNBQyxPQUNBQyxhQUNBQyxNQUNBQyxVQUNBbkI7SUFFQSxJQUFJO1FBQ0YsTUFBTSxFQUFFMUIsc0JBQXNCLEVBQUUsR0FBRyxNQUFNZDtRQUN6QyxNQUFNK0IsS0FBSyxNQUFNakIsdUJBQXVCd0MsVUFBVSxDQUFDQyxJQUFJQyxPQUFPQyxhQUFhQyxNQUFNQyxVQUFVbkI7UUFDM0YsTUFBTVQsR0FBR0gsSUFBSTtRQUNiLE9BQU87SUFDVCxFQUFFLE9BQU90QyxPQUFZO1FBQ25CSixRQUFRSSxLQUFLLENBQUMsd0JBQXdCQTtRQUN0QyxPQUFPZixrRUFBbUJBLENBQUNlO0lBQzdCO0FBQ0YsRUFBRTtBQUVLLE1BQU1zRSxtQkFBbUIsT0FDOUJDLFFBQ0FDLFNBQ0FDLE9BQ0FDLE9BQ0F4QjtJQUVBLElBQUk7UUFDRixNQUFNLEVBQUUxQixzQkFBc0IsRUFBRSxHQUFHLE1BQU1kO1FBQ3pDLE1BQU0rQixLQUFLLE1BQU1qQix1QkFBdUI4QyxnQkFBZ0IsQ0FBQ0MsUUFBUUMsU0FBU0MsT0FBT0MsT0FBT3hCO1FBQ3hGLE1BQU1ULEdBQUdILElBQUk7UUFDYixPQUFPO0lBQ1QsRUFBRSxPQUFPdEMsT0FBWTtRQUNuQkosUUFBUUksS0FBSyxDQUFDLGlDQUFpQ0E7UUFDL0MsT0FBT2Ysa0VBQW1CQSxDQUFDZTtJQUM3QjtBQUNGLEVBQUU7QUFFSyxNQUFNMkUsbUJBQW1CLE9BQU9KLFFBQWdCaEM7SUFDckQsSUFBSTtRQUNGLE1BQU0sRUFBRWYsc0JBQXNCLEVBQUUsR0FBRyxNQUFNZDtRQUN6QyxNQUFNK0IsS0FBSyxNQUFNakIsdUJBQXVCbUQsZ0JBQWdCLENBQUNKLFFBQVFoQztRQUNqRSxNQUFNRSxHQUFHSCxJQUFJO1FBQ2IsT0FBTztJQUNULEVBQUUsT0FBT3RDLE9BQVk7UUFDbkJKLFFBQVFJLEtBQUssQ0FBQywrQkFBK0JBO1FBQzdDLE9BQU9mLGtFQUFtQkEsQ0FBQ2U7SUFDN0I7QUFDRixFQUFFO0FBRUssTUFBTTRFLFVBQVUsT0FBT0w7SUFDNUIsSUFBSTtRQUNGLE1BQU0sRUFBRS9DLHNCQUFzQixFQUFFLEdBQUcsTUFBTWQ7UUFDekMsTUFBTW1FLE9BQU8sTUFBTXJELHVCQUF1Qm9ELE9BQU8sQ0FBQ0w7UUFDbEQsT0FBT007SUFDVCxFQUFFLE9BQU83RSxPQUFZO1FBQ25CSixRQUFRSSxLQUFLLENBQUMsdUJBQXVCQTtRQUNyQyxPQUFPZixrRUFBbUJBLENBQUNlO0lBQzdCO0FBQ0YsRUFBRTtBQUVLLE1BQU04RSxnQkFBZ0IsT0FBT1AsUUFBZ0JDO0lBQ2xELElBQUk7UUFDRixNQUFNLEVBQUVoRCxzQkFBc0IsRUFBRSxHQUFHLE1BQU1kO1FBQ3pDLE1BQU1xRSxTQUFTLE1BQU12RCx1QkFBdUJzRCxhQUFhLENBQUNQLFFBQVFDO1FBQ2xFLE9BQU9PO0lBQ1QsRUFBRSxPQUFPL0UsT0FBWTtRQUNuQkosUUFBUUksS0FBSyxDQUFDLDhCQUE4QkE7UUFDNUMsT0FBT2Ysa0VBQW1CQSxDQUFDZTtJQUM3QjtBQUNGLEVBQUU7QUFFSyxNQUFNZ0Ysc0JBQXNCLE9BQU9DO0lBQ3hDLElBQUk7UUFDRixNQUFNLEVBQUV6RCxzQkFBc0IsRUFBRSxHQUFHLE1BQU1kO1FBQ3pDLE1BQU13RSxRQUFRLE1BQU0xRCx1QkFBdUJ3RCxtQkFBbUIsQ0FBQ0M7UUFDL0QsT0FBT0M7SUFDVCxFQUFFLE9BQU9sRixPQUFZO1FBQ25CSixRQUFRSSxLQUFLLENBQUMsb0NBQW9DQTtRQUNsRCxPQUFPZixrRUFBbUJBLENBQUNlO0lBQzdCO0FBQ0YsRUFBRTtBQUVLLE1BQU1tRixrQkFBa0IsT0FBT1g7SUFDcEMsSUFBSTtRQUNGLE1BQU0sRUFBRWhELHNCQUFzQixFQUFFLEdBQUcsTUFBTWQ7UUFDekMsTUFBTXdFLFFBQVEsTUFBTTFELHVCQUF1QjJELGVBQWUsQ0FBQ1g7UUFDM0QsT0FBT1U7SUFDVCxFQUFFLE9BQU9sRixPQUFZO1FBQ25CSixRQUFRSSxLQUFLLENBQUMsZ0NBQWdDQTtRQUM5QyxPQUFPZixrRUFBbUJBLENBQUNlO0lBQzdCO0FBQ0YsRUFBRTtBQUVLLE1BQU1vRixnQkFBZ0IsT0FBT2IsUUFBZ0J0QjtJQUNsRCxJQUFJO1FBQ0YsTUFBTSxFQUFFekIsc0JBQXNCLEVBQUUsR0FBRyxNQUFNZDtRQUN6QyxNQUFNK0IsS0FBSyxNQUFNakIsdUJBQXVCNEQsYUFBYSxDQUFDYixRQUFRdEI7UUFDOUQsTUFBTVIsR0FBR0gsSUFBSTtRQUNiLE9BQU87SUFDVCxFQUFFLE9BQU90QyxPQUFZO1FBQ25CSixRQUFRSSxLQUFLLENBQUMsNEJBQTRCQTtRQUMxQyxPQUFPZixrRUFBbUJBLENBQUNlO0lBQzdCO0FBQ0YsRUFBRTtBQUVLLE1BQU1xRixjQUFjO0lBQ3pCLE1BQU0sRUFBRTdELHNCQUFzQixFQUFFLEdBQUcsTUFBTWQ7SUFDekMsT0FBT2M7QUFDVCxFQUFFO0FBRUssTUFBTU0sZUFBZTtJQUMxQixJQUFJO1FBQ0YsTUFBTSxFQUFFWCxnQkFBZ0IsRUFBRUosTUFBTSxFQUFFLEdBQUcsTUFBTUw7UUFDM0MsTUFBTU0sY0FBYyxNQUFNRCxPQUFPcEMsVUFBVTtRQUUzQ2lCLFFBQVFDLEdBQUcsQ0FBQyxtQ0FBbUNtQjtRQUMvQ3BCLFFBQVFDLEdBQUcsQ0FBQywyQkFBMkJMO1FBRXZDLGlEQUFpRDtRQUNqRCxNQUFNOEYsVUFBVSxNQUFNbkUsaUJBQWlCbUUsT0FBTyxDQUFDdEU7UUFDL0NwQixRQUFRQyxHQUFHLENBQUMscUJBQXFCeUY7UUFFakMsSUFBSUEsU0FBUztZQUNYMUYsUUFBUUMsR0FBRyxDQUFDO1lBQ1osT0FBTztnQkFBRTBDLFFBQVE7Z0JBQVkrQyxTQUFTO1lBQUs7UUFDN0M7UUFFQSxnREFBZ0Q7UUFDaEQsSUFBSTlGLGlCQUFpQndCLFlBQVlhLFdBQVcsT0FBT3JDLGNBQWNxQyxXQUFXLElBQUk7WUFDOUVqQyxRQUFRQyxHQUFHLENBQUM7WUFFWiwyREFBMkQ7WUFDM0QsSUFBSTtnQkFDRixNQUFNK0IsT0FBTyxNQUFNVCxpQkFBaUJlLFdBQVcsQ0FBQ2xCO2dCQUNoRCxJQUFJWSxTQUFTLEdBQUc7b0JBQ2RoQyxRQUFRQyxHQUFHLENBQUM7b0JBQ1osTUFBTTBGLFFBQVEsTUFBTXBFLGlCQUFpQlEsWUFBWSxDQUFDeEIsV0FBV0ssS0FBSyxFQUFFO29CQUNwRSxNQUFNK0UsTUFBTWpELElBQUk7Z0JBQ2xCO1lBQ0YsRUFBRSxPQUFPdEMsT0FBWTtnQkFDbkIsSUFBSSxDQUFDQSxNQUFNeUIsT0FBTyxDQUFDZSxRQUFRLENBQUMsd0JBQXdCO29CQUNsRCxNQUFNeEM7Z0JBQ1I7Z0JBQ0EsZ0RBQWdEO2dCQUNoREosUUFBUUMsR0FBRyxDQUFDO2dCQUNaLE1BQU0wRixRQUFRLE1BQU1wRSxpQkFBaUJRLFlBQVksQ0FBQ3hCLFdBQVdLLEtBQUssRUFBRTtnQkFDcEUsTUFBTStFLE1BQU1qRCxJQUFJO1lBQ2xCO1lBRUEsa0JBQWtCO1lBQ2xCMUMsUUFBUUMsR0FBRyxDQUFDO1lBQ1osTUFBTXVDLFdBQVcsTUFBTWpCLGlCQUFpQmtCLFVBQVUsQ0FBQ3JCO1lBQ25ELE1BQU1vQixTQUFTRSxJQUFJO1lBRW5CLGlCQUFpQjtZQUNqQjFDLFFBQVFDLEdBQUcsQ0FBQztZQUNaLE1BQU00QyxLQUFLLE1BQU10QixpQkFBaUJxRSxRQUFRLENBQUN4RTtZQUMzQyxNQUFNeUIsR0FBR0gsSUFBSTtZQUNiMUMsUUFBUUMsR0FBRyxDQUFDO1lBRVosT0FBTztnQkFBRTBDLFFBQVE7Z0JBQVcrQyxTQUFTO1lBQUs7UUFDNUM7UUFFQSxNQUFNLElBQUkzRixNQUFNO0lBQ2xCLEVBQUUsT0FBT0ssT0FBWTtRQUNuQkosUUFBUUksS0FBSyxDQUFDLDZCQUE2QkE7UUFDM0MsT0FBT2Ysa0VBQW1CQSxDQUFDZTtJQUM3QjtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vdXRpbHMvY29udHJhY3RzLnRzPzk4NTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgXG4gIENvbnRyYWN0LFxuICBmb3JtYXRVbml0cyxcbiAgZ2V0QWRkcmVzc1xufSBmcm9tICdldGhlcnMnO1xuaW1wb3J0IHsgRXhhbU1hbmFnZW1lbnRBQkkgfSBmcm9tICcuLi9jb25zdGFudHMvYWJpcyc7XG5pbXBvcnQgeyBcbiAgZ2V0UHJvdmlkZXIsIFxuICBnZXRTaWduZXIsIFxuICBFWFBFQ1RFRF9ORVRXT1JLLCBcbiAgdmFsaWRhdGVOZXR3b3JrLFxuICBmb3JtYXRFdGhlcixcbiAgaGFuZGxlQ29udHJhY3RFcnJvclxufSBmcm9tICcuL2V0aGVyc0NvbmZpZyc7XG5pbXBvcnQgdHlwZSB7IEV0aGVyZXVtUHJvdmlkZXIgfSBmcm9tICcuL2V0aGVyc0NvbmZpZyc7XG5pbXBvcnQgeyBnZXRDb25maWcsIHZhbGlkYXRlQ29uZmlnIH0gZnJvbSAnLi9jb25maWcnO1xuXG4vLyBDb250cmFjdCBBQklzXG5jb25zdCBJZGVudGl0eUFCSSA9IFtcbiAgXCJmdW5jdGlvbiByZWdpc3RlclVzZXIodWludDggX3JvbGUsIHN0cmluZyBtZW1vcnkgX2lwZnNIYXNoKSBleHRlcm5hbFwiLFxuICBcImZ1bmN0aW9uIHZlcmlmeVVzZXIoYWRkcmVzcyBfdXNlckFkZHJlc3MpIGV4dGVybmFsXCIsXG4gIFwiZnVuY3Rpb24gZ2V0VXNlclJvbGUoYWRkcmVzcyBfdXNlckFkZHJlc3MpIGV4dGVybmFsIHZpZXcgcmV0dXJucyAodWludDgpXCIsXG4gIFwiZnVuY3Rpb24gaXNWZXJpZmllZFVzZXIoYWRkcmVzcyBfdXNlckFkZHJlc3MpIGV4dGVybmFsIHZpZXcgcmV0dXJucyAoYm9vbClcIixcbiAgXCJmdW5jdGlvbiB1cGRhdGVVc2VySVBGUyhzdHJpbmcgbWVtb3J5IF9uZXdJcGZzSGFzaCkgZXh0ZXJuYWxcIixcbiAgXCJmdW5jdGlvbiBvd25lcigpIGV4dGVybmFsIHZpZXcgcmV0dXJucyAoYWRkcmVzcylcIixcbiAgXCJmdW5jdGlvbiBpc0FkbWluKGFkZHJlc3MgX2FkZHJlc3MpIGV4dGVybmFsIHZpZXcgcmV0dXJucyAoYm9vbClcIixcbiAgXCJmdW5jdGlvbiBhZGRBZG1pbihhZGRyZXNzIF9uZXdBZG1pbikgZXh0ZXJuYWxcIixcbiAgXCJmdW5jdGlvbiByZW1vdmVBZG1pbihhZGRyZXNzIF9hZG1pbikgZXh0ZXJuYWxcIlxuXTtcblxuY29uc3QgQ2VydGlmaWNhdGVzQUJJID0gW1xuICBcImZ1bmN0aW9uIGlzc3VlQ2VydGlmaWNhdGUoYWRkcmVzcyBfc3R1ZGVudEFkZHJlc3MsIHN0cmluZyBtZW1vcnkgX2lwZnNIYXNoKSBleHRlcm5hbCByZXR1cm5zIChieXRlczMyKVwiLFxuICBcImZ1bmN0aW9uIGdldFN0dWRlbnRDZXJ0aWZpY2F0ZXMoYWRkcmVzcyBfc3R1ZGVudCkgZXh0ZXJuYWwgdmlldyByZXR1cm5zIChieXRlczMyW10pXCIsXG4gIFwiZnVuY3Rpb24gdmVyaWZ5Q2VydGlmaWNhdGUoYnl0ZXMzMiBfY2VydGlmaWNhdGVJZCkgZXh0ZXJuYWwgdmlldyByZXR1cm5zIChhZGRyZXNzIHN0dWRlbnQsIGFkZHJlc3MgaW5zdGl0dXRpb24sIHN0cmluZyBpcGZzSGFzaCwgdWludDI1NiBpc3N1ZWRBdCwgYm9vbCBpc1ZhbGlkKVwiXG5dO1xuXG4vLyBDb250cmFjdCBhZGRyZXNzZXMgZnJvbSBjb25maWdcbmNvbnN0IElERU5USVRZX0NPTlRSQUNUX0FERFJFU1MgPSBnZXRDb25maWcoJ0lERU5USVRZX0NPTlRSQUNUX0FERFJFU1MnKTtcbmNvbnN0IENFUlRJRklDQVRFU19DT05UUkFDVF9BRERSRVNTID0gZ2V0Q29uZmlnKCdDRVJUSUZJQ0FURVNfQ09OVFJBQ1RfQUREUkVTUycpO1xuY29uc3QgQURNSU5fQUREUkVTUyA9IGdldENvbmZpZygnQURNSU5fQUREUkVTUycpO1xuY29uc3QgRVhBTV9NQU5BR0VNRU5UX0FERFJFU1MgPSBnZXRDb25maWcoJ0VYQU1fTUFOQUdFTUVOVF9DT05UUkFDVF9BRERSRVNTJyk7XG5cbi8vIFZhbGlkYXRlIGVudmlyb25tZW50IHZhcmlhYmxlc1xuZXhwb3J0IGNvbnN0IHZhbGlkYXRlRW52ID0gKCkgPT4ge1xuICB0cnkge1xuICAgIC8vINin2YTYqtit2YLZgiDZhdmGINi12K3YqSDYp9mE2KrZg9mI2YrZhlxuICAgIHZhbGlkYXRlQ29uZmlnKCk7XG5cbiAgICAvLyDYp9mE2KrYrdmC2YIg2YXZhiDYtdit2Kkg2KfZhNi52YbYp9mI2YrZhlxuICAgIGlmICghZ2V0QWRkcmVzcyhJREVOVElUWV9DT05UUkFDVF9BRERSRVNTKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIElkZW50aXR5IGNvbnRyYWN0IGFkZHJlc3M6ICR7SURFTlRJVFlfQ09OVFJBQ1RfQUREUkVTU31gKTtcbiAgICB9XG5cbiAgICBpZiAoIWdldEFkZHJlc3MoQ0VSVElGSUNBVEVTX0NPTlRSQUNUX0FERFJFU1MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgQ2VydGlmaWNhdGVzIGNvbnRyYWN0IGFkZHJlc3M6ICR7Q0VSVElGSUNBVEVTX0NPTlRSQUNUX0FERFJFU1N9YCk7XG4gICAgfVxuXG4gICAgaWYgKCFnZXRBZGRyZXNzKEFETUlOX0FERFJFU1MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgQWRtaW4gYWRkcmVzczogJHtBRE1JTl9BRERSRVNTfWApO1xuICAgIH1cblxuICAgIGlmICghZ2V0QWRkcmVzcyhFWEFNX01BTkFHRU1FTlRfQUREUkVTUykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBFeGFtIE1hbmFnZW1lbnQgY29udHJhY3QgYWRkcmVzczogJHtFWEFNX01BTkFHRU1FTlRfQUREUkVTU31gKTtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygnQ29uZmlndXJhdGlvbiB2YWxpZGF0ZWQgc3VjY2Vzc2Z1bGx5OicsIHtcbiAgICAgIElERU5USVRZX0NPTlRSQUNUX0FERFJFU1MsXG4gICAgICBDRVJUSUZJQ0FURVNfQ09OVFJBQ1RfQUREUkVTUyxcbiAgICAgIEFETUlOX0FERFJFU1MsXG4gICAgICBFWEFNX01BTkFHRU1FTlRfQUREUkVTUyxcbiAgICAgIENIQUlOX0lEOiBnZXRDb25maWcoJ0NIQUlOX0lEJyksXG4gICAgICBORVRXT1JLX1VSTDogZ2V0Q29uZmlnKCdORVRXT1JLX1VSTCcpXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdDb25maWd1cmF0aW9uIHZhbGlkYXRpb24gZmFpbGVkOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxuLy8gRGVidWcgZW52aXJvbm1lbnQgdmFyaWFibGVzXG5jb25zb2xlLmxvZygnRW52aXJvbm1lbnQgdmFyaWFibGVzIGNoZWNrOicsIHtcbiAgSURFTlRJVFlfQ09OVFJBQ1RfQUREUkVTUyxcbiAgQ0VSVElGSUNBVEVTX0NPTlRSQUNUX0FERFJFU1MsXG4gIEFETUlOX0FERFJFU1MsXG4gIEVYQU1fTUFOQUdFTUVOVF9BRERSRVNTLFxuICBDSEFJTl9JRDogRVhQRUNURURfTkVUV09SSy5jaGFpbklkLFxuICBORVRXT1JLX1VSTDogRVhQRUNURURfTkVUV09SSy5ycGNVcmxcbn0pO1xuXG4vLyBSb2xlIG1hcHBpbmcgd2l0aCBwcm9wZXIgdHlwZXNcbmNvbnN0IFVTRVJfUk9MRVMgPSB7XG4gIE5PTkU6IDAsXG4gIFNUVURFTlQ6IDEsXG4gIElOU1RJVFVUSU9OOiAyLFxuICBFTVBMT1lFUjogMyxcbiAgQURNSU46IDRcbn0gYXMgY29uc3Q7XG5cbnR5cGUgUm9sZVZhbHVlID0gdHlwZW9mIFVTRVJfUk9MRVNba2V5b2YgdHlwZW9mIFVTRVJfUk9MRVNdO1xudHlwZSBSb2xlU3RyaW5nID0gJ25vbmUnIHwgJ3N0dWRlbnQnIHwgJ2luc3RpdHV0aW9uJyB8ICdlbXBsb3llcicgfCAnYWRtaW4nO1xuXG5jb25zdCByb2xlTWFwOiBSZWNvcmQ8Um9sZVZhbHVlLCBSb2xlU3RyaW5nPiA9IHtcbiAgW1VTRVJfUk9MRVMuTk9ORV06ICdub25lJyxcbiAgW1VTRVJfUk9MRVMuU1RVREVOVF06ICdzdHVkZW50JyxcbiAgW1VTRVJfUk9MRVMuSU5TVElUVVRJT05dOiAnaW5zdGl0dXRpb24nLFxuICBbVVNFUl9ST0xFUy5FTVBMT1lFUl06ICdlbXBsb3llcicsXG4gIFtVU0VSX1JPTEVTLkFETUlOXTogJ2FkbWluJ1xufTtcblxuZXhwb3J0IGNvbnN0IGdldENvbnRyYWN0cyA9IGFzeW5jICgpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygnQ29udHJhY3QgQWRkcmVzc2VzOicsIHtcbiAgICAgIElkZW50aXR5OiBJREVOVElUWV9DT05UUkFDVF9BRERSRVNTLFxuICAgICAgQ2VydGlmaWNhdGVzOiBDRVJUSUZJQ0FURVNfQ09OVFJBQ1RfQUREUkVTUyxcbiAgICAgIEFkbWluOiBBRE1JTl9BRERSRVNTXG4gICAgfSk7XG5cbiAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IGdldFByb3ZpZGVyKCk7XG4gICAgYXdhaXQgdmFsaWRhdGVOZXR3b3JrKHByb3ZpZGVyKTtcbiAgICBjb25zb2xlLmxvZygnTmV0d29yayB2YWxpZGF0aW9uIHBhc3NlZCcpO1xuICAgIFxuICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IGdldFNpZ25lcigpO1xuICAgIGNvbnN0IHVzZXJBZGRyZXNzID0gYXdhaXQgc2lnbmVyLmdldEFkZHJlc3MoKTtcbiAgICBcbiAgICBjb25zb2xlLmxvZygnQ29ubmVjdGVkIHdpdGggYWRkcmVzczonLCB1c2VyQWRkcmVzcyk7XG4gICAgXG4gICAgY29uc3QgdXNlckJhbGFuY2UgPSBhd2FpdCBwcm92aWRlci5nZXRCYWxhbmNlKHVzZXJBZGRyZXNzKTtcbiAgICBjb25zb2xlLmxvZygnVXNlciBiYWxhbmNlOicsIGZvcm1hdFVuaXRzKHVzZXJCYWxhbmNlLCAnZXRoZXInKSwgJ0VUSCcpO1xuICAgIFxuICAgIGNvbnN0IGlkZW50aXR5Q29udHJhY3QgPSBuZXcgQ29udHJhY3QoXG4gICAgICBJREVOVElUWV9DT05UUkFDVF9BRERSRVNTISxcbiAgICAgIElkZW50aXR5QUJJLFxuICAgICAgc2lnbmVyXG4gICAgKTtcblxuICAgIGNvbnNvbGUubG9nKCdWZXJpZnlpbmcgY29udHJhY3QgZXhpc3RzIGF0IGFkZHJlc3M6JywgSURFTlRJVFlfQ09OVFJBQ1RfQUREUkVTUyk7XG4gICAgY29uc3QgY29kZSA9IGF3YWl0IHByb3ZpZGVyLmdldENvZGUoSURFTlRJVFlfQ09OVFJBQ1RfQUREUkVTUyEpO1xuICAgIGNvbnNvbGUubG9nKCdDb250cmFjdCBjb2RlIGxlbmd0aDonLCBjb2RlLmxlbmd0aCk7XG4gICAgY29uc29sZS5sb2coJ0NvbnRyYWN0IGV4aXN0czonLCBjb2RlICE9PSAnMHgnKTtcbiAgICBcbiAgICBpZiAoY29kZSA9PT0gJzB4Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJZGVudGl0eSBjb250cmFjdCBub3QgZm91bmQgYXQgYWRkcmVzczogJHtJREVOVElUWV9DT05UUkFDVF9BRERSRVNTfWApO1xuICAgIH1cblxuICAgIGNvbnN0IGNlcnRpZmljYXRlc0NvbnRyYWN0ID0gbmV3IENvbnRyYWN0KFxuICAgICAgQ0VSVElGSUNBVEVTX0NPTlRSQUNUX0FERFJFU1MhLFxuICAgICAgQ2VydGlmaWNhdGVzQUJJLFxuICAgICAgc2lnbmVyXG4gICAgKTtcblxuICAgIGNvbnN0IGV4YW1NYW5hZ2VtZW50Q29udHJhY3QgPSBuZXcgQ29udHJhY3QoXG4gICAgICBFWEFNX01BTkFHRU1FTlRfQUREUkVTUyEsXG4gICAgICBFeGFtTWFuYWdlbWVudEFCSSxcbiAgICAgIHNpZ25lclxuICAgICk7XG5cbiAgICByZXR1cm4geyBpZGVudGl0eUNvbnRyYWN0LCBjZXJ0aWZpY2F0ZXNDb250cmFjdCwgZXhhbU1hbmFnZW1lbnRDb250cmFjdCwgcHJvdmlkZXIsIHNpZ25lciB9O1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW5pdGlhbGl6aW5nIGNvbnRyYWN0czonLCBlcnJvcik7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZGV0YWlsczonLCB7XG4gICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgY29kZTogZXJyb3IuY29kZSxcbiAgICAgIHJlYXNvbjogZXJyb3IucmVhc29uXG4gICAgfSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gaW5pdGlhbGl6ZSBjb250cmFjdHM6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHJlZ2lzdGVyVXNlciA9IGFzeW5jIChyb2xlOiBzdHJpbmcpID0+IHtcbiAgaWYgKCFyb2xlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSb2xlIGlzIHJlcXVpcmVkJyk7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IHsgaWRlbnRpdHlDb250cmFjdCwgc2lnbmVyIH0gPSBhd2FpdCBnZXRDb250cmFjdHMoKTtcbiAgICBcbiAgICAvLyBHZXQgbmV0d29yayBkZXRhaWxzIGFuZCB1c2VyIGFkZHJlc3NcbiAgICBjb25zdCB1c2VyQWRkcmVzcyA9IGF3YWl0IHNpZ25lci5nZXRBZGRyZXNzKCk7XG4gICAgY29uc29sZS5sb2coJ1JlZ2lzdGVyaW5nIGFkZHJlc3M6JywgdXNlckFkZHJlc3MpO1xuICAgIGNvbnNvbGUubG9nKCdXaXRoIHJvbGU6Jywgcm9sZSk7XG4gICAgXG4gICAgLy8gU3BlY2lhbCBoYW5kbGluZyBmb3IgYWRtaW4gYWRkcmVzc1xuICAgIGlmIChBRE1JTl9BRERSRVNTICYmIHVzZXJBZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IEFETUlOX0FERFJFU1MudG9Mb3dlckNhc2UoKSkge1xuICAgICAgY29uc29sZS5sb2coJ1RoaXMgaXMgdGhlIGFkbWluIGFkZHJlc3MsIHNldHRpbmcgYWRtaW4gcm9sZS4uLicpO1xuICAgICAgcmV0dXJuIGF3YWl0IHNldEFkbWluUm9sZSgpO1xuICAgIH1cbiAgICBcbiAgICAvLyBDb252ZXJ0IHJvbGUgc3RyaW5nIHRvIGVudW0gdmFsdWVcbiAgICBjb25zdCByb2xlTWFwOiB7IFtrZXk6IHN0cmluZ106IG51bWJlciB9ID0ge1xuICAgICAgJ3N0dWRlbnQnOiBVU0VSX1JPTEVTLlNUVURFTlQsXG4gICAgICAnaW5zdGl0dXRpb24nOiBVU0VSX1JPTEVTLklOU1RJVFVUSU9OLFxuICAgICAgJ2VtcGxveWVyJzogVVNFUl9ST0xFUy5FTVBMT1lFUixcbiAgICAgICdhZG1pbic6IFVTRVJfUk9MRVMuQURNSU5cbiAgICB9O1xuICAgIFxuICAgIGNvbnN0IHJvbGVWYWx1ZSA9IHJvbGVNYXBbcm9sZS50b0xvd2VyQ2FzZSgpXTtcbiAgICBpZiAocm9sZVZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCByb2xlOiAke3JvbGV9LiBNdXN0IGJlIG9uZSBvZjogc3R1ZGVudCwgaW5zdGl0dXRpb24sIGVtcGxveWVyLCBhZG1pbmApO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCdSb2xlIHZhbHVlIGZyb20gbWFwcGluZzonLCByb2xlVmFsdWUpO1xuICAgIFxuICAgIC8vIENoZWNrIGlmIHVzZXIgaXMgYWxyZWFkeSByZWdpc3RlcmVkXG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCdDaGVja2luZyBpZiB1c2VyIGFscmVhZHkgZXhpc3RzLi4uJyk7XG4gICAgICBjb25zdCBleGlzdGluZ1JvbGUgPSBhd2FpdCBpZGVudGl0eUNvbnRyYWN0LmdldFVzZXJSb2xlKHVzZXJBZGRyZXNzKTtcbiAgICAgIGNvbnNvbGUubG9nKCdFeGlzdGluZyByb2xlOicsIGV4aXN0aW5nUm9sZSk7XG4gICAgICBcbiAgICAgIGlmIChleGlzdGluZ1JvbGUgPiAwKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdVc2VyIGFscmVhZHkgcmVnaXN0ZXJlZCB3aXRoIHJvbGU6JywgZXhpc3RpbmdSb2xlKTtcbiAgICAgICAgXG4gICAgICAgIC8vIElmIHVzZXIgZXhpc3RzIGJ1dCBuZWVkcyB2ZXJpZmljYXRpb25cbiAgICAgICAgY29uc3QgaXNWZXJpZmllZCA9IGF3YWl0IGlkZW50aXR5Q29udHJhY3QuaXNWZXJpZmllZCh1c2VyQWRkcmVzcyk7XG4gICAgICAgIGlmICghaXNWZXJpZmllZCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdVc2VyIGV4aXN0cyBidXQgbm90IHZlcmlmaWVkLCBhdHRlbXB0aW5nIHZlcmlmaWNhdGlvbi4uLicpO1xuICAgICAgICAgIGNvbnN0IHZlcmlmeVR4ID0gYXdhaXQgaWRlbnRpdHlDb250cmFjdC52ZXJpZnlVc2VyKHVzZXJBZGRyZXNzKTtcbiAgICAgICAgICBhd2FpdCB2ZXJpZnlUeC53YWl0KCk7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1VzZXIgdmVyaWZpZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7IHN0YXR1czogJ2V4aXN0aW5nJywgcm9sZTogZXhpc3RpbmdSb2xlIH07XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgaWYgKCFlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdVc2VyIGRvZXMgbm90IGV4aXN0JykpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICBjb25zb2xlLmxvZygnVXNlciBkb2VzIG5vdCBleGlzdCwgcHJvY2VlZGluZyB3aXRoIHJlZ2lzdHJhdGlvbicpO1xuICAgIH1cbiAgICBcbiAgICAvLyBSZWdpc3RlciB1c2VyXG4gICAgY29uc29sZS5sb2coJ1JlZ2lzdGVyaW5nIG5ldyB1c2VyIHdpdGggcm9sZTonLCByb2xlVmFsdWUpO1xuICAgIGNvbnN0IHR4ID0gYXdhaXQgaWRlbnRpdHlDb250cmFjdC5yZWdpc3RlclVzZXIocm9sZVZhbHVlLCBcIlwiKTtcbiAgICBjb25zb2xlLmxvZygnUmVnaXN0cmF0aW9uIHRyYW5zYWN0aW9uIHNlbnQ6JywgdHguaGFzaCk7XG4gICAgXG4gICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHR4LndhaXQoKTtcbiAgICBjb25zb2xlLmxvZygnUmVnaXN0cmF0aW9uIHN1Y2Nlc3NmdWw6JywgcmVjZWlwdC5oYXNoKTtcbiAgICBcbiAgICAvLyBWZXJpZnkgdGhlIHVzZXIgYXV0b21hdGljYWxseVxuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygnQXR0ZW1wdGluZyBhdXRvbWF0aWMgdmVyaWZpY2F0aW9uLi4uJyk7XG4gICAgICBjb25zdCB2ZXJpZnlUeCA9IGF3YWl0IGlkZW50aXR5Q29udHJhY3QudmVyaWZ5VXNlcih1c2VyQWRkcmVzcyk7XG4gICAgICBhd2FpdCB2ZXJpZnlUeC53YWl0KCk7XG4gICAgICBjb25zb2xlLmxvZygnVXNlciB2ZXJpZmllZCBzdWNjZXNzZnVsbHknKTtcbiAgICB9IGNhdGNoICh2ZXJpZnlFcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKCdBdXRvbWF0aWMgdmVyaWZpY2F0aW9uIGZhaWxlZDonLCB2ZXJpZnlFcnJvcik7XG4gICAgICAvLyBDb250aW51ZSBldmVuIGlmIHZlcmlmaWNhdGlvbiBmYWlsc1xuICAgIH1cbiAgICBcbiAgICAvLyBJZiByZWdpc3RlcmluZyBhcyBhZG1pbiwgc2V0IGFkbWluIHJvbGVcbiAgICBpZiAocm9sZS50b0xvd2VyQ2FzZSgpID09PSAnYWRtaW4nKSB7XG4gICAgICBjb25zb2xlLmxvZygnU2V0dGluZyBhZG1pbiBwcml2aWxlZ2VzLi4uJyk7XG4gICAgICBhd2FpdCBzZXRBZG1pblJvbGUoKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHsgc3RhdHVzOiAnc3VjY2VzcycsIHJvbGU6IHJvbGVWYWx1ZSwgdHJhbnNhY3Rpb246IHR4IH07XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICByZXR1cm4gaGFuZGxlQ29udHJhY3RFcnJvcihlcnJvcik7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCB2ZXJpZnlVc2VyID0gYXN5bmMgKGFkZHJlc3M6IHN0cmluZykgPT4ge1xuICB0cnkge1xuICAgIGdldEFkZHJlc3MoYWRkcmVzcyk7IC8vIFVzaW5nIGdldEFkZHJlc3MgaW5zdGVhZCBvZiBpc0FkZHJlc3NcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYWRkcmVzcycpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygnVmVyaWZ5aW5nIHVzZXI6JywgYWRkcmVzcyk7XG4gICAgY29uc3QgeyBpZGVudGl0eUNvbnRyYWN0IH0gPSBhd2FpdCBnZXRDb250cmFjdHMoKTtcbiAgICBjb25zdCBpc1ZlcmlmaWVkID0gYXdhaXQgaWRlbnRpdHlDb250cmFjdC5pc1ZlcmlmaWVkKGFkZHJlc3MpO1xuICAgIGNvbnNvbGUubG9nKCdVc2VyIHZlcmlmaWNhdGlvbiBzdGF0dXM6JywgaXNWZXJpZmllZCk7XG4gICAgcmV0dXJuIGlzVmVyaWZpZWQ7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiB2ZXJpZnlVc2VyOicsIGVycm9yKTtcbiAgICByZXR1cm4gaGFuZGxlQ29udHJhY3RFcnJvcihlcnJvcik7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBnZXRVc2VyUm9sZSA9IGFzeW5jIChhZGRyZXNzOiBzdHJpbmcpOiBQcm9taXNlPFJvbGVTdHJpbmc+ID0+IHtcbiAgdHJ5IHtcbiAgICBnZXRBZGRyZXNzKGFkZHJlc3MpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhZGRyZXNzJyk7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCdHZXR0aW5nIHVzZXIgcm9sZSBmb3I6JywgYWRkcmVzcyk7XG4gICAgY29uc3QgeyBpZGVudGl0eUNvbnRyYWN0IH0gPSBhd2FpdCBnZXRDb250cmFjdHMoKTtcbiAgICBjb25zdCByb2xlID0gYXdhaXQgaWRlbnRpdHlDb250cmFjdC5nZXRVc2VyUm9sZShhZGRyZXNzKTtcbiAgICBjb25zb2xlLmxvZygnVXNlciByb2xlOicsIHJvbGUpO1xuICAgIHJldHVybiByb2xlO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gZ2V0VXNlclJvbGU6JywgZXJyb3IpO1xuICAgIHJldHVybiBoYW5kbGVDb250cmFjdEVycm9yKGVycm9yKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGlzc3VlQ2VydGlmaWNhdGUgPSBhc3luYyAoc3R1ZGVudEFkZHJlc3M6IHN0cmluZywgaXBmc0hhc2g6IHN0cmluZykgPT4ge1xuICBpZiAoIXN0dWRlbnRBZGRyZXNzIHx8ICFpcGZzSGFzaCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU3R1ZGVudCBhZGRyZXNzIGFuZCBJUEZTIGhhc2ggYXJlIHJlcXVpcmVkJyk7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IHsgY2VydGlmaWNhdGVzQ29udHJhY3QgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xuICAgIGNvbnN0IHR4ID0gYXdhaXQgY2VydGlmaWNhdGVzQ29udHJhY3QuaXNzdWVDZXJ0aWZpY2F0ZShzdHVkZW50QWRkcmVzcywgaXBmc0hhc2gpO1xuICAgIGF3YWl0IHR4LndhaXQoKTtcbiAgICByZXR1cm4gdHg7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpc3N1aW5nIGNlcnRpZmljYXRlOicsIGVycm9yKTtcbiAgICByZXR1cm4gaGFuZGxlQ29udHJhY3RFcnJvcihlcnJvcik7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCB2ZXJpZnlDZXJ0aWZpY2F0ZSA9IGFzeW5jIChjZXJ0aWZpY2F0ZUlkOiBzdHJpbmcpID0+IHtcbiAgaWYgKCFjZXJ0aWZpY2F0ZUlkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDZXJ0aWZpY2F0ZSBJRCBpcyByZXF1aXJlZCcpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCB7IGNlcnRpZmljYXRlc0NvbnRyYWN0IH0gPSBhd2FpdCBnZXRDb250cmFjdHMoKTtcbiAgICBjb25zdCBpc1ZhbGlkID0gYXdhaXQgY2VydGlmaWNhdGVzQ29udHJhY3QudmVyaWZ5Q2VydGlmaWNhdGUoY2VydGlmaWNhdGVJZCk7XG4gICAgcmV0dXJuIGlzVmFsaWQ7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciB2ZXJpZnlpbmcgY2VydGlmaWNhdGU6JywgZXJyb3IpO1xuICAgIHJldHVybiBoYW5kbGVDb250cmFjdEVycm9yKGVycm9yKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGdldENlcnRpZmljYXRlcyA9IGFzeW5jIChhZGRyZXNzOiBzdHJpbmcpID0+IHtcbiAgdHJ5IHtcbiAgICBnZXRBZGRyZXNzKGFkZHJlc3MpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhZGRyZXNzJyk7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCdHZXR0aW5nIGNlcnRpZmljYXRlcyBmb3I6JywgYWRkcmVzcyk7XG4gICAgY29uc3QgeyBjZXJ0aWZpY2F0ZXNDb250cmFjdCB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XG4gICAgY29uc3QgY2VydGlmaWNhdGVzID0gYXdhaXQgY2VydGlmaWNhdGVzQ29udHJhY3QuZ2V0Q2VydGlmaWNhdGVzKGFkZHJlc3MpO1xuICAgIGNvbnNvbGUubG9nKCdDZXJ0aWZpY2F0ZXM6JywgY2VydGlmaWNhdGVzKTtcbiAgICByZXR1cm4gY2VydGlmaWNhdGVzO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gZ2V0Q2VydGlmaWNhdGVzOicsIGVycm9yKTtcbiAgICByZXR1cm4gaGFuZGxlQ29udHJhY3RFcnJvcihlcnJvcik7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBpc1ZlcmlmaWVkVXNlciA9IGFzeW5jIChhZGRyZXNzOiBzdHJpbmcpID0+IHtcbiAgdHJ5IHtcbiAgICBnZXRBZGRyZXNzKGFkZHJlc3MpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhZGRyZXNzJyk7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCdDaGVja2luZyBpZiB1c2VyIGlzIHZlcmlmaWVkOicsIGFkZHJlc3MpO1xuICAgIGNvbnN0IHsgaWRlbnRpdHlDb250cmFjdCB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XG4gICAgY29uc3QgaXNWZXJpZmllZCA9IGF3YWl0IGlkZW50aXR5Q29udHJhY3QuaXNWZXJpZmllZChhZGRyZXNzKTtcbiAgICBjb25zb2xlLmxvZygnVXNlciB2ZXJpZmljYXRpb24gc3RhdHVzOicsIGlzVmVyaWZpZWQpO1xuICAgIHJldHVybiBpc1ZlcmlmaWVkO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gaXNWZXJpZmllZFVzZXI6JywgZXJyb3IpO1xuICAgIHJldHVybiBoYW5kbGVDb250cmFjdEVycm9yKGVycm9yKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGlzT3duZXIgPSBhc3luYyAoYWRkcmVzczogc3RyaW5nKSA9PiB7XG4gIHRyeSB7XG4gICAgZ2V0QWRkcmVzcyhhZGRyZXNzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYWRkcmVzcycpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygnQ2hlY2tpbmcgaWYgdXNlciBpcyBvd25lcjonLCBhZGRyZXNzKTtcbiAgICBjb25zdCB7IGlkZW50aXR5Q29udHJhY3QgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xuICAgIGNvbnN0IG93bmVyQWRkcmVzcyA9IGF3YWl0IGlkZW50aXR5Q29udHJhY3Qub3duZXIoKTtcbiAgICBjb25zdCBpc093bmVyUm9sZSA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gb3duZXJBZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc29sZS5sb2coJ1VzZXIgb3duZXIgc3RhdHVzOicsIGlzT3duZXJSb2xlKTtcbiAgICByZXR1cm4gaXNPd25lclJvbGU7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBpc093bmVyOicsIGVycm9yKTtcbiAgICByZXR1cm4gaGFuZGxlQ29udHJhY3RFcnJvcihlcnJvcik7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCB2ZXJpZnlJbnN0aXR1dGlvbiA9IGFzeW5jIChpbnN0aXR1dGlvbkFkZHJlc3M6IHN0cmluZykgPT4ge1xuICB0cnkge1xuICAgIGdldEFkZHJlc3MoaW5zdGl0dXRpb25BZGRyZXNzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5zdGl0dXRpb24gYWRkcmVzcycpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygnVmVyaWZ5aW5nIGluc3RpdHV0aW9uOicsIGluc3RpdHV0aW9uQWRkcmVzcyk7XG4gICAgY29uc3QgeyBpZGVudGl0eUNvbnRyYWN0IH0gPSBhd2FpdCBnZXRDb250cmFjdHMoKTtcbiAgICBjb25zdCB0eCA9IGF3YWl0IGlkZW50aXR5Q29udHJhY3QudmVyaWZ5VXNlcihpbnN0aXR1dGlvbkFkZHJlc3MpO1xuICAgIGF3YWl0IHR4LndhaXQoKTtcbiAgICBjb25zb2xlLmxvZygnSW5zdGl0dXRpb24gdmVyaWZpZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiB2ZXJpZnlJbnN0aXR1dGlvbjonLCBlcnJvcik7XG4gICAgcmV0dXJuIGhhbmRsZUNvbnRyYWN0RXJyb3IoZXJyb3IpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0T3duZXJBZGRyZXNzID0gYXN5bmMgKCkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgaWRlbnRpdHlDb250cmFjdCB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XG4gICAgY29uc3Qgb3duZXIgPSBhd2FpdCBpZGVudGl0eUNvbnRyYWN0Lm93bmVyKCk7XG4gICAgcmV0dXJuIG93bmVyO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBvd25lciBhZGRyZXNzOicsIGVycm9yKTtcbiAgICByZXR1cm4gaGFuZGxlQ29udHJhY3RFcnJvcihlcnJvcik7XG4gIH1cbn07XG5cbi8vIEFkZCBleGFtIG1hbmFnZW1lbnQgZnVuY3Rpb25zXG5leHBvcnQgY29uc3QgY3JlYXRlRXhhbSA9IGFzeW5jIChcbiAgaWQ6IHN0cmluZyxcbiAgdGl0bGU6IHN0cmluZyxcbiAgZGVzY3JpcHRpb246IHN0cmluZyxcbiAgZGF0ZTogbnVtYmVyLFxuICBkdXJhdGlvbjogbnVtYmVyLFxuICBpcGZzSGFzaDogc3RyaW5nXG4pID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGV4YW1NYW5hZ2VtZW50Q29udHJhY3QgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xuICAgIGNvbnN0IHR4ID0gYXdhaXQgZXhhbU1hbmFnZW1lbnRDb250cmFjdC5jcmVhdGVFeGFtKGlkLCB0aXRsZSwgZGVzY3JpcHRpb24sIGRhdGUsIGR1cmF0aW9uLCBpcGZzSGFzaCk7XG4gICAgYXdhaXQgdHgud2FpdCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgZXhhbTonLCBlcnJvcik7XG4gICAgcmV0dXJuIGhhbmRsZUNvbnRyYWN0RXJyb3IoZXJyb3IpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3Qgc3VibWl0RXhhbVJlc3VsdCA9IGFzeW5jIChcbiAgZXhhbUlkOiBzdHJpbmcsXG4gIHN0dWRlbnQ6IHN0cmluZyxcbiAgc2NvcmU6IG51bWJlcixcbiAgZ3JhZGU6IHN0cmluZyxcbiAgaXBmc0hhc2g6IHN0cmluZ1xuKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBleGFtTWFuYWdlbWVudENvbnRyYWN0IH0gPSBhd2FpdCBnZXRDb250cmFjdHMoKTtcbiAgICBjb25zdCB0eCA9IGF3YWl0IGV4YW1NYW5hZ2VtZW50Q29udHJhY3Quc3VibWl0RXhhbVJlc3VsdChleGFtSWQsIHN0dWRlbnQsIHNjb3JlLCBncmFkZSwgaXBmc0hhc2gpO1xuICAgIGF3YWl0IHR4LndhaXQoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHN1Ym1pdHRpbmcgZXhhbSByZXN1bHQ6JywgZXJyb3IpO1xuICAgIHJldHVybiBoYW5kbGVDb250cmFjdEVycm9yKGVycm9yKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHVwZGF0ZUV4YW1TdGF0dXMgPSBhc3luYyAoZXhhbUlkOiBzdHJpbmcsIHN0YXR1czogc3RyaW5nKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBleGFtTWFuYWdlbWVudENvbnRyYWN0IH0gPSBhd2FpdCBnZXRDb250cmFjdHMoKTtcbiAgICBjb25zdCB0eCA9IGF3YWl0IGV4YW1NYW5hZ2VtZW50Q29udHJhY3QudXBkYXRlRXhhbVN0YXR1cyhleGFtSWQsIHN0YXR1cyk7XG4gICAgYXdhaXQgdHgud2FpdCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgZXhhbSBzdGF0dXM6JywgZXJyb3IpO1xuICAgIHJldHVybiBoYW5kbGVDb250cmFjdEVycm9yKGVycm9yKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGdldEV4YW0gPSBhc3luYyAoZXhhbUlkOiBzdHJpbmcpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGV4YW1NYW5hZ2VtZW50Q29udHJhY3QgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xuICAgIGNvbnN0IGV4YW0gPSBhd2FpdCBleGFtTWFuYWdlbWVudENvbnRyYWN0LmdldEV4YW0oZXhhbUlkKTtcbiAgICByZXR1cm4gZXhhbTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgZXhhbTonLCBlcnJvcik7XG4gICAgcmV0dXJuIGhhbmRsZUNvbnRyYWN0RXJyb3IoZXJyb3IpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0RXhhbVJlc3VsdCA9IGFzeW5jIChleGFtSWQ6IHN0cmluZywgc3R1ZGVudDogc3RyaW5nKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBleGFtTWFuYWdlbWVudENvbnRyYWN0IH0gPSBhd2FpdCBnZXRDb250cmFjdHMoKTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBleGFtTWFuYWdlbWVudENvbnRyYWN0LmdldEV4YW1SZXN1bHQoZXhhbUlkLCBzdHVkZW50KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBleGFtIHJlc3VsdDonLCBlcnJvcik7XG4gICAgcmV0dXJuIGhhbmRsZUNvbnRyYWN0RXJyb3IoZXJyb3IpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0SW5zdGl0dXRpb25FeGFtcyA9IGFzeW5jIChpbnN0aXR1dGlvbjogc3RyaW5nKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBleGFtTWFuYWdlbWVudENvbnRyYWN0IH0gPSBhd2FpdCBnZXRDb250cmFjdHMoKTtcbiAgICBjb25zdCBleGFtcyA9IGF3YWl0IGV4YW1NYW5hZ2VtZW50Q29udHJhY3QuZ2V0SW5zdGl0dXRpb25FeGFtcyhpbnN0aXR1dGlvbik7XG4gICAgcmV0dXJuIGV4YW1zO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBpbnN0aXR1dGlvbiBleGFtczonLCBlcnJvcik7XG4gICAgcmV0dXJuIGhhbmRsZUNvbnRyYWN0RXJyb3IoZXJyb3IpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0U3R1ZGVudEV4YW1zID0gYXN5bmMgKHN0dWRlbnQ6IHN0cmluZykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgZXhhbU1hbmFnZW1lbnRDb250cmFjdCB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XG4gICAgY29uc3QgZXhhbXMgPSBhd2FpdCBleGFtTWFuYWdlbWVudENvbnRyYWN0LmdldFN0dWRlbnRFeGFtcyhzdHVkZW50KTtcbiAgICByZXR1cm4gZXhhbXM7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHN0dWRlbnQgZXhhbXM6JywgZXJyb3IpO1xuICAgIHJldHVybiBoYW5kbGVDb250cmFjdEVycm9yKGVycm9yKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGVucm9sbFN0dWRlbnQgPSBhc3luYyAoZXhhbUlkOiBzdHJpbmcsIHN0dWRlbnRBZGRyZXNzOiBzdHJpbmcpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGV4YW1NYW5hZ2VtZW50Q29udHJhY3QgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xuICAgIGNvbnN0IHR4ID0gYXdhaXQgZXhhbU1hbmFnZW1lbnRDb250cmFjdC5lbnJvbGxTdHVkZW50KGV4YW1JZCwgc3R1ZGVudEFkZHJlc3MpO1xuICAgIGF3YWl0IHR4LndhaXQoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGVucm9sbGluZyBzdHVkZW50OicsIGVycm9yKTtcbiAgICByZXR1cm4gaGFuZGxlQ29udHJhY3RFcnJvcihlcnJvcik7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBnZXRDb250cmFjdCA9IGFzeW5jICgpID0+IHtcbiAgY29uc3QgeyBleGFtTWFuYWdlbWVudENvbnRyYWN0IH0gPSBhd2FpdCBnZXRDb250cmFjdHMoKTtcbiAgcmV0dXJuIGV4YW1NYW5hZ2VtZW50Q29udHJhY3Q7XG59O1xuXG5leHBvcnQgY29uc3Qgc2V0QWRtaW5Sb2xlID0gYXN5bmMgKCkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgaWRlbnRpdHlDb250cmFjdCwgc2lnbmVyIH0gPSBhd2FpdCBnZXRDb250cmFjdHMoKTtcbiAgICBjb25zdCB1c2VyQWRkcmVzcyA9IGF3YWl0IHNpZ25lci5nZXRBZGRyZXNzKCk7XG4gICAgXG4gICAgY29uc29sZS5sb2coJ1NldHRpbmcgYWRtaW4gcm9sZSBmb3IgYWRkcmVzczonLCB1c2VyQWRkcmVzcyk7XG4gICAgY29uc29sZS5sb2coJ0V4cGVjdGVkIGFkbWluIGFkZHJlc3M6JywgQURNSU5fQUREUkVTUyk7XG4gICAgXG4gICAgLy8gRmlyc3QgY2hlY2sgaWYgdGhlIGFkZHJlc3MgaXMgYWxyZWFkeSBhbiBhZG1pblxuICAgIGNvbnN0IGlzQWRtaW4gPSBhd2FpdCBpZGVudGl0eUNvbnRyYWN0LmlzQWRtaW4odXNlckFkZHJlc3MpO1xuICAgIGNvbnNvbGUubG9nKCdJcyBhbHJlYWR5IGFkbWluPycsIGlzQWRtaW4pO1xuICAgIFxuICAgIGlmIChpc0FkbWluKSB7XG4gICAgICBjb25zb2xlLmxvZygnVXNlciBpcyBhbHJlYWR5IGFuIGFkbWluJyk7XG4gICAgICByZXR1cm4geyBzdGF0dXM6ICdleGlzdGluZycsIGlzQWRtaW46IHRydWUgfTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyB0aGUgY29uZmlndXJlZCBhZG1pbiBhZGRyZXNzXG4gICAgaWYgKEFETUlOX0FERFJFU1MgJiYgdXNlckFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gQURNSU5fQUREUkVTUy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICBjb25zb2xlLmxvZygnQWRkcmVzcyBtYXRjaGVzIGNvbmZpZ3VyZWQgYWRtaW4sIGFkZGluZyBhcyBhZG1pbi4uLicpO1xuICAgICAgXG4gICAgICAvLyBGaXJzdCB0cnkgdG8gcmVnaXN0ZXIgYXMgYWRtaW4gaWYgbm90IGFscmVhZHkgcmVnaXN0ZXJlZFxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgcm9sZSA9IGF3YWl0IGlkZW50aXR5Q29udHJhY3QuZ2V0VXNlclJvbGUodXNlckFkZHJlc3MpO1xuICAgICAgICBpZiAocm9sZSA9PT0gMCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdSZWdpc3RlcmluZyBhZG1pbiB1c2VyIGZpcnN0Li4uJyk7XG4gICAgICAgICAgY29uc3QgcmVnVHggPSBhd2FpdCBpZGVudGl0eUNvbnRyYWN0LnJlZ2lzdGVyVXNlcihVU0VSX1JPTEVTLkFETUlOLCBcIlwiKTtcbiAgICAgICAgICBhd2FpdCByZWdUeC53YWl0KCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgaWYgKCFlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdVc2VyIGRvZXMgbm90IGV4aXN0JykpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB1c2VyIGRvZXNuJ3QgZXhpc3QsIHJlZ2lzdGVyIHRoZW0gYXMgYWRtaW5cbiAgICAgICAgY29uc29sZS5sb2coJ1JlZ2lzdGVyaW5nIG5ldyBhZG1pbiB1c2VyLi4uJyk7XG4gICAgICAgIGNvbnN0IHJlZ1R4ID0gYXdhaXQgaWRlbnRpdHlDb250cmFjdC5yZWdpc3RlclVzZXIoVVNFUl9ST0xFUy5BRE1JTiwgXCJcIik7XG4gICAgICAgIGF3YWl0IHJlZ1R4LndhaXQoKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVmVyaWZ5IHRoZSB1c2VyXG4gICAgICBjb25zb2xlLmxvZygnVmVyaWZ5aW5nIGFkbWluIHVzZXIuLi4nKTtcbiAgICAgIGNvbnN0IHZlcmlmeVR4ID0gYXdhaXQgaWRlbnRpdHlDb250cmFjdC52ZXJpZnlVc2VyKHVzZXJBZGRyZXNzKTtcbiAgICAgIGF3YWl0IHZlcmlmeVR4LndhaXQoKTtcbiAgICAgIFxuICAgICAgLy8gQWRkIGFkbWluIHJvbGVcbiAgICAgIGNvbnNvbGUubG9nKCdBZGRpbmcgYWRtaW4gcm9sZS4uLicpO1xuICAgICAgY29uc3QgdHggPSBhd2FpdCBpZGVudGl0eUNvbnRyYWN0LmFkZEFkbWluKHVzZXJBZGRyZXNzKTtcbiAgICAgIGF3YWl0IHR4LndhaXQoKTtcbiAgICAgIGNvbnNvbGUubG9nKCdTdWNjZXNzZnVsbHkgYWRkZWQgYXMgYWRtaW4nKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHsgc3RhdHVzOiAnc3VjY2VzcycsIGlzQWRtaW46IHRydWUgfTtcbiAgICB9XG4gICAgXG4gICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IGNvbmZpZ3VyZWQgYWRtaW4gYWRkcmVzc2VzIGNhbiBiZSBzZXQgYXMgYWRtaW4nKTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNldHRpbmcgYWRtaW4gcm9sZTonLCBlcnJvcik7XG4gICAgcmV0dXJuIGhhbmRsZUNvbnRyYWN0RXJyb3IoZXJyb3IpO1xuICB9XG59OyAiXSwibmFtZXMiOlsiQ29udHJhY3QiLCJmb3JtYXRVbml0cyIsImdldEFkZHJlc3MiLCJFeGFtTWFuYWdlbWVudEFCSSIsImdldFByb3ZpZGVyIiwiZ2V0U2lnbmVyIiwiRVhQRUNURURfTkVUV09SSyIsInZhbGlkYXRlTmV0d29yayIsImhhbmRsZUNvbnRyYWN0RXJyb3IiLCJnZXRDb25maWciLCJ2YWxpZGF0ZUNvbmZpZyIsIklkZW50aXR5QUJJIiwiQ2VydGlmaWNhdGVzQUJJIiwiSURFTlRJVFlfQ09OVFJBQ1RfQUREUkVTUyIsIkNFUlRJRklDQVRFU19DT05UUkFDVF9BRERSRVNTIiwiQURNSU5fQUREUkVTUyIsIkVYQU1fTUFOQUdFTUVOVF9BRERSRVNTIiwidmFsaWRhdGVFbnYiLCJFcnJvciIsImNvbnNvbGUiLCJsb2ciLCJDSEFJTl9JRCIsIk5FVFdPUktfVVJMIiwiZXJyb3IiLCJjaGFpbklkIiwicnBjVXJsIiwiVVNFUl9ST0xFUyIsIk5PTkUiLCJTVFVERU5UIiwiSU5TVElUVVRJT04iLCJFTVBMT1lFUiIsIkFETUlOIiwicm9sZU1hcCIsImdldENvbnRyYWN0cyIsIklkZW50aXR5IiwiQ2VydGlmaWNhdGVzIiwiQWRtaW4iLCJwcm92aWRlciIsInNpZ25lciIsInVzZXJBZGRyZXNzIiwidXNlckJhbGFuY2UiLCJnZXRCYWxhbmNlIiwiaWRlbnRpdHlDb250cmFjdCIsImNvZGUiLCJnZXRDb2RlIiwibGVuZ3RoIiwiY2VydGlmaWNhdGVzQ29udHJhY3QiLCJleGFtTWFuYWdlbWVudENvbnRyYWN0IiwibWVzc2FnZSIsInJlYXNvbiIsInJlZ2lzdGVyVXNlciIsInJvbGUiLCJ0b0xvd2VyQ2FzZSIsInNldEFkbWluUm9sZSIsInJvbGVWYWx1ZSIsInVuZGVmaW5lZCIsImV4aXN0aW5nUm9sZSIsImdldFVzZXJSb2xlIiwiaXNWZXJpZmllZCIsInZlcmlmeVR4IiwidmVyaWZ5VXNlciIsIndhaXQiLCJzdGF0dXMiLCJpbmNsdWRlcyIsInR4IiwiaGFzaCIsInJlY2VpcHQiLCJ2ZXJpZnlFcnJvciIsIndhcm4iLCJ0cmFuc2FjdGlvbiIsImFkZHJlc3MiLCJpc3N1ZUNlcnRpZmljYXRlIiwic3R1ZGVudEFkZHJlc3MiLCJpcGZzSGFzaCIsInZlcmlmeUNlcnRpZmljYXRlIiwiY2VydGlmaWNhdGVJZCIsImlzVmFsaWQiLCJnZXRDZXJ0aWZpY2F0ZXMiLCJjZXJ0aWZpY2F0ZXMiLCJpc1ZlcmlmaWVkVXNlciIsImlzT3duZXIiLCJvd25lckFkZHJlc3MiLCJvd25lciIsImlzT3duZXJSb2xlIiwidmVyaWZ5SW5zdGl0dXRpb24iLCJpbnN0aXR1dGlvbkFkZHJlc3MiLCJnZXRPd25lckFkZHJlc3MiLCJjcmVhdGVFeGFtIiwiaWQiLCJ0aXRsZSIsImRlc2NyaXB0aW9uIiwiZGF0ZSIsImR1cmF0aW9uIiwic3VibWl0RXhhbVJlc3VsdCIsImV4YW1JZCIsInN0dWRlbnQiLCJzY29yZSIsImdyYWRlIiwidXBkYXRlRXhhbVN0YXR1cyIsImdldEV4YW0iLCJleGFtIiwiZ2V0RXhhbVJlc3VsdCIsInJlc3VsdCIsImdldEluc3RpdHV0aW9uRXhhbXMiLCJpbnN0aXR1dGlvbiIsImV4YW1zIiwiZ2V0U3R1ZGVudEV4YW1zIiwiZW5yb2xsU3R1ZGVudCIsImdldENvbnRyYWN0IiwiaXNBZG1pbiIsInJlZ1R4IiwiYWRkQWRtaW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./utils/contracts.ts\n"));

/***/ })

});